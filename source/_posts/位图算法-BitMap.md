---
title: 位图算法--BitMap
date: 2019-08-08 14:53:50
tags:
	- 算法
---

### 抛出一个问题

有这样一个需求，给一个系统中的用户加上标签，方便统计特定特征的用户群，就像下图这样：

![用户标签](用户标签.png)



刚拿到需求，我们可以这样设计，在数据库中增加一张表，用来记录那个用户有那些特征，就像这样：

| name | age  | sex  | phone |
| ---- | ---- | ---- | ----- |
| 小叶   | 90后  | 男    | 一加    |
| 小李   | 90后  | 女    | 一加    |
| 小张   | 80后  | 男    | 小米    |

<!-- more -->

需要统计90后并且使用一加手机的用户，我们可以这样写sql

```sql
select * from tab where age='90后' and phone='一加'
```

上面是一个解决方案，但是存在问题，用户的标签数量不是固定的，那每次新增一个标签就需要去修改表结构，而且列数很多的话，写出来的sql和面条一样。



### BitMap介绍

这时候就要掏出我们的位图算法--BitMap啦，那么什么是BitMap？

| index |  9   |  8   |  7   |  6   |  5   |  4   |  3   |  2   |  1   |  0   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| value |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   |

上面是一个长度为10的BitMap，刚开始时所有位都是0，表示这个BitMap中还没有存放值，那现在我们将整数7存入这个BitMap中，存放后结果为

| index |  9   |  8   |   7   |  6   |  5   |  4   |  3   |  2   |  1   |  0   |
| :---: | :--: | :--: | :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| value |  0   |  0   | **1** |  0   |  0   |  0   |  0   |  0   |  0   |  0   |

那如果再把整数3和4存放入BitMap中，得到结果

| index |  9   |  8   |   7   |  6   |  5   |   4   |   3   |  2   |  1   |  0   |
| :---: | :--: | :--: | :---: | :--: | :--: | :---: | :---: | :--: | :--: | :--: |
| value |  0   |  0   | **1** |  0   |  0   | **1** | **1** |  0   |  0   |  0   |

要问这时BitMap中存放了那些元素，那是一目了然的7,4,3这几个。BitMap不仅方便查询，还可以去除掉重复的整形数。



### 怎么应用

那看到这里有小伙伴可能有疑问了，怎么将BitMap应用到上面的问题中呢？

问的好！！！

用户可能有数十万个，那一个用户建立一个BitMap的方式肯定是不妥的。我们可以换一种思路，将标签抽象为一个个的BitMap，然后BitMap中存放对应用户的ID。

第一步：为用户建立一个映射关系表

| name | age  | sex  | phone |
| ---- | ---- | ---- | ----- |
| 小叶   | 90后  | 男    | 一加    |
| 小李   | 90后  | 女    | 一加    |
| 小张   | 80后  | 男    | 小米    |

对应的映射为：

| ID   | 用户名  |
| ---- | ---- |
| 1    | 小叶   |
| 2    | 小李   |
| 3    | 小张   |

第二步：为每个标签创建BitMap

| sex  | BitMap |
| ---- | ------ |
| 男    | 1,3    |
| 女    | 2      |

| age  | BitMap |
| ---- | ------ |
| 90后  | 1,2    |
| 80后  | 3      |

那看到这里又有小伙伴要问了，要查90后的男性用户怎么查呢？

问得好！！！

这时候就需要用到BitMap的‘与’和‘或’等操作了

首先拿到男性标签和90后标签的BitMap

男性用户（0000001010B）：

| index |  9   |  8   |  7   |  6   |  5   |  4   |   3   |  2   |   1   |  0   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :---: | :--: | :---: | :--: |
| value |  0   |  0   |  0   |  0   |  0   |  0   | **1** |  0   | **1** |  0   |
90后用户（0000000110B）：

| index |  9   |  8   |  7   |  6   |  5   |  4   |  3   |   2   |   1   |  0   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :---: | :---: | :--: |
| value |  0   |  0   |  0   |  0   |  0   |  0   |  0   | **1** | **1** |  0   |

这两个BitMap相与就能得到符合‘90后’和‘男’两个标签的用户

（0000001010B  &  0000000110B  =  0000000010B）

| index |  9   |  8   |  7   |  6   |  5   |  4   |  3   |  2   |   1   |  0   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :---: | :--: |
| value |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  0   | **1** |  0   |

最后结果很明显可以看出，得到了ID为1的用户是符合查询结果的。那如果需要查找90后或者是男性的用户，就用这两个标签的BitMap相或，最后得到符合结果的BitMap。

**在JDK中的BitSet就是BitMap算法的实现，它底层是使用Long数组去存放值的。**也有第三方的实现，如谷歌的EWAHCompressedBitMap。



### BitMap的缺点

忘记说优点了，BitMap的优点主要有下面几个：

> 1.占用空间小，存储同样的数据，使用HashMap或HashSet的话需要存放int，众所周知int是32位的，而BitMap每存放一个数只占用一位，节省32倍空间咧。
>
> 2.BitMap在做交集和并集时有极大的便利，并且位运算的性能也比较高。

那BitMap缺点是什么呢，它的主要缺点就是**不支持非运算**，如果我要查不用小米手机的用户，那BitMap是无法直接得出结果的。

比如下面是小米用户的BitMap

| index |  9   |  8   |  7   |  6   |  5   |  4   |   3   |  2   |  1   |  0   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :---: | :--: | :--: | :--: |
| value |  0   |  0   |  0   |  0   |  0   |  0   | **1** |  0   |  0   |  0   |

进行非运算后，得到结果

| index |   9   |   8   |   7   |   6   |   5   |   4   |  3   |   2   |   1   |   0   |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :--: | :---: | :---: | :---: |
| value | **1** | **1** | **1** | **1** | **1** | **1** |  0   | **1** | **1** | **1** |

这个结果显然是错误的。

那如果在实际使用中，需要进行这样的运算怎么办呢？这时我们需要一个全量的BitMap，和目标标签的BitMap进行**异或**操作就能得到需要的结果。

小米用户（0000001000B）：

| index |  9   |  8   |  7   |  6   |  5   |  4   |   3   |  2   |  1   |  0   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :---: | :--: | :--: | :--: |
| value |  0   |  0   |  0   |  0   |  0   |  0   | **1** |  0   |  0   |  0   |

全量用户（0000001110B）：

| index |  9   |  8   |  7   |  6   |  5   |  4   |   3   |   2   |   1   |  0   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :---: | :---: | :---: | :--: |
| value |  0   |  0   |  0   |  0   |  0   |  0   | **1** | **1** | **1** |  0   |

进行**异或**操作，即相同位为0，不同位为1：

（0000001000B  XOR  0000001110B  =  0000000110B）

| index |  9   |  8   |  7   |  6   |  5   |  4   |  3   |  2   |  1   |  0   |
| :---: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: | :--: |
| value |  0   |  0   |  0   |  0   |  0   |  0   |  0   |  1   |  1   |  0   |

