---
title: synchronized和Lock的区别
date: 2018-01-08 19:36:58
tags:

	- Java

	- 线程
---



## 1.Thread的几个重要方法

我们先了解一下Thread的几个重要方法：
​	a、start()方法，调用该方法开始执行该线程；
​	b、stop()方法，调用该方法强制结束该线程执行；
​	c、join方法，调用该方法等待该线程结束。
​	d、sleep()方法，调用该方法该线程进入等待。
​	e、run()方法，调用该方法直接执行线程的run()方法，但是线程调用start()方法时也会运行run()方法，区别就是一个是由线程调度运行run()方法，一个是直接调用了线程中的run()方法！！

​	看到这里，可能有些人就会问啦，那wait()和notify()呢？要注意，其实wait()与notify()方法是Object的方法，不是Thread的方法！！同时，wait()与notify()会配合使用，分别表示线程挂起和线程恢复。

​	这里还有一个很常见的问题，顺带提一下：wait()与sleep()的区别，简单来说wait()会释放对象锁而sleep()不会释放对象锁。这些问题有很多的资料，不再赘述。



<!-- more -->

## 2.线程的状态

![线程的状态](线程的状态.png)

线程总共有5大状态。

- 新建状态：新建线程对象，并没有调用start()方法之前
- 就绪状态：调用start()方法之后线程就进入就绪状态，但是并不是说只要调用start()方法线程就马上变为当前线程，在变为当前线程之前都是为就绪状态。值得一提的是，线程在睡眠和挂起中恢复的时候也会进入就绪状态哦。
- 运行状态：线程被设置为当前线程，开始执行run()方法。就是线程进入运行状态
- 阻塞状态：线程被暂停，比如说调用sleep()方法后线程就进入阻塞状态
- 死亡状态：线程执行结束



## 3.锁的类型

- 可重入锁：在执行对象中所有同步方法不用再次获得锁
- 可中断锁：在等待获取锁过程中可中断
- 公平锁： 按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利
- 读写锁：对资源读取和写入的时候拆分为2部分处理，读的时候可以多线程一起读，写的时候必须同步地写



## 4.synchronized和Lock的区别

| 类别   | synchronized                             | Lock                                     |
| ---- | ---------------------------------------- | ---------------------------------------- |
| 存在层次 | JAVA的关键字，在jvm层面上的                        | 是一个类                                     |
| 锁的释放 | 1.已获取锁的线程执行完代码，释放锁  2.线程执行发生异常时，jvm会让线程释放锁 | 在finally中必须释放锁，不然容易造成线程死锁                |
| 锁的获取 | 假如A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待。         | 分情况而定，Lock有多个获取锁的方式，大致是可以尝试获得所，线程可以不用一直等待 |
| 锁状态  | 无法判断                                     | 可以判断                                     |
| 锁类型  | 可重入 不可中断 非公平                             | 可重入 可中断 可公平(可非公平)                        |
| 性能   | 少量同步                                     | 大量同步                                     |

