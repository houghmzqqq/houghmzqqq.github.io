---
title: 分布式事务
date: 2020-11-02 17:12:07
tags:
	- 数据库
	- 分布式
	- 事务
---

## 1.事务的基本概念

​		在我们了解分布式事务之前，我们首先需要知道什么是事务，对它的基本概念和实现原理有一个底。事务有四个特性以及四种隔离级别，下面简单记录一下。



###  1.1事务的特性

​		事务有四个特性，分别为原子性、隔离性、持久性、一致性。

##### 原子性：

​		原子性是指在同一个事务中的所有数据库操作，要么全部成功，要么全部失败。

##### 隔离性：

​		当多个事务并发执行时，一个事务的操作不会对其他事务造成影响。比如两个事务T1和T2对同一张表进行操作，在T2看来，T1要么在T2开始前结束，要么在T2结束后开始，它们看起来是串行执行的。

##### 持久性：

​		当一个事务被提交时，它对数据库的修改是永久性的。

##### 一致性：

​		当数据从一个状态转换为另一个状态时，数据库的完整性保持稳定。简单来说，有点像现实生活中的质量守恒。比如我有一瓶500ML的可乐，我向杯子里倒入了100ML，现在可乐瓶子的状态变了，它还剩下400ML可乐，杯子的状态变了，它有了100ML可乐，但是可乐的总量是不变的，还是500ML。如果这时候瓶子里还剩450ML可乐，杯子里有150ML可乐，那么他的完整性就被破坏了，这在现实生活中也是不可能发生的。



<!-- more -->

###  1.2并发事务时可能发生的问题

​	在了解事务的隔离级别之前，我们需要知道它是为了解决什么问题的，所以我们需要知道在没有隔离级别的情况下，并发事务会出现的问题。

##### 丢失更新

​		丢失更新又分第一类丢失更新、第二类丢失更新。

​		1）第一类丢失更新：事务T1和事务T2同时读取了同一行数据，事务T1成功更新数据，事务T2提交失败进行回退操作，导致T1的更新结果丢失

| 时间 | 事务T1                        | 事务T2                                    |
| :--- | ----------------------------- | ----------------------------------------- |
| M1   | 查询表A中第N行数据 i=100      |                                           |
| M2   |                               | 查询表A中第N行数据100                     |
| M3   | 进行计算 i = i - 10; 这时i=90 |                                           |
| M4   | 提交事务T1                    |                                           |
| M5   |                               | 出现错误，执行回退操作                    |
| M6   |                               | 表A的第N行数据被回退为100，丢失了T1的更新 |

​		2）第二类更新丢失：事务T1和事务T2同时读取了同一行数据，事务T1成功更新数据，事务T2也成功提交数据，将T1的提交覆盖了。

| 时间 | 事务T1                          | 事务T2                           |
| ---- | ------------------------------- | -------------------------------- |
| M1   | 查询表A中第N行数据100           |                                  |
| M2   |                                 | 查询表A中第N行数据100            |
| M3   | 进行计算 i = i - 10; 这时i = 90 |                                  |
| M4   | 提交事务T1                      |                                  |
| M5   |                                 | 进行计算 i = i + 10; 这时i = 110 |
| M6   |                                 | 提交事务T2，覆盖了T1的更新       |

##### 脏读

​		事务T1查询数据并进行修改，但是还未提交，这时事务T2读取了事务T1未提交的修改；事务T1执行回退操作，这时事务T2持有的数据就是脏数据，如果事务T2那这个脏数据去做业务逻辑运算，则结果会出差错。

| 时间 | 事务T1                           | 事务T2                           |
| ---- | -------------------------------- | :------------------------------- |
| M1   | 查询表A第N行数据 i = 100         |                                  |
| M2   | 进行计算 i = i - 10; 这时 i = 90 |                                  |
| M3   |                                  | 读取事务T1未提交的数据 i = 90    |
| M4   | 出现错误，执行回退操作           |                                  |
| M5   |                                  | 进行计算 i = i + 10; 这时i = 100 |
| M6   |                                  | 提交事务T2                       |

##### 幻读

​		幻读是指两次读取数据时，返回的数据行数不一样。事务T1读取了数据，事务T2插入了一条数据，事务T1再次读取数据，这时两次读取的数据数量不一致。

| 时间 | 事务T1                       | 事务T2               |
| ---- | ---------------------------- | -------------------- |
| M1   | 统计一班的学生总数，查得50人 |                      |
| M2   |                              | 向一班加入一个插班生 |
| M3   |                              | 提交事务T2           |
| M4   | 统计一班的学生总数，查得51人 |                      |

##### 不可重复读

​		不可重复读是指，同一个事务，读取同一行数据两次，得到的结果不一样。事务T1读取数据，事务T2修改数据并提交，事务T1再读取数据，这时得到两个不同的结果。 

| 时间 | 事务T1                       | 事务T2                            |
| ---- | ---------------------------- | --------------------------------- |
|      | 查询表A第N行记录 i = 100     |                                   |
|      |                              | 查询表A第N行记录 i = 100          |
|      |                              | 进行计算 i = i + 10；这时 i = 110 |
|      |                              | 提交事务T2                        |
|      | 再次查询表A第N行记录 i = 110 |                                   |

​    	不可重复读和幻读的区别是，不可重复读指的是同一行数据，幻读是指事务操作过程中，有其他事务插入或删除数据。

​		不可重复读和脏读的区别，脏读是读取其他事务未提交的数据，不可重复读是读取了事务已提交的数据。



###  1.3事务的隔离级别

​		针对并发事务中的几个问题，划分出了解决对应问题的四个隔离级别。针对不同的场景和业务需要，选择适用的隔离级别。

##### 可读未提交

​		顾名思义，这种隔离级别可以让一个事务读取其他事务未提交的数据，它不能解决上述并发事务产生的任何一个问题。

##### 可读已提交

​		可以防止脏读的发生，但是不可重复读、幻读还是会发生。

##### 可重复读

​		开启这个级别时，当一个事务读取一行数据时，其他事务不能对这条数据进行修改。可以避免脏读、不可重复读的问题。

##### 串行

​		这是最高的级别，这种隔离级别下，多个事务会串行地执行，相互之间不会有影响，可以解决所有问题。但是性能也相对比较低。



## 2.分布式事务

​		上面介绍了事务的基本概念，对于在单体应用上使用事务的话，是足够应付的。但是随着分布式、微服务愈发的火热，单体的应用逐渐式微，原本的事务也不能满足分布式的要求，所以需要一套能够应用于分布式系统的事务体系，也就是分布式事务。

​		分布式事务有几种方案，每种方案又有不同的实现方式，下面逐一进行介绍。





