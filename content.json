[{"title":"JVM的GC原理","date":"2020-03-11T07:39:34.000Z","path":"2020/03/11/JVM的GC原理/","text":"​ GC是Java虚拟机中至关重要的一部分，然而由于Java良好的垃圾自动回收机制，使我们平时开发过程中并没有什么感觉，我们不必像c、c++一样写一堆的析构函数，在日常的开发中不必为如何清理内存空间而烦恼。 什么是垃圾回收(GC)​ 垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。 ​ Java 语言出来之前，大家都在拼命的写 C 或者 C++ 的程序，而此时存在一个很大的矛盾，C++ 等语言创建对象要不断的去开辟空间，不用的时候又需要不断的去释放控件，既要写构造函数，又要写析构函数，很多时候都在重复的 allocated，然后不停的析构。于是，有人就提出，能不能写一段程序实现这块功能，每次创建，释放控件的时候复用这段代码，而无需重复的书写呢？ ​ 1960年，基于 MIT 的 Lisp 首先提出了垃圾回收的概念，而这时 Java 还没有出世呢！所以实际上 GC 并不是Java的专利，GC 的历史远远大于 Java 的历史！ 怎样定义垃圾​ 既然要回收，我们首先要知道哪些东西是垃圾、是需要回收的，这里介绍两种标记垃圾的算法 1.引用计数法​ 引用计数法是指，在对象头中新增一个标签，记录给对象被引用的次数，当对象被引用次数为零时，则标记该对象为可回收 12String m = new String(&quot;Jack&quot;);m = null; 首先新建一个对象，这是m引用了”Jack”对象，所以”Jack”对象不会被标记回收 将m设置为null后，”Jack”的引用次数为零，被标记为可回收对象 ​ 引用计数法虽然可以标记出可回收对象，但是却有一个很大的问题，它无法处理两个对象相互引用的情况 123456789101112131415public class ReferenceCountingGC &#123; public Object instance; public ReferenceCountingGC(String name)&#123;&#125;&#125;public static void testGC()&#123; ReferenceCountingGC a = new ReferenceCountingGC(&quot;objA&quot;); ReferenceCountingGC b = new ReferenceCountingGC(&quot;objB&quot;); a.instance = b; b.instance = a; a = null; b = null;&#125; 简单描述上面代码： a.定义两个对象 b.两个对象相互引用 c.两个对象设置为null ​ 最后由于a，b两个对象相互调用，它们的引用计数永远不会为零，这两个对象就成钉子户了，再也不会被GC回收。 2.可达性分析法​ 可达性分析法的思路是，通过一些引用链的对象作为起点(GC Roots)，从这些起点向下搜索，搜索过的路径称为(Reference Chain)参考链，当一个对象无法链接到(GC Roots)时(该节点到GC Roots 不可达)，则这个对象为可回收对象 ​ 通过可达性算法，成功解决了引用计数所无法解决的问题-“循环依赖”，只要你无法与 GC Root 建立直接或间接的连接，系统就会判定你为可回收对象。那这样就引申出了另一个问题，哪些属于 GC Root。 在Java中，可以作为GC Root 的对象有一下四种： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中 JNI（即一般说的 Native 方法）引用的对象 虚拟机栈(栈帧中的本地变量表)12345678public class StackLocalParameter &#123; public StackLocalParameter(String name)&#123;&#125;&#125;public static void testGC()&#123; StackLocalParameter s = new StackLocalParameter(&quot;localParameter&quot;); s = null;&#125; 这里的s被压入了虚拟机栈中，可以被看做GC Root，当把s设置为null，”localParameter”对象断开了与GC Root 的引用链而被标记为可回收对象 方法去中类静态属性应用的对象12345678910public class MethodAreaStaicProperties &#123; public static MethodAreaStaicProperties m; public MethodAreaStaicProperties(String name)&#123;&#125;&#125;public static void testGC()&#123; MethodAreaStaicProperties s = new MethodAreaStaicProperties(&quot;properties&quot;); s.m = new MethodAreaStaicProperties(&quot;parameter&quot;); s = null;&#125; s 为 GC Root，s 置为 null，经过 GC 后，s 所指向的 properties 对象由于无法与 GC Root 建立关系被回收。 而 m 作为类的静态属性，也属于 GC Root，parameter 对象依然与 GC root 建立着连接，所以此时 parameter 对象并不会被回收。 方法区中常量引用的对象123456789public class MethodAreaStaicProperties &#123; public static final MethodAreaStaicProperties m = MethodAreaStaicProperties(&quot;final&quot;); public MethodAreaStaicProperties(String name)&#123;&#125;&#125;public static void testGC()&#123; MethodAreaStaicProperties s = new MethodAreaStaicProperties(&quot;staticProperties&quot;); s = null;&#125; m 即为方法区中的常量引用，也为 GC Root，s 置为 null 后，final 对象也不会被回收。 本地方法栈中引用的对象 任何 Native 接口都会使用某种本地方法栈，实现的本地方法接口是使用 C 连接模型的话，那么它的本地方法栈就是 C 栈。当线程调用 Java 方法时，虚拟机会创建一个新的栈帧并压入 Java 栈。然而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不再在线程的 Java 栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法。 怎么回收垃圾标记出了需要回收的垃圾之后，我们需要考虑怎么样去回收垃圾更快、更好，下面是两种常见的回收算法。 1.标记–清除算法 标记清除算法的思路是，现在内存中将可回收对象标记出来，然后直接清除掉。 这种方法简单便捷，但是也有很大问题。我们知道，内存空间是连续的，当我们需要使用2M的内存时，必须要有一个2M以上的内存空间，2个1M的内存空间是无法使用的。标记清除算法会产生大量的内存碎片，破坏内存空间的连续性，导致我们有很多的内存空间缺无法使用。 2.复制算法 复制算法是将内存空间划分为大小相等的两块，每次只使用其中一块。当使用中的内存块进行GC时，将存活对象复制到另一个内存块中，将使用中的内存块清空。 复制算法的缺陷也很明显，对内存空间的牺牲太大，合着我这140平的大三房，只能当70平米的小两房来使？ 3.标记整理法 标记整理法会将不同状态的对象进行分类并排序，将存活对象排列在内存前端，可回收对象放在其后，排列完成后再将垃圾对象进行回收清理。 标记整理算法一方面在标记-清除算法上做了升级，解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。看起来很美好，但从上图可以看到，它对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法要差很多。 JVM使用的是分代收集的方法，这是结合上面的三种方法而形成的，一般把JVM堆分为新生代和老年代，在不同区域根据实际情况使用不同的算法。 内存模型和回收策略 堆内存是JVM中最大的一块内存区域，GC的主要清理对象也是堆。堆主要分为新生代和老年代，新生代中又有Eden和Survivor From、Survivor To区。需要提一下，在Java1.8之后，原本方法区中的永久代改为了元空间，它在逻辑上是属于堆中的，但是又将它称为NON–Heap(非堆)，应该是为了将它和堆区分开。 EdenIBM 公司的专业研究表明，有将近98%的对象是朝生夕死，所以针对这一现状，大多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC，Minor GC 相比 Major GC 更频繁，回收速度也更快。 通过 Minor GC 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区）。 Survivorsurvivor区相当于Old区的缓冲区域，当Eden进行Minor GC后，存活的对象会转移到Survivor Form中，如果Form区满了，则直接转移到Old区中。那么Survivor To区是做什么的呢？当第二次Minor GC到来时，Eden和From的存活对象转移到To区，Eden和From区清空，这时From和To的职能调换。每经历一次这个过程，Survivor 中的存活对象年龄会+1，当年龄增长到15岁后，就会将对象转移到Old区。 为啥需要？ 不就是新生代到老年代么，直接 Eden 到 Old 不好了吗，为啥要这么复杂。想想如果没有 Survivor 区，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代，老年代很快就会被填满。而有很多对象虽然一次 Minor GC 没有消灭，但其实也并不会蹦跶多久，或许第二次，第三次就需要被清除。这时候移入老年区，很明显不是一个明智的决定。 所以，Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。Survivor 的预筛选保证，只有经历16次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。 为啥需要俩？ 设置两个 Survivor 区最大的好处就是解决内存碎片化。 我们先假设一下，Survivor 如果只有一个区域会怎样。Minor GC 执行后，Eden 区被清空了，存活的对象放到了 Survivor 区，而之前 Survivor 区中的对象，可能也有一些是需要被清除的。问题来了，这时候我们怎么清除它们？在这种场景下，我们只能标记清除，而我们知道标记清除最大的问题就是内存碎片，在新生代这种经常会消亡的区域，采用标记清除必然会让内存产生严重的碎片化。因为 Survivor 有2个区域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，From 与 To 职责兑换，这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域，以此反复。 这种机制最大的好处就是，整个过程中，永远有一个 Survivor space 是空的，另一个非空的 Survivor space 是无碎片的。那么，Survivor 为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果 Survivor 区再细分下去，每一块的空间就会比较小，容易导致 Survivor 区满，两块 Survivor 区可能是经过权衡之后的最佳方案。 Old区老年代占了堆内存2/3的空间，只有在Major GC(full GC)时才会清理老年代，Major GC时会发生(Stop-The-World)程序暂停现象。内存越大，STW时间就越长。所以并不是内存空间越大越好。由于老年代里的对象是存活率较高的对象，所以使用标记–整理算法是最合适的。 大对象 大对象指需要大量连续内存空间的对象，这部分对象不管是不是“朝生夕死”，都会直接进到老年代。这样做主要是为了避免在 Eden 区及2个 Survivor 区之间发生大量的内存复制。当你的系统有非常多“朝生夕死”的大对象时，得注意了。 长期存活对象 虚拟机给每个对象定义了一个对象年龄（Age）计数器。正常情况下对象会不断的在 Survivor 的 From 区与 To 区之间移动，对象在 Survivor 区中每经历一次 Minor GC，年龄就增加1岁。当年龄增加到15岁时，这时候就会被转移到老年代。当然，这里的15，JVM 也支持进行特殊设置，但是只能够比15小，因为对象的年龄是定义在对象头中的，用4位二进制表示。 动态对象年龄 虚拟机并不重视要求对象年龄必须到15岁，才会放入老年区，如果 Survivor 空间中相同年龄所有对象大小的总合大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进去老年区，无需等你“成年”。 GC调优1.打印GC日志 -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -Xloggc:./gc.log Tomcat可以直接加载JAVA_OPTS变量里 2.分析日志得到关键性指标 3.分析GC原因，调优JVM参数 主要目标是减少或消灭Full GC的次数","tags":[{"name":"JVM","slug":"JVM","permalink":"http://houghmzqqq.gihub.io/tags/JVM/"},{"name":"GC","slug":"GC","permalink":"http://houghmzqqq.gihub.io/tags/GC/"}]},{"title":"数据结构之排序","date":"2020-03-02T02:13:33.000Z","path":"2020/03/02/数据结构之排序/","text":"1. 插入排序1.1 直接插入排序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对如下序列进行直接插入排序：{18,8,56,9,68,8} 1）.将第一个数据元素放入序列，即{18} 2）.插入下一个元素，得到{8,18} 3）.循环第二步，直至最后一个元素插入完毕 1.2 shell排序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设有一个序列{18,8,15,9,5,3,8,16}，长度为n=8. 1）.对它进行划分，分成增量t=n/2，长度至多为2的多个分组，对每一个分组进行直接插入排序； 2）.然后继续划分，分成增量t=n/2，长度至多为4的多个分组，对分组排序； 3）.后面依次类推，直到增量为1. 1.3快速排序​ __快速排序__的基本思想是，通过一轮的排序将序列分割成独立的两部分，其中一部分序列的关键字（这里主要用值来表示）均比另一部分关键字小。继续对长度较短的序列进行同样的分割，最后到达整体有序。在排序过程中，由于已经分开的两部分的元素不需要进行比较，故减少了比较次数，降低了排序时间。 下面用一个例子说明快速排序的过程， ​ i = j = 3， 这样序列就这样分割成了两部分，左边部分{15， 30， 17} 均小于 基准值（46）；右边部分 {56， 90，95，82}，均大于基准值。这样子我们就达到了分割序列的目标。在接着对子序列用同样的办法进行分割，直至子序列不超过一个元素，那么排序结束，整个序列处于有序状态。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://houghmzqqq.gihub.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"位图算法--BitMap","date":"2019-08-08T06:53:50.000Z","path":"2019/08/08/位图算法-BitMap/","text":"抛出一个问题有这样一个需求，给一个系统中的用户加上标签，方便统计特定特征的用户群，就像下图这样： 刚拿到需求，我们可以这样设计，在数据库中增加一张表，用来记录那个用户有那些特征，就像这样： name age sex phone 小叶 90后 男 一加 小李 90后 女 一加 小张 80后 男 小米 需要统计90后并且使用一加手机的用户，我们可以这样写sql 1select * from tab where age=&#x27;90后&#x27; and phone=&#x27;一加&#x27; 上面是一个解决方案，但是存在问题，用户的标签数量不是固定的，那每次新增一个标签就需要去修改表结构，而且列数很多的话，写出来的sql和面条一样。 BitMap介绍这时候就要掏出我们的位图算法–BitMap啦，那么什么是BitMap？ index 9 8 7 6 5 4 3 2 1 0 value 0 0 0 0 0 0 0 0 0 0 上面是一个长度为10的BitMap，刚开始时所有位都是0，表示这个BitMap中还没有存放值，那现在我们将整数7存入这个BitMap中，存放后结果为 index 9 8 7 6 5 4 3 2 1 0 value 0 0 1 0 0 0 0 0 0 0 那如果再把整数3和4存放入BitMap中，得到结果 index 9 8 7 6 5 4 3 2 1 0 value 0 0 1 0 0 1 1 0 0 0 要问这时BitMap中存放了那些元素，那是一目了然的7,4,3这几个。BitMap不仅方便查询，还可以去除掉重复的整形数。 怎么应用那看到这里有小伙伴可能有疑问了，怎么将BitMap应用到上面的问题中呢？ 问的好！！！ 用户可能有数十万个，那一个用户建立一个BitMap的方式肯定是不妥的。我们可以换一种思路，将标签抽象为一个个的BitMap，然后BitMap中存放对应用户的ID。 第一步：为用户建立一个映射关系表 name age sex phone 小叶 90后 男 一加 小李 90后 女 一加 小张 80后 男 小米 对应的映射为： ID 用户名 1 小叶 2 小李 3 小张 第二步：为每个标签创建BitMap sex BitMap 男 1,3 女 2 age BitMap 90后 1,2 80后 3 那看到这里又有小伙伴要问了，要查90后的男性用户怎么查呢？ 问得好！！！ 这时候就需要用到BitMap的‘与’和‘或’等操作了 首先拿到男性标签和90后标签的BitMap 男性用户（0000001010B）： index 9 8 7 6 5 4 3 2 1 0 value 0 0 0 0 0 0 1 0 1 0 90后用户（0000000110B）： index 9 8 7 6 5 4 3 2 1 0 value 0 0 0 0 0 0 0 1 1 0 这两个BitMap相与就能得到符合‘90后’和‘男’两个标签的用户 （0000001010B &amp; 0000000110B = 0000000010B） index 9 8 7 6 5 4 3 2 1 0 value 0 0 0 0 0 0 0 0 1 0 最后结果很明显可以看出，得到了ID为1的用户是符合查询结果的。那如果需要查找90后或者是男性的用户，就用这两个标签的BitMap相或，最后得到符合结果的BitMap。 在JDK中的BitSet就是BitMap算法的实现，它底层是使用Long数组去存放值的。也有第三方的实现，如谷歌的EWAHCompressedBitMap。 BitMap的缺点忘记说优点了，BitMap的优点主要有下面几个： 1.占用空间小，存储同样的数据，使用HashMap或HashSet的话需要存放int，众所周知int是32位的，而BitMap每存放一个数只占用一位，节省32倍空间咧。 2.BitMap在做交集和并集时有极大的便利，并且位运算的性能也比较高。 那BitMap缺点是什么呢，它的主要缺点就是不支持非运算，如果我要查不用小米手机的用户，那BitMap是无法直接得出结果的。 比如下面是小米用户的BitMap index 9 8 7 6 5 4 3 2 1 0 value 0 0 0 0 0 0 1 0 0 0 进行非运算后，得到结果 index 9 8 7 6 5 4 3 2 1 0 value 1 1 1 1 1 1 0 1 1 1 这个结果显然是错误的。 那如果在实际使用中，需要进行这样的运算怎么办呢？这时我们需要一个全量的BitMap，和目标标签的BitMap进行异或操作就能得到需要的结果。 小米用户（0000001000B）： index 9 8 7 6 5 4 3 2 1 0 value 0 0 0 0 0 0 1 0 0 0 全量用户（0000001110B）： index 9 8 7 6 5 4 3 2 1 0 value 0 0 0 0 0 0 1 1 1 0 进行异或操作，即相同位为0，不同位为1： （0000001000B XOR 0000001110B = 0000000110B） index 9 8 7 6 5 4 3 2 1 0 value 0 0 0 0 0 0 0 1 1 0","tags":[{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Spring Cloud微服务(一)","date":"2019-04-21T11:56:11.000Z","path":"2019/04/21/Spring-Cloud微服务-一/","text":"一、什么是微服务 ​ 在我们以前的应用程序中，所有服务都是糅合在一起的，比如用户服务，产品服务、订单服务等都放在一个应用中，这种可以称为单体架构。 以下这种架构的优缺点 优点： – 开发过程比较简单粗暴 – 服务之间的通信没有额外开销 – 人力成本低 缺点： – 开发效率低 – 部署不够灵活，一旦修改代码并部署后，就需要重启整个应用才能生效 – 稳定性不高，如果其中一个服务出错，很大可能会影响到整个应用的运行 – 扩展性不高，运维和扩展都比较困难 ​ 为了解决上述的单体架构的这些问题，衍生除了分布式的解决方案，而微服务是分布式中的一种形式。在微服务架构中，我们将可以单独运行的一个服务模块拆分出来，形成单独的一个子应用，使单个服务能够独自运行而不影响其他服务。 微服务架构的优缺点 优点： – 由业务驱动，将各服务分开管理，减轻开发和维护的工作量 – 能够轻松扩展，在新增服务模块的时候，不需要考虑与其他服务的耦合关系 – 容错率高，如果某个服务出错，比如服务器宕机，只会影响这个服务的使用，不会影响到整个应用 – 管理轻松，微服务有特定的管理组件，可以很好的监控管理服务的运行状态 缺点： – 人员成本高 – 设备成本高，需要多台机器部署各服务 – 架构设计要求高，需要考虑好如何划分一个服务 – 会有额外的性能开销，服务与服务之间的通信，注册器与服务之间的通信是需要花费资源的 – 调试麻烦，在开发一个服务时，可能需要其他服务的配合才能够进行调试","tags":[{"name":"笔记","slug":"笔记","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"spring","slug":"spring","permalink":"http://houghmzqqq.gihub.io/tags/spring/"},{"name":"微服务","slug":"微服务","permalink":"http://houghmzqqq.gihub.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"},{"name":"分布式","slug":"分布式","permalink":"http://houghmzqqq.gihub.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"name":"框架","slug":"框架","permalink":"http://houghmzqqq.gihub.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"定时任务调度Quartz","date":"2018-10-25T07:50:02.000Z","path":"2018/10/25/定时任务调度Quartz/","text":"Quartz是做什么的Quartz是一个任务调度框架。比如你遇到这样的问题 想每月25号，信用卡自动还款 想每年4月1日自己给当年同学发一封匿名贺卡 想每隔1小时，备份一下自己的学习笔记到云盘 ​ 这些问题总结起来就是：在某一个有规律的时间点干某件事。并且时间的触发的条件可以非常复杂（比如每月最后一个工作日的17:50），复杂到需要一个专门的框架来干这个事。 Quartz就是来干这样的事，你给它一个触发条件的定义，它负责到了时间点，触发相应的Job起来干活。 ### 一个简单例子TestQuartz.java 1234567891011121314151617181920212223242526public class TestQuartz &#123; public static void main(String[] args) &#123; try &#123; //调度工厂 SchedulerFactory schedulerFactory = new StdSchedulerFactory(); //调度器 Scheduler scheduler = schedulerFactory.getScheduler(); scheduler.start(); //生成一个job对象,TestJob中是具体的调度内容 JobDetail job = JobBuilder.newJob(TestJob.class) .withIdentity(&quot;myjob&quot;, &quot;group1&quot;).build(); //触发器 Trigger trigger = TriggerBuilder.newTrigger() .withIdentity(&quot;myTrigger&quot;, &quot;group1&quot;) .startNow() .withSchedule(SimpleScheduleBuilder.simpleSchedule() .withIntervalInSeconds(5) .repeatForever()) .build(); //开始管理该调度 scheduler.scheduleJob(job, trigger); &#125; catch (SchedulerException e) &#123; e.printStackTrace(); &#125; &#125;&#125; TestJob.java 12345678/*** 任务具体实现类*/public class TestJob implements Job&#123; public void execute(JobExecutionContext paramJobExecutionContext) throws JobExecutionException &#123; System.out.println(&quot;这是一个定时任务。&quot;); &#125;&#125; 像这样就可以启动一个定时任务了，任务每隔5秒执行一次。 JobDetail用来生成一个Job对象，对应任务，可以用它注册具体的任务实现。Trigger是触发器，它决定任务在何时被触发。Scheduler是调度器，用来管理任务，它基本可以控制quartz中的任何东西了，Scheduler在手天下我有。 cron表达式cron表达式是用来表示时间的一段字符串，大概长这个样子0 0/10 * * * ?，它表示间隔10分钟 个人认为专门学习这个表达式的语法有点麻烦，简单了解下语法就好。如果有复杂的定时要求，网上有cron生成器，直接用就是了：cron表达式生成器 使用cron表达式生成触发器： 123456// 表达式调度构建器CronScheduleBuilder scheduleBuilder = CronScheduleBuilder.cronSchedule(&quot;0 0/10 * * * ?&quot;);// 按照cronExpression表达式构建一个triggertrigger = TriggerBuilder.newTrigger().startNow() .withIdentity(mySche.getScheId(), mySche.getScheduleName()) .withSchedule(scheduleBuilder).build(); 使用spring与绑定数据库quartz可以配置数据库，将任务的信息放在数据库里，当项目重启时，能够加载之前的任务信息。需要的配置如下所示。 依赖包，pom.xml: 12345678910&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz-jobs&lt;/artifactId&gt; &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt; spring配置文件中配置SchedulerFactoryBean，下面是一个范例: 12345678910111213&lt;!-- 总管理类 如果将lazy-init=&#x27;false&#x27;那么容器启动就会执行调度程序 --&gt; &lt;bean id=&quot;schedulerFactoryBean&quot; lazy-init=&quot;false&quot; autowire=&quot;no&quot; class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot; destroy-method=&quot;destroy&quot;&gt; &lt;property name=&quot;overwriteExistingJobs&quot; value=&quot;true&quot; /&gt; &lt;!-- 启动延时 --&gt; &lt;property name=&quot;startupDelay&quot; value=&quot;5&quot; /&gt; &lt;!-- 是否自动启动 --&gt; &lt;property name=&quot;autoStartup&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;applicationContextSchedulerContextKey&quot; value=&quot;applicationContext&quot; /&gt; &lt;!-- quartz配置文件 --&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:quartz.properties&quot; /&gt; &lt;/bean&gt; quartz的配置文件quartz.properties(官网好像有范例): 1234567891011121314151617181920212223242526272829303132333435363738394041#============================================================================# Configure Main Scheduler Properties #============================================================================org.quartz.scheduler.instanceName: mySchedulerorg.quartz.scheduler.instanceId: AUTOorg.quartz.scheduler.skipUpdateCheck: true#============================================================================# Configure ThreadPool Tomcat/Liberty TestOnly#============================================================================org.quartz.threadPool.class: org.quartz.simpl.SimpleThreadPoolorg.quartz.threadPool.threadCount: 10org.quartz.threadPool.threadPriority: 6#============================================================================# Configure JobStore #============================================================================org.quartz.jobStore.class = org.quartz.impl.jdbcjobstore.JobStoreTXorg.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegateorg.quartz.jobStore.useProperties = falseorg.quartz.jobStore.dataSource = smartformsorg.quartz.jobStore.tablePrefix = QRTZ_org.quartz.jobStore.isClustered = trueorg.quartz.jobStore.clusterCheckinInterval = 20000 #============================================================================# Configure Datasources #============================================================================# mysql#org.quartz.dataSource.myDS.driver = com.mysql.jdbc.Driver#org.quartz.dataSource.myDS.URL = jdbc:mysql://localhost:3306/osn_mdm#org.quartz.dataSource.myDS.user = root#org.quartz.dataSource.myDS.password =admin#org.quartz.dataSource.myDS.maxConnections = 5# oracle2org.quartz.dataSource.smartforms.driver =oracle.jdbc.driver.OracleDriverorg.quartz.dataSource.smartforms.URL =jdbc:oracle:thin:@120.197.50.154:1521:smartformsdborg.quartz.dataSource.smartforms.user =csmartorg.quartz.dataSource.smartforms.password =csmartorg.quartz.dataSource.smartforms.maxConnections =30 另外，quartz绑定数据库需要用到一些表，可以在官网找到，这里直接贴出来: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180delete from qrtz_fired_triggers;delete from qrtz_simple_triggers;delete from qrtz_simprop_triggers;delete from qrtz_cron_triggers;delete from qrtz_blob_triggers;delete from qrtz_triggers;delete from qrtz_job_details;delete from qrtz_calendars;delete from qrtz_paused_trigger_grps;delete from qrtz_locks;delete from qrtz_scheduler_state;drop table qrtz_calendars;drop table qrtz_fired_triggers;drop table qrtz_blob_triggers;drop table qrtz_cron_triggers;drop table qrtz_simple_triggers;drop table qrtz_simprop_triggers;drop table qrtz_triggers;drop table qrtz_job_details;drop table qrtz_paused_trigger_grps;drop table qrtz_locks;drop table qrtz_scheduler_state;CREATE TABLE qrtz_job_details ( SCHED_NAME VARCHAR2(120) NOT NULL, JOB_NAME VARCHAR2(200) NOT NULL, JOB_GROUP VARCHAR2(200) NOT NULL, DESCRIPTION VARCHAR2(250) NULL, JOB_CLASS_NAME VARCHAR2(250) NOT NULL, IS_DURABLE VARCHAR2(1) NOT NULL, IS_NONCONCURRENT VARCHAR2(1) NOT NULL, IS_UPDATE_DATA VARCHAR2(1) NOT NULL, REQUESTS_RECOVERY VARCHAR2(1) NOT NULL, JOB_DATA BLOB NULL, CONSTRAINT QRTZ_JOB_DETAILS_PK PRIMARY KEY (SCHED_NAME,JOB_NAME,JOB_GROUP));CREATE TABLE qrtz_triggers ( SCHED_NAME VARCHAR2(120) NOT NULL, TRIGGER_NAME VARCHAR2(200) NOT NULL, TRIGGER_GROUP VARCHAR2(200) NOT NULL, JOB_NAME VARCHAR2(200) NOT NULL, JOB_GROUP VARCHAR2(200) NOT NULL, DESCRIPTION VARCHAR2(250) NULL, NEXT_FIRE_TIME NUMBER(13) NULL, PREV_FIRE_TIME NUMBER(13) NULL, PRIORITY NUMBER(13) NULL, TRIGGER_STATE VARCHAR2(16) NOT NULL, TRIGGER_TYPE VARCHAR2(8) NOT NULL, START_TIME NUMBER(13) NOT NULL, END_TIME NUMBER(13) NULL, CALENDAR_NAME VARCHAR2(200) NULL, MISFIRE_INSTR NUMBER(2) NULL, JOB_DATA BLOB NULL, CONSTRAINT QRTZ_TRIGGERS_PK PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), CONSTRAINT QRTZ_TRIGGER_TO_JOBS_FK FOREIGN KEY (SCHED_NAME,JOB_NAME,JOB_GROUP) REFERENCES QRTZ_JOB_DETAILS(SCHED_NAME,JOB_NAME,JOB_GROUP) );CREATE TABLE qrtz_simple_triggers ( SCHED_NAME VARCHAR2(120) NOT NULL, TRIGGER_NAME VARCHAR2(200) NOT NULL, TRIGGER_GROUP VARCHAR2(200) NOT NULL, REPEAT_COUNT NUMBER(7) NOT NULL, REPEAT_INTERVAL NUMBER(12) NOT NULL, TIMES_TRIGGERED NUMBER(10) NOT NULL, CONSTRAINT QRTZ_SIMPLE_TRIG_PK PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), CONSTRAINT QRTZ_SIMPLE_TRIG_TO_TRIG_FK FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP));CREATE TABLE qrtz_cron_triggers ( SCHED_NAME VARCHAR2(120) NOT NULL, TRIGGER_NAME VARCHAR2(200) NOT NULL, TRIGGER_GROUP VARCHAR2(200) NOT NULL, CRON_EXPRESSION VARCHAR2(120) NOT NULL, TIME_ZONE_ID VARCHAR2(80), CONSTRAINT QRTZ_CRON_TRIG_PK PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), CONSTRAINT QRTZ_CRON_TRIG_TO_TRIG_FK FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP));CREATE TABLE qrtz_simprop_triggers ( SCHED_NAME VARCHAR2(120) NOT NULL, TRIGGER_NAME VARCHAR2(200) NOT NULL, TRIGGER_GROUP VARCHAR2(200) NOT NULL, STR_PROP_1 VARCHAR2(512) NULL, STR_PROP_2 VARCHAR2(512) NULL, STR_PROP_3 VARCHAR2(512) NULL, INT_PROP_1 NUMBER(10) NULL, INT_PROP_2 NUMBER(10) NULL, LONG_PROP_1 NUMBER(13) NULL, LONG_PROP_2 NUMBER(13) NULL, DEC_PROP_1 NUMERIC(13,4) NULL, DEC_PROP_2 NUMERIC(13,4) NULL, BOOL_PROP_1 VARCHAR2(1) NULL, BOOL_PROP_2 VARCHAR2(1) NULL, CONSTRAINT QRTZ_SIMPROP_TRIG_PK PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), CONSTRAINT QRTZ_SIMPROP_TRIG_TO_TRIG_FK FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP));CREATE TABLE qrtz_blob_triggers ( SCHED_NAME VARCHAR2(120) NOT NULL, TRIGGER_NAME VARCHAR2(200) NOT NULL, TRIGGER_GROUP VARCHAR2(200) NOT NULL, BLOB_DATA BLOB NULL, CONSTRAINT QRTZ_BLOB_TRIG_PK PRIMARY KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP), CONSTRAINT QRTZ_BLOB_TRIG_TO_TRIG_FK FOREIGN KEY (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP) REFERENCES QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP));CREATE TABLE qrtz_calendars ( SCHED_NAME VARCHAR2(120) NOT NULL, CALENDAR_NAME VARCHAR2(200) NOT NULL, CALENDAR BLOB NOT NULL, CONSTRAINT QRTZ_CALENDARS_PK PRIMARY KEY (SCHED_NAME,CALENDAR_NAME));CREATE TABLE qrtz_paused_trigger_grps ( SCHED_NAME VARCHAR2(120) NOT NULL, TRIGGER_GROUP VARCHAR2(200) NOT NULL, CONSTRAINT QRTZ_PAUSED_TRIG_GRPS_PK PRIMARY KEY (SCHED_NAME,TRIGGER_GROUP));CREATE TABLE qrtz_fired_triggers ( SCHED_NAME VARCHAR2(120) NOT NULL, ENTRY_ID VARCHAR2(95) NOT NULL, TRIGGER_NAME VARCHAR2(200) NOT NULL, TRIGGER_GROUP VARCHAR2(200) NOT NULL, INSTANCE_NAME VARCHAR2(200) NOT NULL, FIRED_TIME NUMBER(13) NOT NULL, SCHED_TIME NUMBER(13) NOT NULL, PRIORITY NUMBER(13) NOT NULL, STATE VARCHAR2(16) NOT NULL, JOB_NAME VARCHAR2(200) NULL, JOB_GROUP VARCHAR2(200) NULL, IS_NONCONCURRENT VARCHAR2(1) NULL, REQUESTS_RECOVERY VARCHAR2(1) NULL, CONSTRAINT QRTZ_FIRED_TRIGGER_PK PRIMARY KEY (SCHED_NAME,ENTRY_ID));CREATE TABLE qrtz_scheduler_state ( SCHED_NAME VARCHAR2(120) NOT NULL, INSTANCE_NAME VARCHAR2(200) NOT NULL, LAST_CHECKIN_TIME NUMBER(13) NOT NULL, CHECKIN_INTERVAL NUMBER(13) NOT NULL, CONSTRAINT QRTZ_SCHEDULER_STATE_PK PRIMARY KEY (SCHED_NAME,INSTANCE_NAME));CREATE TABLE qrtz_locks ( SCHED_NAME VARCHAR2(120) NOT NULL, LOCK_NAME VARCHAR2(40) NOT NULL, CONSTRAINT QRTZ_LOCKS_PK PRIMARY KEY (SCHED_NAME,LOCK_NAME));create index idx_qrtz_j_req_recovery on qrtz_job_details(SCHED_NAME,REQUESTS_RECOVERY);create index idx_qrtz_j_grp on qrtz_job_details(SCHED_NAME,JOB_GROUP);create index idx_qrtz_t_j on qrtz_triggers(SCHED_NAME,JOB_NAME,JOB_GROUP);create index idx_qrtz_t_jg on qrtz_triggers(SCHED_NAME,JOB_GROUP);create index idx_qrtz_t_c on qrtz_triggers(SCHED_NAME,CALENDAR_NAME);create index idx_qrtz_t_g on qrtz_triggers(SCHED_NAME,TRIGGER_GROUP);create index idx_qrtz_t_state on qrtz_triggers(SCHED_NAME,TRIGGER_STATE);create index idx_qrtz_t_n_state on qrtz_triggers(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP,TRIGGER_STATE);create index idx_qrtz_t_n_g_state on qrtz_triggers(SCHED_NAME,TRIGGER_GROUP,TRIGGER_STATE);create index idx_qrtz_t_next_fire_time on qrtz_triggers(SCHED_NAME,NEXT_FIRE_TIME);create index idx_qrtz_t_nft_st on qrtz_triggers(SCHED_NAME,TRIGGER_STATE,NEXT_FIRE_TIME);create index idx_qrtz_t_nft_misfire on qrtz_triggers(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME);create index idx_qrtz_t_nft_st_misfire on qrtz_triggers(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_STATE);create index idx_qrtz_t_nft_st_misfire_grp on qrtz_triggers(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_GROUP,TRIGGER_STATE);create index idx_qrtz_ft_trig_inst_name on qrtz_fired_triggers(SCHED_NAME,INSTANCE_NAME);create index idx_qrtz_ft_inst_job_req_rcvry on qrtz_fired_triggers(SCHED_NAME,INSTANCE_NAME,REQUESTS_RECOVERY);create index idx_qrtz_ft_j_g on qrtz_fired_triggers(SCHED_NAME,JOB_NAME,JOB_GROUP);create index idx_qrtz_ft_jg on qrtz_fired_triggers(SCHED_NAME,JOB_GROUP);create index idx_qrtz_ft_t_g on qrtz_fired_triggers(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP);create index idx_qrtz_ft_tg on qrtz_fired_triggers(SCHED_NAME,TRIGGER_GROUP); 以上就是基本配置，使用是，直接用spring容器取出Scheduler实例使用就行了 12@Autowiredprivate Scheduler scheduler;","tags":[{"name":"Java","slug":"Java","permalink":"http://houghmzqqq.gihub.io/tags/Java/"}]},{"title":"hexo备份——多终端编写博客","date":"2018-10-25T06:39:41.000Z","path":"2018/10/25/hexo备份——多终端编写博客/","text":"​ 之前一直在个人笔记本上写博客，最近有需要在另一台终端上去写博客，所以需要将hexo上的资源文件备份到另一台电脑上。在这里记录一下操作过程，方便下一次需要备份博客时使用。 1 github上备份​ 按照网上的教程，安装好node.js并搭建hexo环境后，使用hexo d -g命令后，hexo会生成一些静态文件并上传到github上。 这些静态文件直接拉取下来是没用的，我们需要将资源文件也放到github上。 在github存放博客的仓库上，创建一个分支。对于我来说，就是在houghmzqqq.github.io仓库上创建hexo分支。 将你的hexo资源文件push到hexo分支上（别忘记先加个.gitignore文件） 2 终端拷贝在你需要备份hexo的电脑上，新建一个文件夹，在该文件夹中进行如下操作： 1.cnpm install hexo-cli -g 安装hexo（如果还没有安装hexo的话） 2.cnpm install 安装其他依赖（如果没安装过的话） 3.hexo init 初始化hexo，执行完后，会生成_config.yml、source等资源文件 4.cnpm install --save hexo-deployer-git hexo生成静态文件并保存到github所需要的依赖 5.npm i hexo-generator-json-content --save 标签支持依赖（如果你需要使用到标签的话） 6.然后在任意位置新建一个文件夹，克隆github博客仓库的hexo分支到该目录，然后将克隆下来的文件覆盖到上面的hexo目录下，就相当于将你的博客拷贝下来了。具体操作是： 1)、用tortoiseGit在hexo（你的博客文件夹）目录下创建版本库 2)、复制.gitignore文件，add文件，提交文件 3)、拉取文件，可以在拉取时配置远端信息，就是github仓库地址，对我来说是https://github.com/houghmzqqq/houghmzqqq.github.io.git 4)、合并文件，解决冲突（全部替换为远端文件就行） 5)、解决完冲突，再次提交并推送 然后就可以愉快的hexo d -g 提交博客了！！（当然，先执行hexo server本地测试一下）","tags":[{"name":"随笔","slug":"随笔","permalink":"http://houghmzqqq.gihub.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"sprinp监听器(ApplicationListener)原理简析","date":"2018-09-21T10:43:06.000Z","path":"2018/09/21/sprinp监听器-ApplicationListener-原理简析/","text":"##一、spring监听器的使用 ​ spring中监听器的使用很方便，建立一个Listener继承ApplicationListener，建立一个Event继承ApplicationEvent，需要使用时，用applicationContext上下文调用publishEvent()方法触发事件 1.1 定义事件MyEvent12345678910public class MyEvent extends ApplicationEvent&#123; public MyEvent(Object source) &#123; super(source); &#125; @Override public Object getSource() &#123; return super.getSource(); &#125;&#125; 1.2 定义监听器MyListener123456789101112@Componentpublic class MyListener implements ApplicationListener&lt;MyEvent&gt;&#123; /** * 触发事件时，会执行这个方法 */ @Override public void onApplicationEvent(MyEvent event) &#123; System.out.println(&quot;监听到事件:&quot; + event.getClass().getSimpleName()); &#125;&#125; 1.3 触发事件123456789public class MyTest &#123; public static void main(String[] args) &#123; //获取spring上下文 AbstractApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); MyEvent myEvent = new MyEvent(&quot;Hello&quot;); //触发事件 context.publishEvent(myEvent); &#125;&#125; 二、源码分析（触发事件——&gt;执行监听器过程） 2.1 触发事件​ 触发事件时，使用了AbstractApplicationContext.publishEvent()方法，以此为切入点，查看这个方法的源码： 12345678910111213141516171819202122/** * 触发给定的事件，通知所有的监听者 * @param event the event to publish (may be an &#123;@link ApplicationEvent&#125; * or a payload object to be turned into a &#123;@link PayloadApplicationEvent&#125;) * @param eventType the resolved event type, if known * @since 4.2 */protected void publishEvent(Object event, ResolvableType eventType) &#123; ...省略... // Multicast right now if possible - or lazily once the multicaster is initialized if (this.earlyApplicationEvents != null) &#123; this.earlyApplicationEvents.add(applicationEvent); &#125; else &#123; //调用这个方法，将事件广播出去 getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType); &#125; ...省略...&#125; ​ 上面这段代码重点在getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);，调用SimpleApplicationEventMulticaster.multicastEvent()方法，将事件广播给监听器 2.2 广播事件12345678910111213141516171819@Overridepublic void multicastEvent(final ApplicationEvent event, ResolvableType eventType) &#123; ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event)); for (final ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123; Executor executor = getTaskExecutor(); if (executor != null) &#123; executor.execute(new Runnable() &#123; @Override public void run() &#123; invokeListener(listener, event); &#125; &#125;); &#125; else &#123; invokeListener(listener, event); &#125; &#125;&#125; ​ 在这个方法中，用getApplicationListeners()方法，获取该事件的所有监听器，然后遍历监听器并用invokeListener()方法，具体的去执行各个监听器逻辑 2.3 获取监听器列表123456789101112131415161718192021222324252627282930313233343536protected Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners( ApplicationEvent event, ResolvableType eventType) &#123; Object source = event.getSource(); Class&lt;?&gt; sourceType = (source != null ? source.getClass() : null); ListenerCacheKey cacheKey = new ListenerCacheKey(eventType, sourceType); // 查询缓存中是否有监听器，如果命中缓存，则直接返回缓存中的监听器 ListenerRetriever retriever = this.retrieverCache.get(cacheKey); if (retriever != null) &#123; return retriever.getApplicationListeners(); &#125; if (this.beanClassLoader == null || (ClassUtils.isCacheSafe(event.getClass(), this.beanClassLoader) &amp;&amp; (sourceType == null || ClassUtils.isCacheSafe(sourceType, this.beanClassLoader)))) &#123; // Fully synchronized building and caching of a ListenerRetriever synchronized (this.retrievalMutex) &#123; retriever = this.retrieverCache.get(cacheKey); if (retriever != null) &#123; return retriever.getApplicationListeners(); &#125;1 //未命中缓存，重新获取监听器列 retriever = new ListenerRetriever(true); Collection&lt;ApplicationListener&lt;?&gt;&gt; listeners = retrieveApplicationListeners(eventType, sourceType, retriever); this.retrieverCache.put(cacheKey, retriever); return listeners; &#125; &#125; else &#123; // No ListenerRetriever caching -&gt; no synchronization necessary return retrieveApplicationListeners(eventType, sourceType, null); &#125;&#125; ​ AbstractApplicationEventMulticaster是SimpleApplicationEventMulticaster的父类，getApplicationListeners()方法主要逻辑是查询缓存中是否有该事件的监听器列表，如果没有则调用retrieveApplicationListeners()重新获取监听器列表。 2.4 重新获取监听器列表123456789101112131415161718192021222324252627282930313233343536373839404142434445private Collection&lt;ApplicationListener&lt;?&gt;&gt; retrieveApplicationListeners( ResolvableType eventType, Class&lt;?&gt; sourceType, ListenerRetriever retriever) &#123; LinkedList&lt;ApplicationListener&lt;?&gt;&gt; allListeners = new LinkedList&lt;ApplicationListener&lt;?&gt;&gt;(); Set&lt;ApplicationListener&lt;?&gt;&gt; listeners; Set&lt;String&gt; listenerBeans; synchronized (this.retrievalMutex) &#123; //从defaultRetriever中获取listeners和listenerBeans listeners = new LinkedHashSet&lt;ApplicationListener&lt;?&gt;&gt;(this.defaultRetriever.applicationListeners); listenerBeans = new LinkedHashSet&lt;String&gt;(this.defaultRetriever.applicationListenerBeans); &#125; for (ApplicationListener&lt;?&gt; listener : listeners) &#123; if (supportsEvent(listener, eventType, sourceType)) &#123; if (retriever != null) &#123; retriever.applicationListeners.add(listener); &#125; allListeners.add(listener); &#125; &#125; if (!listenerBeans.isEmpty()) &#123; BeanFactory beanFactory = getBeanFactory(); //遍历listenerBeans，获取所有监听器 for (String listenerBeanName : listenerBeans) &#123; try &#123; Class&lt;?&gt; listenerType = beanFactory.getType(listenerBeanName); if (listenerType == null || supportsEvent(listenerType, eventType)) &#123; ApplicationListener&lt;?&gt; listener = beanFactory.getBean(listenerBeanName, ApplicationListener.class); if (!allListeners.contains(listener) &amp;&amp; supportsEvent(listener, eventType, sourceType)) &#123; if (retriever != null) &#123; retriever.applicationListenerBeans.add(listenerBeanName); &#125; allListeners.add(listener); &#125; &#125; &#125; catch (NoSuchBeanDefinitionException ex) &#123; // Singleton listener instance (without backing bean definition) disappeared - // probably in the middle of the destruction phase &#125; &#125; &#125; AnnotationAwareOrderComparator.sort(allListeners); return allListeners; &#125; ​ 在这个方法中，会获取AbstractApplicationEventMulticaster.defaultRetriever中的listeners(监听器列表)和listenerBeans(监听器BeanId列表)，然后会遍历listenerBeans获取所有监听器实例（所以定义一个监听器后，需要将它注册到IOC中）。defaultRetriever的初始化在下面会介绍。 2.5 通知监听器1234567891011121314151617181920private void doInvokeListener(ApplicationListener listener, ApplicationEvent event) &#123; try &#123; //执行监听器中的逻辑 listener.onApplicationEvent(event); &#125; catch (ClassCastException ex) &#123; String msg = ex.getMessage(); if (msg == null || matchesClassCastMessage(msg, event.getClass().getName())) &#123; // Possibly a lambda-defined listener which we could not resolve the generic event type for // -&gt; let&#x27;s suppress the exception and just log a debug message. Log logger = LogFactory.getLog(getClass()); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Non-matching event type for listener: &quot; + listener, ex); &#125; &#125; else &#123; throw ex; &#125; &#125;&#125; ​ 最后回到invokeListener()方法，里面会调用doInvokeListener()，在这里可以看到listener.onApplicationEvent(event);这一句，即调用监听器中的onApplicationEvent()方法去执行监听器的业务逻辑 三、源码分析（监听器的初始化和注册）3.1 初始化spring上下文123456789101112131415161718192021222324252627public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; ...省略... // 初始化事件多播器 initApplicationEventMulticaster ...省略... // 注册监听器 registerListeners(); ...省略... &#125; ...省略... &#125; &#125; 在refresh()方法中，调用了registerListeners()方法，在这个方法中注册监听器 1234567891011121314151617181920212223protected void registerListeners() &#123; // Register statically specified listeners first. for (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123; //这里的addApplicationListener()方法即初始化2.4中的defaultRetriever getApplicationEventMulticaster().addApplicationListener(listener); &#125; // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let post-processors apply to them! String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, true, false); for (String listenerBeanName : listenerBeanNames) &#123; getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName); &#125; // Publish early application events now that we finally have a multicaster... Set&lt;ApplicationEvent&gt; earlyEventsToProcess = this.earlyApplicationEvents; this.earlyApplicationEvents = null; if (earlyEventsToProcess != null) &#123; for (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123; getApplicationEventMulticaster().multicastEvent(earlyEvent); &#125; &#125; &#125; ​ 在registerListeners()中调用了getApplicationEventMulticaster().addApplicationListener(listener);方法，此方法即初始化了前面2.4中的defaultRetriever","tags":[{"name":"spring","slug":"spring","permalink":"http://houghmzqqq.gihub.io/tags/spring/"},{"name":"源码","slug":"源码","permalink":"http://houghmzqqq.gihub.io/tags/%E6%BA%90%E7%A0%81/"}]},{"title":"js中的正则表达式","date":"2018-07-13T03:04:33.000Z","path":"2018/07/13/js中的正则表达式/","text":"首先需要说明，在js的正则表达式中，’&#39;（即反斜杠）表示转义，而非’/‘。基本的写法是：/匹配的字符/修饰(可选)，匹配的字符包含在两个斜杠中间。 1.基本语法1.1元字符 元字符 描述 元字符 描述 \\d 匹配数字 \\f 匹配换页符 \\s 匹配空白字符 \\n 匹配换行符 \\b 匹配字母 \\r 匹配回车符 \\w 表示单词字符，={a-zA-Z0-9} ^ 表示后面出现的字符必须在开头 + 表示出现一到多次，={1,} . 匹配任意字符 $ 表示前面出现的字符必须在结尾 \\S 表示非空格符 * 表示出现0到多次，={0,} \\b 匹配一个单词的边界 ？ 表示出现0次或一次，={0,1} 举例1：表达式 “^aaa” 在匹配 “xxx aaa xxx” 时，匹配结果是：失败。因为 “^” 要求与字符串开始的地方匹配，因此，只有当 “aaa” 位于字符串的开头的时候，”^aaa” 才能匹配，比如：”aaa xxx xxx”。 举例2：表达式 “aaa$” 在匹配 “xxx aaa xxx” 时，匹配结果是：失败。因为 “$” 要求与字符串结束的地方匹配，因此，只有当 “aaa” 位于字符串的结尾的时候，”aaa$” 才能匹配，比如：”xxx xxx aaa”。 举例3：表达式 “\\b” 在匹配 “@@@abc” 时，匹配结果是：成功；匹配到的内容是：”@a”；匹配到的位置是：开始于2，结束于4。​ 进一步说明：”/b” 与 “^” 和 “$” 类似，本身不匹配任何字符，但是它要求它在匹配结果中所处位置的左右两边，其中一边是 “/w” 范围，另一边是 非”/w” 的范围。 1.2修饰符 修饰符 描述 i 执行对大小写不敏感的匹配 g 执行全局匹配（查找所有匹配而非在找到第一个匹配后停止） m 执行多行匹配。 1.3模式 表达式 描述 表达式 描述 [ab5@] 匹配a、b、5、@中的一个字符 [^abc] 匹配a、b、c以外的字符 [f-k] 匹配f~k之间的字符 [^A-F0_3] 匹配AF、03以外的任意字符 1.4其他 元符号 描述 “|” 能够进行或运算，匹配左边或右边 () 括号里的内容可以看做一个整体，能够使用””$1”的方式获取匹配的结果 1.5贪婪匹配和非贪婪匹配贪婪模式 ​ 在使用修饰匹配次数的特殊符号时，有几种表示方法可以使同一个表达式能够匹配不同的次数，比如：”{m,n}”, “{m,}”, “?”, “*”, “+”，具体匹配的次数随被匹配的字符串而定。这种重复匹配不定次数的表达式在匹配过程中，总是尽可能多的匹配。比如，针对文本 “dxxxdxxxd”，举例如下： 表达式 匹配结果 (d)(\\w+) “/w+” 将匹配第一个 “d” 之后的所有字符 “xxxdxxxd” (d)(/w+)(d) “/w+” 将匹配第一个 “d” 和最后一个 “d” 之间的所有字符 “xxxdxxx”。虽然 “/w+” 也能够匹配上最后一个 “d”，但是为了使整个表达式匹配成功，”/w+” 可以 “让出” 它本来能够匹配的最后一个 “d” 非贪婪模式 ​ 在修饰匹配次数的特殊符号后再加上一个 “?” 号，则可以使匹配次数不定的表达式尽可能少的匹配，使可匹配可不匹配的表达式，尽可能的 “不匹配”。这种匹配原则叫作 “非贪婪” 模式，也叫作 “勉强” 模式。如果少匹配就会导致整个表达式匹配失败的时候，与贪婪模式类似，非贪婪模式会最小限度的再匹配一些，以使整个表达式匹配成功。举例如下，针对文本 “dxxxdxxxd” 举例： 表达式 匹配结果 (d)(\\w+?) “/w+?” 将尽可能少的匹配第一个 “d” 之后的字符，结果是：”/w+?” 只匹配了一个 “x” (d)(\\w+?)(d) 为了让整个表达式匹配成功，”/w+?” 不得不匹配 “xxx” 才可以让后边的 “d” 匹配，从而使整个表达式匹配成功。因此，结果是：”/w+?” 匹配 “xxx” 2.实际问题2.1解析不标准的json数据今天遇到一串不标准的json数据： {“warning”:{message:”用户会话已到期。请重新装入页面。&lt;br /&gt;”,details:”&lt;br /&gt;”}} 可以看到它的message和details是没有加双引号的，我们可以使用正则表达式为它补充上，否则js不能解析该json数据，代码如下。 12data.replace(/(\\s*?&#123;\\s*?|\\s*?,\\s*?)([&#x27;&quot;])?([a-zA-Z0-9]+)([&#x27;&quot;])?:/g, &#x27;$1&quot;$3&quot;:&#x27;);eval(&#x27;var rel = new Object(&#x27; + data + &#x27;)&#x27;); 2.2去掉html标签1var msg = &quot;&lt;SPAN class=\\&quot;ellipsis\\&quot;&gt;...&lt;\\/SPAN&gt; &lt;SPAN class=\\&quot;OFHighlightTerm1\\&quot;&gt;深圳&lt;\\/SPAN&gt;燃气2017年年度报告 2018-06-11 | 来源:董事办 | 作者:郭鋆辉 | 摄影:董事办 &lt;SPAN class=\\&quot;ellipsis\\&quot;&gt;...&lt;\\/SPAN&gt; 收藏 《&lt;SPAN class=\\&quot;OFHighlightTerm1\\&quot;&gt;深圳&lt;\\/SPAN&gt;燃气2017年年度报告》全文请见附件 附件: [打印本文] [关闭窗口] [复制地址&quot; 像上面的字符串，它里面包好有html标签，如果我们希望把html去掉，可以使用正则表达式，代码如下： 1msg = msg.replace(/&lt;[^&gt;]+&gt;/g, &quot;&quot;);","tags":[{"name":"js","slug":"js","permalink":"http://houghmzqqq.gihub.io/tags/js/"}]},{"title":"springboot 2.0中定义拦截器","date":"2018-04-04T01:51:23.000Z","path":"2018/04/04/springboot-中定义拦截器/","text":"HandlerInterceptor 的功能跟过滤器类似，但是提供更精细的的控制能力：在request被响应之前、request被响应之后、视图渲染之前以及request全部结束之后。我们不能通过拦截器修改request内容，但是可以通过抛出异常（或者返回false）来暂停request的执行。 实现 UserRoleAuthorizationInterceptor 的拦截器有：ConversionServiceExposingInterceptorCorsInterceptorLocaleChangeInterceptorPathExposingHandlerInterceptorResourceUrlProviderExposingInterceptorThemeChangeInterceptorUriTemplateVariablesHandlerInterceptorUserRoleAuthorizationInterceptor 其中 LocaleChangeInterceptor 和 ThemeChangeInterceptor 比较常用。 配置拦截器也很简单，Spring 为我们提供了基础类WebMvcConfigurerAdapter ，我们只需要重写 addInterceptors 方法添加注册拦截器。 实现自定义拦截器只需要3步：1、创建我们自己的拦截器类并实现 HandlerInterceptor 接口。2、创建一个Java类继承WebMvcConfigurerAdapter，并重写 addInterceptors 方法。2、实例化我们自定义的拦截器，然后将对像手动添加到拦截器链中（在addInterceptors方法中添加）。 1、LoginInterceptor.java新建一个Interceptor类，实现HandlerInteceptor接口 1234567891011121314151617public class LoginInterceptor implements HandlerInterceptor&#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(&quot;--&gt;request请求执行前，Controller执行前。&quot;); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;--&gt;request请求执行后，Controller执行前。&quot;); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; System.out.println(&quot;--&gt;request请求执行后，Controller执行后。&quot;); &#125;&#125; 2、WebAppConfigurer​ 新建WebAppConfigurer类继承WebMvcConfigurationSupport，重写addInteceptor()方法，在其中配置拦截器。（在SpringBoot2.0中，WebMvcConfigurationAdapter已过时，用WebMvcConfigurationSupport替换） 12345678@Configurationpublic class WebAppConfigurer extends WebMvcConfigurationSupport &#123; @Override protected void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()).addPathPatterns(&quot;/**&quot;); super.addInterceptors(registry); &#125;&#125; 拦截器配置完成，在浏览器访问该项目路径，拦截器会进行拦截 123--&gt;request请求执行前，Controller执行前。--&gt;request请求执行后，Controller执行前。--&gt;request请求执行后，Controller执行后。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"spring","slug":"spring","permalink":"http://houghmzqqq.gihub.io/tags/spring/"},{"name":"框架","slug":"框架","permalink":"http://houghmzqqq.gihub.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"自定义jsp标签","date":"2018-01-17T03:00:07.000Z","path":"2018/01/17/自定义jsp标签/","text":"1.如何自定义Jsp标签​ 通过一个示例来说明如何自定义一个jsp标签，示例内容是定义一个标签输出“Hello World！” 1.1新建一个java类，继承TagSupport类​ 可以选择重写doStartTag()、doEndTag、doAfterBody()等方法，分别表示识别到开始标签时执行的方法、识别结束标签时执行的方法、执行完标签体后执行的方法。 ​ 我们可以在doStartTag()中控制是否输出标签体，在doAfterBody()中实现标签体的循环输出，在doEndTag()中控制后面的内容是否输出等。 12345678910111213141516public class MyTag extends TagSupport &#123; @Override public int doStartTag() throws JspException &#123; //获取输出流 JspWriter out = this.pageContext.getOut(); //或者获取打印流// PrintWriter out = this.pageContext.getResponse().getWriter(); try &#123; //打印字符串 out.print(&quot;Hello World!&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return super.doStartTag(); &#125;&#125; 1.2注册Tag标签​ 实现好标签的具体执行类后，需要新建一个tld文件对它进行注册。 123456789101112131415161718192021&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;&lt;taglib xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd&quot; version=&quot;2.1&quot;&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;mycompany&lt;/short-name&gt; &lt;!-- 这个标签的uri，jap通过这个uri访问这个标签库 --&gt; &lt;uri&gt;http://mycompany.com/mytag&lt;/uri&gt; &lt;!-- Invoke &#x27;Generate&#x27; action to add tags or functions --&gt; &lt;!-- 标签的信息，定义标签的名称、对应的标签实现类、标签体内容格式 --&gt; &lt;tag&gt; &lt;name&gt;ViewIp&lt;/name&gt; &lt;tag-class&gt;com.yjf.tagTest.MyTag&lt;/tag-class&gt; &lt;!-- 标签体内容格式，可以为empty、JSP等 --&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;/tag&gt; &lt;/taglib&gt; 1.3引用标签​ 注册完成后，就可以在jsp中使用该标签了。 12345678&lt;!-- 引用标签库，uri对应tld文件中的uri --&gt;&lt;%@taglib prefix=&quot;mytag&quot; uri=&quot;http://mycompany.com/mytag&quot;%&gt;&lt;html&gt; &lt;body&gt; &lt;!-- 别名：标签名 的形式使用自定义标签 --&gt; &lt;mytag:ViewIp/&gt; &lt;/body&gt;&lt;/html&gt; 2.自定义标签的原理2.1访问页面到调用标签的过程​ 1）当服务器打开时，就会加载WEB-INF下的资源文件，包括web.xml 和 tld文件，把它们加载到内存 ​ 2）我们在浏览器输入http://localhost:8080/index.jsp来访问jsp页面 ​ 3）服务器读取index.jsp里的内容，当读到 &lt;%@taglib uri=&quot;http://mycompany.com/mytag&quot; prefix=&quot;mytag&quot; %&gt; 这一句的时候，就会在内存中找是否存在uri为http://mycompany.com/mytag的tld文件，找不到就会报错 ​ 4）继续读取jsp页面，读到&lt;mmt:mytag&gt;这个标签的时候，就会通过uri去找到tld文件，在tld文件中找到mytab是否被定义，是的话就得到它的tag-class的内容，然后去找到它对应的标签处理程序 ​ 5）实例化标签处理程序，利用生成的对象调用它里面的方法 2.2处理程序中方法的调用顺序服务器对标签处理程序里的方法也有一定的调用顺序 ​ A)void setPageContext(PageContext pc) –传入pageContext对象 ​ B)void setParent(Tag t) –如果有父标签，传入父标签对象，如果没有，则传入null ​ C)int doStartTag() –开始执行标签时调用。 ​ D)int doEndTag() –结束标签时调用 ​ E)void release() –释放资源 如果你没有重写上面的方法，系统将会调用它的父类里的方法~ 为什么是这个调用顺序，我们来看一下证据，下面是该jsp被翻译为的java文件中截取的内容 123456789101112131415161718192021222324252627282930313233343536373839private boolean _jspx_meth_mytag03_005fchangeBody_005f0(PageContext _jspx_page_context) throws Throwable &#123; //获取pageContext PageContext pageContext = _jspx_page_context; JspWriter out = _jspx_page_context.getOut(); // mytag03:changeBody com.yjf.tagTest.MyTag03 _jspx_th_mytag03_005fchangeBody_005f0 = (com.yjf.tagTest.MyTag03) _005fjspx_005ftagPool_005fmytag03_005fchangeBody.get(com.yjf.tagTest.MyTag03.class); //1.调用setPageContext方法 _jspx_th_mytag03_005fchangeBody_005f0.setPageContext(_jspx_page_context); //2.调用setParent方法 _jspx_th_mytag03_005fchangeBody_005f0.setParent(null); //3.调用doStartTag方法 int _jspx_eval_mytag03_005fchangeBody_005f0 = _jspx_th_mytag03_005fchangeBody_005f0.doStartTag(); if (_jspx_eval_mytag03_005fchangeBody_005f0 != javax.servlet.jsp.tagext.Tag.SKIP_BODY) &#123; if (_jspx_eval_mytag03_005fchangeBody_005f0 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) &#123; out = _jspx_page_context.pushBody(); _jspx_th_mytag03_005fchangeBody_005f0.setBodyContent((javax.servlet.jsp.tagext.BodyContent) out); _jspx_th_mytag03_005fchangeBody_005f0.doInitBody(); &#125; do &#123; out.write(&quot;\\r\\n&quot;); out.write(&quot; hello world!\\r\\n&quot;); //4.调用doAfterBody方法 int evalDoAfterBody = _jspx_th_mytag03_005fchangeBody_005f0.doAfterBody(); if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN) break; &#125; while (true); if (_jspx_eval_mytag03_005fchangeBody_005f0 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) &#123; out = _jspx_page_context.popBody(); &#125; &#125; //5.调用doEndTag方法 if (_jspx_th_mytag03_005fchangeBody_005f0.doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) &#123; _005fjspx_005ftagPool_005fmytag03_005fchangeBody.reuse(_jspx_th_mytag03_005fchangeBody_005f0); return true; &#125; _005fjspx_005ftagPool_005fmytag03_005fchangeBody.reuse(_jspx_th_mytag03_005fchangeBody_005f0); return false; &#125; 3.操作标签体中的内容​ 使用TagSupport能够实现控制标签体内容的输出，但是不能够修改标签体的内容。如果需要修改标签体的内容再输出，需要继承TagSupport的子类BodyTagSupport。 12345678910111213141516171819202122232425262728public class MyTag03 extends BodyTagSupport &#123; @Override public int doStartTag() throws JspException &#123; //表示输出标签体中的内容 return BodyTag.EVAL_BODY_BUFFERED; &#125; @Override public int doAfterBody() throws JspException &#123; //得到BodyContent对象，它包装了标签体里的内容 BodyContent bodyContent = this.getBodyContent(); //获取标签体中的内容 String content = bodyContent.getString(); //将字符串转换为大写 String change = content.toUpperCase(); try &#123; this.pageContext.getResponse().getWriter().write(change); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return Tag.EVAL_BODY_INCLUDE; &#125; @Override public int doEndTag() throws JspException &#123; return Tag.SKIP_PAGE; &#125;&#125; ​ 使用以上的方法定义的标签我们成为传统标签，这种方法相对比较麻烦，所以有人写出一组代码，用来解决这个问题，这组代码称为：简单标签 简单标签4.开发一个简单标签​ 实现简单标签需要继承SimpleTagSupport类 4.1创建处理类1234567public class SimpleTag extends SimpleTagSupport &#123; @Override public void doTag() throws JspException, IOException &#123; getJspBody().invoke(null); super.doTag(); &#125;&#125; 4.2注册123456&lt;tag&gt; &lt;name&gt;showBody&lt;/name&gt; &lt;tag-class&gt;com.yjf.tagTest.SimpleTag&lt;/tag-class&gt; &lt;!-- 这里需要用scriptless处理 --&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;/tag&gt; 4.3在将jsp中使用和传统标签一样的方法 5.简单标签的原理5.1访问过程1）和传统标签一样，得到tag-class字符串，找到标签处理程序类 2）实例化标签处理程序类 3）利用对象调用方法。。。。 5.2方法调用顺序和传统标签相比，简单标签调用的方法不相同： SimpleTag接口的方法执行过程： 1） void setJspContext(JspContext pc) ——设置pageContext对象，传入pageContext对象。JspContext是PageContext的父类。在标签处理器类中通过this.getJspContext()方法得到PageContext对象。 2）void setParent(JspTag parent) ——传入父标签对象，如果没有父标签，则不调用次方法。通过getParent方法得到父标签对象 3）void setJspBody(JspFragment jspBody) ——传入标签体内容。标签体内容封装到JspFragment方法中。通过getJspBody方法得到标签体内容。如果没签体，不调用此方法。 4）void doTag() ——开始标签和结束标签都执行次方法。 这个顺序也是有依据的，具体查看tomcat下的jsp编译文件 5.3控制标签体文本与结束标签后的内容是否输出我们可以通过JspFragment对象来控制– 标签体内容： ​ 要输出：在doTage()方法中执行jspFrament.invoke()方法 ​ 不输出：什么都不做！ 结束标签后的内容： ​ 要输出：什么都不做！ ​ 不输出：在doTag()方法中抛出一个SkipPageException异常。 那么如何循环输出标签体内容呢，在简单标签中实现十分简单，在doTag()方法中加一个for循环即可： 12345678910 public class SimpleTag extends SimpleTagSupport &#123; @Override public void doTag() throws JspException, IOException &#123; System.out.println(&quot;使用了简单标签中的doTag方法！&quot;); for(int i=0;i&lt;3;i++)&#123; getJspBody().invoke(null); &#125; super.doTag(); &#125;&#125; 5.4改变标签体中的内容在doTag()方法中这样写： 12345678910111213141516public class SimpleTag02 extends SimpleTagSupport &#123; @Override public void doTag() throws JspException, IOException &#123; //1.获取一个临时的输出流作为容器 StringWriter writer = new StringWriter(); //2.将标签体内容拷贝到writer流中 JspFragment jspFragment = this.getJspBody(); jspFragment.invoke(writer); //3.从临时的输出流中获取标签体内容 String tempStr = writer.toString(); //4.修改标签体内容 tempStr = tempStr.toUpperCase(); //5.通过JspContext将内容输出，这里注意使用jspFragment.invoke()还是输出修改前的标签体 this.getJspContext().getOut().write(tempStr); &#125;&#125; 5.5标签体内容输出格式除了能设置标签体内容是否输出，还能够设置它的输出格式，那么它有什么样的输出格式呢？ 可以有以下输出格式： __JSP__： 表示输出的标签体内容可以包含jsp脚本，且可以执行此脚本。此值只能用在传统标签中。 scriptless: 表示输出的标签体内容不能包含jsp脚本，如果包含则报错。 __empty__：表示没有标签体内容。即是空标签。如果不是空标签，则报错。 __tagdependent__： 表示输出的标签体内容可以包含jsp脚本。但不执行jsp脚本（直接原样输出） 5.6自定义标签属性下面定义一个if标签： 123456789101112131415public class MyIfTag extends SimpleTagSupport&#123; //定义一个属性，并生成setter方法 private boolean test; public void setTest(boolean test) &#123; this.test = test; &#125; @Override public void doTag() throws JspException, IOException &#123; //如果test为true，执行标签体 if (test)&#123; getJspBody().invoke(null); &#125; &#125;&#125; tld文件中定义test属性 1234567891011&lt;tag&gt; &lt;name&gt;if&lt;/name&gt; &lt;tag-class&gt;com.yjf.tagTest.MyIfTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;!-- 定义属性 --&gt; &lt;attribute&gt; &lt;name&gt;test&lt;/name&gt; &lt;required&gt;true&lt;/required&gt;&lt;!-- --&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt;&lt;!-- --&gt; &lt;/attribute&gt;&lt;/tag&gt; 6.最后的实践6.1任务使用SimpleTagSupport简单标签自定义一组标签、、 –其中when标签中有一个boolean类型的属性：test –choose是when和otherwise的父标签，when在otherwise之前使用 –在父标签中定义一个“全局”的boolean类型的flag：用于判断子标签在满足条件的情况下是否执行 –若when的tese为true，且when的父标签flag也为true，则执行when的标签体，并且设置父标签的flag为false –若when的test为true，且when的父标签flag为false，则不执行标签体 –若flag为true，otherwise执行标签体 6.2处理类MyChoose： 123456789101112131415 public class MyChoose extends SimpleTagSupport &#123; //全局的判断属性 private boolean flag = true; public boolean isFlag() &#123; return flag; &#125; public void setFlag(boolean flag) &#123; this.flag = flag; &#125; @Override public void doTag() throws JspException, IOException &#123; getJspBody().invoke(null); &#125;&#125; MyWhen： 123456789101112131415161718192021public class MyWhen extends SimpleTagSupport&#123; private boolean test; public void setTest(boolean test) &#123; this.test = test; &#125; @Override public void doTag() throws JspException, IOException &#123; //test为true if (test) &#123; //获取父标签的flag MyChoose choose = (MyChoose) getParent(); boolean flag = choose.isFlag(); //如果父标签的flag为trur，则执行when的标签体 if(flag)&#123; getJspBody().invoke(null); choose.setFlag(false); &#125; &#125; &#125;&#125; MyOtherwise： 1234567891011public class MyOtherwise extends SimpleTagSupport &#123; @Override public void doTag() throws JspException, IOException &#123; //获取父标签 MyChoose choose = (MyChoose) getParent(); //如果父标签中的flag为true，则执行otherwise的标签体 if(choose.isFlag())&#123; getJspBody().invoke(null); &#125; &#125;&#125; 6.3tld文件在tld文件中定义标签 1234567891011121314151617181920&lt;tag&gt; &lt;name&gt;choose&lt;/name&gt; &lt;tag-class&gt;com.yjf.tagTest.MyChoose&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt;&lt;/tag&gt;&lt;tag&gt; &lt;name&gt;when&lt;/name&gt; &lt;tag-class&gt;com.yjf.tagTest.MyWhen&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;test&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt;&lt;/tag&gt;&lt;tag&gt; &lt;name&gt;otherwise&lt;/name&gt; &lt;tag-class&gt;com.yjf.tagTest.MyOtherwise&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt;&lt;/tag&gt; 6.4jsp中使用接下来就是在jsp中使用这些个标签啦 12345678&lt;myc:choose&gt; &lt;myc:when test=&quot;$&#123;false&#125;&quot;&gt; when body &lt;/myc:when&gt; &lt;myc:otherwise&gt; otherwise body &lt;/myc:otherwise&gt;&lt;/myc:choose&gt; 如上，页面中显示 otherwise body。","tags":[{"name":"Java","slug":"Java","permalink":"http://houghmzqqq.gihub.io/tags/Java/"}]},{"title":"synchronized和Lock的区别","date":"2018-01-08T11:36:58.000Z","path":"2018/01/08/synchronized和Lock的区别/","text":"1.Thread的几个重要方法我们先了解一下Thread的几个重要方法：​ a、start()方法，调用该方法开始执行该线程；​ b、stop()方法，调用该方法强制结束该线程执行；​ c、join方法，调用该方法等待该线程结束。​ d、sleep()方法，调用该方法该线程进入等待。​ e、run()方法，调用该方法直接执行线程的run()方法，但是线程调用start()方法时也会运行run()方法，区别就是一个是由线程调度运行run()方法，一个是直接调用了线程中的run()方法！！ ​ 看到这里，可能有些人就会问啦，那wait()和notify()呢？要注意，其实wait()与notify()方法是Object的方法，不是Thread的方法！！同时，wait()与notify()会配合使用，分别表示线程挂起和线程恢复。 ​ 这里还有一个很常见的问题，顺带提一下：wait()与sleep()的区别，简单来说wait()会释放对象锁而sleep()不会释放对象锁。这些问题有很多的资料，不再赘述。 2.线程的状态 线程总共有5大状态。 新建状态：新建线程对象，并没有调用start()方法之前 就绪状态：调用start()方法之后线程就进入就绪状态，但是并不是说只要调用start()方法线程就马上变为当前线程，在变为当前线程之前都是为就绪状态。值得一提的是，线程在睡眠和挂起中恢复的时候也会进入就绪状态哦。 运行状态：线程被设置为当前线程，开始执行run()方法。就是线程进入运行状态 阻塞状态：线程被暂停，比如说调用sleep()方法后线程就进入阻塞状态 死亡状态：线程执行结束 3.锁的类型 可重入锁：在执行对象中所有同步方法不用再次获得锁 可中断锁：在等待获取锁过程中可中断 公平锁： 按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利 读写锁：对资源读取和写入的时候拆分为2部分处理，读的时候可以多线程一起读，写的时候必须同步地写 4.synchronized和Lock的区别 类别 synchronized Lock 存在层次 JAVA的关键字，在jvm层面上的 是一个类 锁的释放 1.已获取锁的线程执行完代码，释放锁 2.线程执行发生异常时，jvm会让线程释放锁 在finally中必须释放锁，不然容易造成线程死锁 锁的获取 假如A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待。 分情况而定，Lock有多个获取锁的方式，大致是可以尝试获得所，线程可以不用一直等待 锁状态 无法判断 可以判断 锁类型 可重入 不可中断 非公平 可重入 可中断 可公平(可非公平) 性能 少量同步 大量同步","tags":[{"name":"Java","slug":"Java","permalink":"http://houghmzqqq.gihub.io/tags/Java/"},{"name":"线程","slug":"线程","permalink":"http://houghmzqqq.gihub.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"redis学习笔记","date":"2018-01-02T11:47:27.000Z","path":"2018/01/02/redis学习笔记/","text":"1.什么是redis​ redis是一种NoSql（非关系型数据库），它是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。 2.redis的安装redis一般是安装在liunx上的，本人使用centOs进行安装 2.1配置环境​ redis是使用c语言开发的，使用它需要配置c语言的运行环境，需要在centOs中安装gcc-c++软件 1yum install gcc-c++ ​ 下载redis for linux，使用SecureCRT上传到虚拟机上运行的centOs，并进行解压 1tar -zxvf redis-4.0.6.tat.gz ​ 解压后进入redis-4.0.6文件夹 1cd redis-4.0.6 ​ 然后执行make命令，对它进行基本的编译 1make ​ 进行基本的安装 1make PREFIX&#x3D;&#x2F;usr&#x2F;local&#x2F;redis install ​ 然后进到/usr/local/redis/bin目录中 1cd &#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin ​ 该目录中可以看到以下文件 ] redis-benchmark 性能测试的工具 redis-check-aof aof文件修复工具 redis-check-rdb rdb文件检查工具 redis-cli 命令行的客户端 redis-sentinel -&gt; redis-server redis-server redis服务器启动命令 ​ 回到redis-4.0.6目录下，将redis.conf文件复制到redis目录 1cp redis.conf &#x2F;usr&#x2F;local&#x2F;redis ​ 修改redis.conf文件 将daemonize yes 改为 no (表示开启) 将bind 127.0.0.1 注释掉(否则，redis只能由本机访问) 将protected-mode yes 改为no(表示关闭保护模式，否则在关闭bind的情况下，不能通过外部程序访问redis) ​ 启动redis 1.&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-server .&#x2F;usr&#x2F;local&#x2F;redis&#x2F;redis.conf ​ 查看是否启动 1ps -ef | grep -i redis ​ 关闭redis 1.&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli shutdown ​ 执行客户端，之后就可以向redis数据库存取数据了 1.&#x2F;usr&#x2F;local&#x2F;redis&#x2F;bin&#x2F;redis-cli ​ 插入命令，插入一个key=name，value=zhangsan的数据 1set name zhangsan ​ 查询命令，查询key=name的数据 1get name ​ 查看所有key名称 1keys * 3.使用jedis操作linux上的redis​ jedis是redis官方推荐的一个针对java语言的客户端，使用它可以使用java程序操作redis。 3.1打开redis端口在root用户下，通过vim /etc/sysconfig/iptables 修改防火墙配置， 以上6379为默认端口，配置你自己的redis端口 3.2在maven工程中导入jar包12345678910&lt;dependency&gt; &lt;groupId&gt;commons-pool&lt;/groupId&gt; &lt;artifactId&gt;commons-pool&lt;/artifactId&gt; &lt;version&gt;1.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt; 3.3测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class JedisDemo1 &#123; /** *连接linux上的redis **/ @Test public void demo1()&#123; //1.设置ip地址和端口号 Jedis jedis = new Jedis(&quot;192.168.13.153&quot;); //2.保存数据 jedis.set(&quot;name&quot;,&quot;yejunfeng&quot;); //3.获取数据 System.out.println(jedis.get(&quot;name&quot;)); //4.释放资源 jedis.close(); &#125; /** *设置redis的连接池 **/ @Test public void demo2()&#123; //1.获得连接池配置对象 JedisPoolConfig config = new JedisPoolConfig(); //设置最大连接数 config.setMaxTotal(10); //设置最大空闲连接数 config.setMaxIdle(5); //获得连接池 JedisPool jedisPool = new JedisPool(config,&quot;192.168.13.153&quot;,6379); //获得jedis对象 Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); jedis.set(&quot;handsome&quot;,&quot;yjf&quot;); System.out.println(jedis.get(&quot;handsome&quot;)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if(jedis!=null)&#123; jedis.close(); &#125; if(jedisPool!=null)&#123; jedisPool.close(); &#125; &#125; &#125;&#125; 4.redis中的数据结构redis有5种数据结构，分别是hash、String、list、sort set、set 4.1字符串的基本操作 set key value get key value incr key(该key的value为一个可以转换为数字的字符串，否则报错) decr key incrby key 4(表示该key的值加4) decrby key 4(表示该key的值减4) append key aa(如果key的值为b，执行该命令后key的值为aab) 4.2hash的基本操作key为hash的名称，field为属性名，value为属性值 hset key field value hget key field hdel key field hgetall key hmset key field value [field value] hincrby key field increment(使hash的某个属性增加‘increment’) hexists key field(判断某个hash的某个属性是否存在) hlen key(返回某个hash的属性个数) hkeys key(返回某个hash的所有属性名称) hvals key(返回某个hash的所有属性的值) 4.3list的基本操作 lpush key value [value] (从左边将元素放入队列) lpushx key value [value] (为已存在的列表添加至) rpush key value [value] (从右边将元素放入队列) lrange key start stop (start和stop表示查找的范围，0 -1 表示查找全部) lindex key index (通过索引查找列表中的元素) rpop key (弹出列表的最后一个元素) rpoplpush list1 list2 (将list1中的最后一个元素删除并移出，放入list2的头部) linsert key BEFORE|AFTER pivot value (在pivot之前或之后插入元素) 4.4set的基本操作","tags":[{"name":"redis","slug":"redis","permalink":"http://houghmzqqq.gihub.io/tags/redis/"},{"name":"数据库","slug":"数据库","permalink":"http://houghmzqqq.gihub.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"mybatis学习笔记","date":"2018-01-02T01:03:25.000Z","path":"2018/01/02/mybatis学习笔记/","text":"1.初次使用mybatis1.1通过maven导入jar包1234567891011&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.30&lt;/version&gt;&lt;/dependency&gt; 1.2mybatis的配置文件mybatis需要一个全局的配置文件，在其中声明数据库、连接池等参数 1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- 配置数据库连接信息 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot; /&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;XDP&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;User.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.3创建一个实体类User以及相应的映射文件User.xml1234567public class User &#123; private int id; private String userName; private String password; …getter and setter…&#125; 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- 为这个mapper指定一个唯一的namespace，namespace的值习惯上设置成包名+sql映射文件名，这样就能够保证namespace的值是唯一的例如namespace=&quot;me.gacl.mapping.userMapper&quot;就是me.gacl.mapping(包名)+userMapper(userMapper.xml文件去除后缀) --&gt;&lt;mapper namespace=&quot;me.gacl.mapping.userMapper&quot;&gt; &lt;!-- 在select标签中编写查询的SQL语句， 设置select标签的id属性为getUser，id属性值必须是唯一的，不能够重复 使用parameterType属性指明查询时使用的参数类型，resultType属性指明查询返回的结果集类型 resultType=&quot;me.gacl.domain.User&quot;就表示将查询结果封装成一个User类的对象返回 User类就是users表所对应的实体类 --&gt; &lt;!-- 根据id查询得到一个user对象 --&gt; &lt;select id=&quot;getUser&quot; parameterType=&quot;int&quot; resultType=&quot;me.gacl.domain.User&quot;&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;","tags":[{"name":"框架","slug":"框架","permalink":"http://houghmzqqq.gihub.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"java多态","date":"2017-12-18T03:26:23.000Z","path":"2017/12/18/java多态/","text":"什么是多态面向对象的三大特性： ​ 1.封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。 ​ 2.继承：一个类可以继承另一个类，子类可以访问父类的属性和方法。 ​ 3.多态：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。 举个栗子： ​ 有一个Person类，它封装了walk()和talk()两个行为。有一个Teacher类继承了Person，Teacher也能够walk()和talk()，在此基础上他还能够teach()。 ​ 现在有Person per = new Teacher();，它表示Person的引用指向Teacher对象，per能够使用Person中的方法但不能使用Student中独有的teach(),能够访问Person中的__非私有(private)属性__，如果Student中重写了Person中的walk()方法，则per.walk()实际上是使用了重写后的walk()。 ​ 总的来说，java中的多态有三个条件：继承，重写，父类引用指向子类对象 第二个栗子： 123456789101112131415161718class A ...&#123; public String show(D obj)...&#123; return (&quot;A and D&quot;); &#125; public String show(A obj)...&#123; return (&quot;A and A&quot;); &#125; &#125; class B extends A...&#123; public String show(B obj)...&#123; return (&quot;B and B&quot;); &#125; public String show(A obj)...&#123; return (&quot;B and A&quot;); &#125; &#125; class C extends B...&#123;&#125; class D extends B...&#123;&#125; 123456789101112131415A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println(a1.show(b)); 1System.out.println(a1.show(c)); 2System.out.println(a1.show(d)); 3System.out.println(a2.show(b)); 4System.out.println(a2.show(c)); 5System.out.println(a2.show(d)); 6System.out.println(b.show(b)); 7System.out.println(b.show(c)); 8System.out.println(b.show(d)); 9 结果： 1234567891 A and A2 A and A3 A and D4 B and A5 B and A6 A and D7 B and B8 B and B9 A and D","tags":[{"name":"Java","slug":"Java","permalink":"http://houghmzqqq.gihub.io/tags/Java/"}]},{"title":"JSONObject使用心得","date":"2017-12-15T12:48:54.000Z","path":"2017/12/15/JSONObject使用心得/","text":"对于JSONObject的使用心得​ 最近在一个项目中需要频繁使用JSON数据来做数据接口，使用到了JSONObject工具类，这是java中一个强大的json转Object、Object转json的工具。 1.maven中导入的jar：12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!-- Exclude Commons Logging in favor of SLF4j --&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-lang.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib-ext-spring&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt;&lt;/dependency&gt; 大概这些，可能还有些漏掉的… 2.使用2.1拼接jsonJSONObject可以逐个拼接字符串组成json，示例： 1234JSONObject jsonObject = newJSONObject();jsonObject.accumulate(&quot;action&quot;,&quot;register&quot;);jsonObject.accumulate(&quot;result&quot;,&quot;ok&quot;);jsonObject.toString(); 以上的代码输出{“action”:”register”,”result”:”ok”} 2.2拼接json数据使用JSONArray类封装json数据，示例： 123456789JSONObject json01 = newJSONObject();jsonObject.accumulate(&quot;action&quot;,&quot;register&quot;);jsonObject.accumulate(&quot;result&quot;,&quot;ok&quot;);JSONObject json02 = newJSONObject();jsonObject.accumulate(&quot;action&quot;,&quot;login&quot;);jsonObject.accumulate(&quot;result&quot;,&quot;ok&quot;);JSONArray jsonArray = new JSONArray();jsonArray.add(json01);jsonArray.add(1,json02); 上面代码输出[{“action”:”register”,”result”:”ok”},{“action”:”login”,”result”:”ok”}] 2.3json转Object，Object转jsonJSONObject可以直接将一个对象转化为json数据格式，示例： 12345public class Student()&#123; private String name; private String gander; ...setter and getter...&#125; 123456//通过JSONObject将对象转化为json数据格式Student stu = new Student();stu.setName(&quot;Jack&quot;);stu.setGander(&quot;man&quot;);JSONObject jsonObject = JSONObject.fromObject(stu);jsonObject.toString(); 上述代码输出{“name”:”Jack”,”gander”:”man”} 如果Student中包含其他对象，JSONArray转化Student对象时，需要用到一个map，示例： 123456public class Student()&#123; private String name; private String gander; private List&lt;Course&gt; courses; ...setter and getter...&#125; 12345678Map&lt;String,Object&gt; map = new HashMap&lt;~&gt;();map.put(&quot;courses&quot;,Course.class);//data表示一个json格式的stu数组JSONObject jsonObject = JSONObject.fromObject(&quot;&lt;data&gt;&quot;);//stu为Student数组的名称JSONArray jsonArray = jsonObject.getJSONArray(&quot;stu&quot;);//解析student数组中的Course数组List&lt;Course&gt; courses = JSONArray.toList(jsonObject,Student.class,map);","tags":[{"name":"笔记","slug":"笔记","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"代理模式","date":"2017-11-08T11:50:02.000Z","path":"2017/11/08/代理模式/","text":"1.远程代理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一冰淇淋公司制作了一个控制冰淇淋生产的系统，现在有一个新的需求，该公司CEO希望能够远程获取生产系统的信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CEO希望远程遥控生产系统，所以首先CEO这边的计算机上需要运行该系统，我们知道不同机器上运行的同一种程序会存在于不同的JVM中，它们之间是没有直接联系的。我们可以通过远程代理的方式让它们进行通信。 Java中的RMI","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://houghmzqqq.gihub.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"线程笔记","date":"2017-11-02T05:41:17.000Z","path":"2017/11/02/线程笔记/","text":"1.Thread和Runnable Thread是Runnable的实现类，定义一个线程类时，可以通过实现Runnable接口并实现run()方法实现；也可以通过继承Thread并重写run()方法实现。 区别在于，由于java不支持多继承，当你的线程类需要继承其他的类时，就需要用到Runnable 使用Thread实现线程类： 12345public class MyThread01 extends Thread &#123; public void run() &#123; //实现... &#125;&#125; 使用Runnable实现线程类： 1234public class MyThread02 implements Runnable &#123; public void run() &#123; //实现... &#125; 运行： 12345678public class Client&#123; public static void main(String args[])&#123; //直接调用start()方法启动 new MyThread01.start(); //需要使用Thread中的start()方法启动 new Thread(new MyThread02()).start(); &#125;&#125; 2.Executor Executor在客户端和任务执行之间提供了一个间接层；与客户端直接执行任务不同，任务将由这个中介对象执行。Executor允许你管理异步任务的执行，而无需显式地管理线程的生命周期。1）.CachedThreadPool为每个任务创建一个线程[与普通的线程启动没什么区别]2）.FixedThreadPool可以限制线程的作用： 12345678910public class Client &#123; public static void main(String[] args) &#123; //使用Executors的静态方法确定ExecutorService的类型 ExecutorService exec = Executors.newFixedThreadPool(5); for(int i=0;i&lt;10;i++)&#123; exec.execute(new MyThread()); &#125; exec.shutdown(); &#125;&#125; 如上代码，设置容量为5，当存在5个线程时，其他任务将延后处理，当有线程结束时再执行。. . . 3.Callable 如果你的线程类实现了__Callable__而不是Runnable，则线程结束时会__返回一个类型为Future结果__。与Runnable类似，实现Callable需要实现它的call()方法，并且必须_使用ExecutorService中的submit()方法启动线程_。示例：实现Callable接口并实现call()方法 1234567891011public class MyCallable implements Callable&lt;String&gt; &#123; private int id; public MyCallable(int id) &#123; this.id = id; &#125; @Override public String call() throws Exception &#123; return &quot;result of MyCallable&quot; + id; &#125;&#125; 启动线程，接收结果并输出 1234567891011121314151617181920public class Client &#123; public static void main(String[] args) &#123; ExecutorService exec = Executors.newCachedThreadPool(); List&lt;Future&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); for(int i=0;i&lt;10;i++)&#123; list.add(exec.submit(new MyCallable(i))); &#125; try &#123; for(Future&lt;String&gt; ft : list)&#123; System.out.println(ft.get()); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125;finally&#123; exec.shutdown(); &#125; &#125;&#125; 4.多线程的资源共享4.1多线程调用一个资源的例子1）.首先定义一个抽象类IntGenerator，作为被消费者的父类 123456789101112public abstract class IntGenerator &#123; private volatile boolean canceled = false; //被消费者的功能在这个方法中定义 public abstract int next(); //能够被取消 public void cancel()&#123; canceled = true; &#125; public boolean isCanceled()&#123; return canceled; &#125;&#125; 2）.消费者EvenChecker，它是一个线程类 123456789101112131415161718192021222324252627282930public class EvenChecker implements Runnable &#123; private IntGenerator generator; private final int id; public EvenChecker(IntGenerator generator, int id) &#123; this.generator = generator; this.id = id; &#125; @Override public void run() &#123; System.out.println(&quot;Thread: &quot; + id); while(!generator.isCanceled())&#123; int val = generator.next(); if(val % 2 != 0)&#123; System.out.println(val + &quot; not even!&quot;); generator.cancel(); &#125; &#125; &#125; //测试任意类型的IntGenerator public static void test(IntGenerator gp,int count)&#123; System.out.println(&quot;Press Contro-c to exit&quot;); ExecutorService excu = Executors.newCachedThreadPool(); for(int i=0;i&lt;count;i++)&#123; excu.execute(new EvenChecker(gp,i)); &#125; &#125; public static void test(IntGenerator gp)&#123; test(gp,10); &#125;&#125; 3）.被消费者 12345678910111213public class EvenGenerator extends IntGenerator &#123; private int currentEvenvalue = 0; //生产偶数 public int next() &#123; ++currentEvenvalue; //冲突点 ++currentEvenvalue; return currentEvenvalue; &#125; public static void main(String[] args) &#123; EvenChecker.test(new EvenGenerator()); &#125;&#125; 执行上面的程序时，__一个任务有可能在另一个任务执行第一个对currentEvenvalue的递增操作之后，但是没有执行第二个操作之前[即注释”冲突点”的地方]，调用next()方法__。这就使得next()返回的值可能是一个奇数，这时线程会调用cancel()方法取消被消费者。 4.2 解决共享资源竞争1）使用synchronized关键字修饰方法 在上面的问题中，可能发生冲突的代码是next()方法，我们使用synchronized关键字修饰该方法 12345678public synchronized int next() &#123; ++currentEvenvalue; //冲突点 Thread.yeild(); //提高发生冲突的可能性 ++currentEvenvalue; return currentEvenvalue; &#125; 2）使用ReentrantLock加锁 12345678910111213private Lock lock = new ReentrantLock();public int next() &#123; lock.lock(); try&#123; ++currentEvenvalue; //冲突点 Thread.yeild(); //提高发生冲突的可能性 ++currentEvenvalue; return currentEvenvalue; &#125;finally&#123; lock.unlock(); &#125; &#125; 使用lock.lock()和lock.unlock()将方法块包围起来，为这个方法块加一个互斥锁。需要注意的是，对lock()的调用，你必须放置在finally字句中带有unlock()的fry-finally语句之前。 关于wait()和sleep()方法1.wait来自Object类，sleep来自Thread类，它是一个静态方法 2.使用wait时释放了锁，使用sleep时没有释放锁 ​ 使用sleep让线程睡觉时，它不会让出资源，所以它是占着cpu睡觉的。 ​ wait是进入线程等待池等待，让出系统资源，敏感词线程可以占用cpu。然后等待敏感词线程调用notify、notifyAll唤醒等待池中的所有线程。 3.wait、notify和notifyAll只能在同步控制方法块（synchronized）中使用，sleep能够在任何地方使用，sleep需要捕获异常。","tags":[{"name":"Java","slug":"Java","permalink":"http://houghmzqqq.gihub.io/tags/Java/"},{"name":"线程","slug":"线程","permalink":"http://houghmzqqq.gihub.io/tags/%E7%BA%BF%E7%A8%8B/"}]},{"title":"数据结构之查找","date":"2017-10-16T13:00:27.000Z","path":"2017/10/16/数据结构之查找/","text":"1. 静态表的查找1.1 顺序查找&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从第一个记录开始逐个比较关键字。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顺序查找的效率（用平均查找长度表示）ASL=(n+1)/2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与其他查找方法相比，顺序查找法查找成功的平均查找长度较长，但是对查找表没有什么要求，并且线性链表只能进行顺序查找。 1.2有序表的查找有序表是指查找表按关键字排序，一般采用折半查找来实现。过程如下图：对于7个元素的查找表{1,3,4,5,7,8,9}，查找关键字key=4 2. 动态查找表2.1 二叉搜索树2.1.1 二叉搜索树的定义1）如果左子树不为空，则左子树上的所有节点上的值小于根节点的值2）如果右子树不为空，则右子树上的所有节点上的值大于根节点的值3）左右子树也分别是二叉搜索树 2.1.2 二叉搜索树生成过程设关键字序列为{16,8,28,6,18,10}，则二叉树生成过程如下： 2.2 二叉平衡树（AVL树）2.2.1 定义AVL树是一种特殊的二叉搜索树，即具有以下特征的二叉搜索树：1）根的左、右子树的高度差的绝对值不大于12）根的左、右子树都是AVL树 平衡因子：根的左右子树的高度差最小不平衡节点：平衡因子的绝对值大于1的节点称为不平衡节点，高度最低的不平衡节点就是最低不平衡节点 2.2.2 失去平衡时的调整方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在平衡二叉树进行插入操作时遇到的不平衡情况有多种，但是这么多种情况都可以分解为一下四中基础情景：把它叫做：左左、左右、右右、右左。 四种情景命名意义：左左：节点插入在最小不平衡节点的&nbsp;&nbsp;左子树&nbsp;&nbsp;的&nbsp;&nbsp;左子树&nbsp;&nbsp;上。左右：节点插入在最小不平衡节点的&nbsp;&nbsp;左子树&nbsp;&nbsp;的&nbsp;&nbsp;右子树&nbsp;&nbsp;上面右右：节点插入在最小不平衡节点的&nbsp;&nbsp;右子树&nbsp;&nbsp;的&nbsp;&nbsp;右子树&nbsp;&nbsp;上面。 右左：节点插入在最小不平衡节点的&nbsp;&nbsp;右子树&nbsp;&nbsp;的&nbsp;&nbsp;左子树&nbsp;&nbsp;上面。 针对以上四种情况，各自有相对应的调整平衡的方法： 1） 左左–右旋 2） 左右–先左旋再右旋 这里解释一下为什么上图的情况需要旋转两次 上面是直接进行右旋的结果，这种情况下直接进行右旋，最后的结果还是不平衡 上图先以6为节点左旋，降低6节点右子树的高度，然后再进行右旋 3）右右–左旋 4) 右左–先右旋在左旋 与左右类似的，先对18进行右旋，调低18节点的左子树高度，在对10节点进行左旋 3.散列表3.1 概念&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashTable是一种结合数组和链表的构造方法。在线性表的存储结构中，数组和链表的特点： 数组——寻址容易，插入和删除困难链表——寻址困难，插入和删除容易 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashTable就是为了构造一种寻址容易，插入和删除也容易的存储结构。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashTable中定义了一个数组，用来存放数据的地址，每个数组中存放一个链表的表头，用来存放数据 3.2构造散列函数的方法1）.平方取中法2）.随机数法3）.除留余数法：H(key) = key % length [length为数组长度] 3.3处理冲突的方法1）.开放定址法 如果发生冲突，则往后找空余位置， 2）.链地址发","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://houghmzqqq.gihub.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"树和二叉树","date":"2017-10-14T12:07:02.000Z","path":"2017/10/14/树和二叉树/","text":"1. 树的定义有序树：节点的位置对树的结构有关，节点的位置改变会改变该树的意义。无序树：与有序树相反，节点的位置不关乎树的结构。二叉树：是有序树的一种。 2. 二叉树的存储结构2.1 顺序存储结构将完全二叉树的各个节点按照节点编号依次存放入数组中。 由于该树是完全二叉树，可以很容易的找到节点的的双亲节点和子节点。 对于含有n个节点的完全二叉树，任意节点i有以下关系： 1.若i=1,则节点i是根节点；若i&gt;1，则节点[i/2]为双亲节点。 2.若2i&gt;n，则节点i无左孩子，否则节点[2i]为左孩子。 3.若2i+1&gt;n，则节点无右孩子，否则节点[2i+1]为右孩子 2.2 链式存储结构在每一个节点中定义两个分别指向左孩子和右孩子节点的指针。 2.3 二叉树遍历使用递归算法 2. 普通有序树转换为二叉树 3. 哈弗曼树与哈夫曼编码3.1 哈夫曼树的几个相关概念1）路径：从树的一个节点到另一个节点的路径；对于哈夫曼树是指从根节点到某一节点的路径。2）树的路径长度：从根节点到某一节点的路径上的分支数目3）权：对某个节点定义某些属性或数值化的描述。4）带权路径长度：树中所有叶子结点的带权路径长度之和。设某个树中有n个叶子结点，他们的权值分别为w1，w1……wn，从根到各叶子结点的路径长度分别为l1,l2……ln，则该树的带权路径长度为WPL=（w1*l1 + w2*l2 + … + wn*ln）。5）哈弗曼树：设树有n个叶子结点，它们的权值分别为w1，w2……wn,其中带权路径长度WPL最小的二叉树叫做最优树，即哈弗曼树。 3.2 哈夫曼树的构建1）给定n个权值，构造由n可二叉树构成的森林。2）从森林中取出两个根节点的权值最小的两个颗树(如果这样的树不止两棵，则人选其中两棵)，分别做左右子树构造一颗新的二叉树，并置这棵二叉树的权值为其左右子树的权值之和。3）从森林中删去这两棵二叉树，并将新生成的二叉树加入森林中，循环执行 2）、3）。 3.3 哈夫曼树例题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对只含有字符{A,B,C,D}的字符串进行二进制编码。可以对每个字符进行等长编码，{A,B,C,D}分别对应{00,01,10,11},对于报文“ABCDBDBB”，它的编码为“0001101101110101”,编码长度为(1 + 4 + 1 + 2) * 2 = 16。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，在已知传输的字符集合及其出现的频度的情况下，使用哈夫曼树对每个字符进行编码可以使总编码长度达到最短。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;已知{A,B,C,D}出现频度分别为{1,4,1,2},画出它的哈夫曼树： 由上图可得出字符编码： A:110B:0C:111D:10 得出字符串“ABCDBDBB”的编码为“11001111001000”，长度为(1*3+4*1+1*3+2*2) = 14。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://houghmzqqq.gihub.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"BigDecimal控制精度及BigInteger解决整数溢出","date":"2017-10-13T14:15:57.000Z","path":"2017/10/13/BigDecimal控制精度及BigInteger解决整数溢出/","text":"1. BigDecimal1.1 进行精确计算1234public void test()&#123; System.out.println(0.06 + 0.01); System.out.println(1.0 - 0.42); &#125; 执行以上代码的结果是： 0.06999999999999999 0.5800000000000001 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原因在于我们的计算机是二进制的。浮点数没有办法是用二进制进行精确表示。我们的CPU表示浮点数由两个部分组成：指数和尾数，这样的表示方法一般都会失去一定的精确度，有些浮点数运算也会产生一定的误差。如：2.4的二进制表示并非就是精确的2.4。反而最为接近的二进制表示是 2.3999999999999999。浮点数的值实际上是由一个特定的数学公式计算得到的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用BigDecimal进行精确运算 12345public static double add(double value1,double value2)&#123; BigDecimal b1 &#x3D; new BigDecimal(String.valueOf(value1)); BigDecimal b2 &#x3D; new BigDecimal(String.valueOf(value2)); return b1.add(b2).doubleValue(); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里需要使用new BigDecimal(String str)构造方法实例化BigDecimal，然后通过内置的add()方法进行精确加法运算(相应的subtract()、multiply()、divide()方法进行其他运算)。[因为使用new BigDecimal(Double d) 时，得到的BigDecimal中的long值并不是精确的，使用new BigDecimal(String str)才能达到精确运算的目的] 1.2 控制精度有时会遇到保留小数点后两位，这样的要求精度的需求。可以使用BigDecimal控制。 12BigDecimal b1 &#x3D; new BigDecimal(0.33333);BigDecimal b2 &#x3D; b1.setScale(2,BigDecimal.ROUND_HALF_UP); 其中b1.setScale(2,BigDecimal.ROUND_HALF_UP)表示设置b1的精度为2并且采用四舍五入的策略 2. BigInteger&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java中常规的进行整数运算的类有两个，Integer和Long，其中Long的表示范围比Integer要大，Long能够表示的最大值为2^63-1 = 9223372036854775807，当需要进行运算的数超过这个值时会发生溢出。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以使用BigInteger进行大整数的运算。 12BigInteger bi1 &#x3D; new BigInteger(String.valueOf(10));BigInteger bi2 &#x3D; bi1.multiply(new BigInteger(&quot;100000000000000000000000000000000000000000000&quot;));","tags":[{"name":"Java","slug":"Java","permalink":"http://houghmzqqq.gihub.io/tags/Java/"}]},{"title":"适配器模式","date":"2017-10-11T10:57:38.000Z","path":"2017/10/11/适配器模式/","text":"类图： 将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 Adaptee类表示被转换的类 Adapter是适配器 Traget是目标类，Adapter实现Traget，将Adaptee转换成Traget","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://houghmzqqq.gihub.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"工厂模式","date":"2017-10-09T08:38:43.000Z","path":"2017/10/09/工厂模式/","text":"1. 简单工厂模式类图： 定义一个工厂类，将所有创建产品实例的动作交给工厂类完成。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Product是一个由工厂管理的产品类，ProductA和ProductB是它的子类。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Factory是一个简单工厂类，它拥有一个产品类属性，能够根据要求实例化用户所需的产品类。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;User是一个用户类，它表示一个向工厂申请产品实例的类，拥有一个工厂类属性。 2. 工厂方法模式类图： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在用户类中定义一个createProduct()抽象方法，在它的子类中实现该方法，在该方法中实例化产品。故称为工厂方法。工厂方法把对象的创建委托给子类，延迟创建对象的方法的实现。 3. 抽象工厂方法类图： 使用对象组合，对象的创建被实现在工厂接口所暴露出来的方法中。它可以创建相关的对象，而不需要依赖它们的具体类。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://houghmzqqq.gihub.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"观察者模式","date":"2017-10-09T05:31:22.000Z","path":"2017/10/09/观察者模式/","text":"类图： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subject是一个观察者类，它可以添加、删除主题，观察变化并反馈给主题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConcreteSubject是观察者的实现类&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Observer是一个主题类，它有一个update()方法，观察者通过调用这个方法通知主题进行更新&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConcreteObserver是主题的实现类 观察者实现类： 主题实现类： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subject中有个存放主题的集合，当调用registerObserver()[注册主题]方法时，将主题加入该集合中，观察者发现变化时，会调用notifyObserver()方法，notifyObserver()中通过调用主题中的update()方法提示主题进行更新。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://houghmzqqq.gihub.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"装饰者模式","date":"2017-09-18T14:39:37.000Z","path":"2017/09/18/装饰者模式/","text":"类图： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Component表示一个组件，也是一个超类 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConcreteComponent是一个具体组件，即相当于Component的实现类 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decorator装饰者类,继承Component &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConcreteDecorator具体的装饰者类，即相当于Decorator的实现类，每一个ConcreteDecorator中拥有一个Component的实例，记录所装饰的事物。在装饰者类中定义新行为，新的行为通过在旧的行为前面或后面做一些计算来达到装饰的目的","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://houghmzqqq.gihub.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"SpringMVC笔记","date":"2017-09-16T08:26:20.000Z","path":"2017/09/16/SpringMVC笔记/","text":"1. Spring mvc 的配置1.1 首先，我们需要在web.xml中定义Spring mvc的servlet 12345678910111213141516171819202122232425&lt;!-- 配置Spring应用上下文 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- DispatcherServlet,Spring MVC的核心 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 对应Spring应用的上下文 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 修改配置文件的路径 --&gt; &lt;param-value&gt;classpath:mvc-dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;!-- 表示mvc-dispatcher拦截所有的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 1.2 配置Spring mvc 的xml文件，为 DispatcherServlet提供相应的配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt; &lt;!-- 本配置文件是名为mvc-dispatcher的DispatcherServlet使用的，为其提供相关的Spring MVC配置 --&gt; &lt;!-- 激活@Required等注解 --&gt; &lt;context:annotation-config/&gt; &lt;!-- DispatcherServlet上下文，只搜索@Controller注解的类 --&gt; &lt;context:component-scan base-package=&quot;com.yejunfeng.action&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Repository&quot;/&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Service&quot;/&gt; &lt;/context:component-scan&gt; &lt;!-- 扩充了注解驱动，可以将请求参数绑定到控制器参数 --&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:interceptors&gt; &lt;!--国际化操作拦截器 如果采用基于（请求/Session/Cookie）则必需配置--&gt; &lt;bean class=&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot; /&gt; &lt;!-- 如果不定义 mvc:mapping path 将拦截所有的URL请求 --&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**/*&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/fonts/*&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.css&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.js&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.png&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.gif&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.jpg&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.jpeg&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*login*&quot;/&gt; &lt;bean class=&quot;com.xyz.gym_management_sys.filter.SecurityInterceptor&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**/equ/*&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/fonts/*&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.css&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.js&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.png&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.gif&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.jpg&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.jpeg&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*login*&quot;/&gt; &lt;bean class=&quot;com.xyz.gym_management_sys.filter.EquManageInterceptor&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**/userManage/*&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/fonts/*&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.css&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.js&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.png&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.gif&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.jpg&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.jpeg&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*login*&quot;/&gt; &lt;bean class=&quot;com.xyz.gym_management_sys.filter.UserManageInterceptor&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;!-- 静态资源处理，入css，js，image --&gt; &lt;!--&lt;mvc:resources location=&quot;/images/&quot; mapping=&quot;/images/**&quot; /&gt;--&gt; &lt;mvc:resources location=&quot;/lib/&quot; mapping=&quot;/lib/**&quot; /&gt; &lt;mvc:resources location=&quot;/stylesheets/&quot; mapping=&quot;/stylesheets/**&quot; /&gt; &lt;!-- 拼接视图的名称，prefix表示前缀，suffix表示后缀 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot;&gt;&lt;/property&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/jsps/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 文件上传的bean配置 --&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt; &lt;property name=&quot;maxUploadSize&quot; value=&quot;102400&quot; /&gt; &lt;property name=&quot;maxInMemorySize&quot; value=&quot;514&quot; /&gt; &lt;property name=&quot;defaultEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;!--&lt;property name=&quot;uploadTempDir&quot; value=&quot;upload/temp&quot; /&gt;--&gt; &lt;/bean&gt;&lt;/beans&gt; 2.spring mvc注解2.1 @RequeseMapping(value=”path”) ​ 表示访问该action的路径名，可以注解类和类方法，类上的注解和方法上的注解拼接起来可以访问该方法。 1234567@RequestMapping(value=&quot;user&quot;)public class User&#123; @RequestMapping(value=&quot;login&quot;) public String login()&#123; return null; &#125;&#125; ​ 以上代码中127.0.0.1:8080//user/login地址可以访问user.login()方法，并返回一个视图名称。 2.2 @RequestParam ​ 用于接收浏览器发送到服务器的请求参数 1234@RequestMapping(value=&quot;login&quot;)public String login(@RequestParam String userName, @RequestParam(value=&quot;password&quot;) String password)&#123; return null;&#125; ​ 以上代码中，login()可以接收两个请求参数，其中第一个@RequestParam因为没有value值，所以请求参数的名字必须等于userName，否则会出错。 ​ 除了以上的接收参数的方法，Spring mvc可以将需要接收的请求参数直接封装在一个类中。 12345public class LoginInfo&#123; private String userName; private String password; ...setter and getter...&#125; 1234@RequestMapping(value=&quot;login&quot;)public String login(LoginInfo logIn)&#123; return null;&#125; ​ 当然，LoginInfo中的userName和password需要和浏览器传过来的参数名称相同。 2.3 @ResponseBody ​ 将内容或对象作为HTTP响应正文返回（不返回视图，只返回内容，适合做即时校验） 12345@RequestMapping(value=&quot;login&quot;)@ResponseBodypublic void login()&#123; return &quot;hello world!&quot;;&#125; ​ 直接在方法上面加上该注解，当访问127.0.0.1:8080//user/login时，页面上显示hello world!. 3.对于Spring 中自定义servlet时获取IOC容器中的实例​ 在Spring中如果你自定义一个自动加载的servlet，那么当你在该servlet中获取IOC容器中的实例时，是取不到的，会得到一个null值，程序会报空指针异常。 解决方案： ​ 在servlet中加载Spring配置文件，通过getBean()方法获取实例，代码 123ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);deviceService = context.getBean(DeviceService.class); 4.表单上传spring mvc 中的表单上传需要使用到MultipartFile这个类 1.表单上需要加上enctype=”multipart/form-data”，打开文件上传功能 2.通过@RequestPart注解获取文件对象 1234567@RequestMapping(value=&quot;/add&quot;)public String method(@RequestPart(value=&quot;file01&quot;)MultipartFile file)&#123; file.getInputStream(); file.getSize(); ... ...&#125; 5.拦截器Spring中定义一个拦截器，用于登录拦截。 第一步：定义一个拦截器。spring 中的拦截器需要继承HandlerInterceptorAdapter，它实现了java中给出的拦截器接口（具体待补充）。 123456789101112131415161718192021222324252627282930313233343536373839404142public class UserLoginInteceptorByString extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if(&quot;GET&quot;.equalsIgnoreCase(request.getMethod()))&#123; // &#125; System.out.println(&quot;preHandle...&quot;); String requestUri = request.getRequestURI(); String contextPath = request.getContextPath(); String url = requestUri.substring(contextPath.length()); System.out.println(&quot;requestUri = &quot; + requestUri); System.out.println(&quot;contextPath = &quot; + contextPath); System.out.println(&quot;url = &quot; + url); String username = (String) request.getParameter(&quot;username&quot;); if(username==null || username.equals(&quot;&quot;))&#123; //未登录，跳转到登录界面// request.getRequestDispatcher(&quot;/WEB-INF/jsps/login.jsp&quot;).forward(request,response); System.out.println(&quot;You have not login in, turn to login page...&quot;); return false; &#125; else&#123; System.out.println(&quot;You are login in, turn to the page you want...&quot;); return true; &#125;// return super.preHandle(request, response, handler); &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(&quot;postHandle...&quot;); if (modelAndView != null) &#123; Map&lt;String,String&gt; map = new HashMap&lt;&gt;();// modelAndView.addAllObjects(map); &#125; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(&quot;afterCompletion...&quot;); &#125;&#125; 第二步：在Spring mvc的配置文件中进行拦截器的注册配置 1234567891011121314151617181920&lt;mvc:interceptors&gt; &amp;lt;!&amp;ndash; 国际化操作拦截器 如果采用基于（请求/Session/Cookie）则必需配置 &amp;ndash;&amp;gt; &lt;bean class=&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot; /&gt; &amp;lt;!&amp;ndash;如果不定义 mvc:mapping path 将拦截所有的URL请求&amp;ndash;&amp;gt; &lt;mvc:interceptor&gt; &lt;!-- 拦截的url，这里表示拦截所有请求 --&gt; &lt;mvc:mapping path=&quot;/**/*&quot;/&gt; &lt;!-- 排除静态资源，不配置的话，拦截器会拦截静态资源 --&gt; &lt;mvc:exclude-mapping path=&quot;/**/fonts/*&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.css&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.js&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.png&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.gif&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.jpg&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*.jpeg&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/**/*login*&quot;/&gt; &lt;bean class=&quot;com.yejunfeng.interceptor.UserLoginInteceptorByString&quot;&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 当访问localhost://user/toLogin时，控制台输出： ​ preHandle…​ requestUri = /stu/toView​ contextPath =​ url = /stu/toView​ You have not login in, turn to login page… 当访问localhost://user/toLogin?username=yyy时，控制台输出： ​ preHandle… ​ requestUri = /stu/toView ​ contextPath = ​ url = /stu/toView ​ You are login in, turn to the page you want… ​ postHandle… 6.关于Spring mvc的线程安全问题对于SpringMVC和Struts2，我们知道SpringMVC是基于方法的拦截，而Struts2是基于类的拦截。 struts2每次处理一个请求，它会产生一个action的实例，所以它是不会产生线程安全问题的。 Spring的Controller默认是singleton的，这表示所有关于这个Action的请求都使用一个实例去进行处理，这样的话就容易产生线程问题。 我的解决方案： 1.在spring配置文件Controller中声明 scope=”prototype”或者使用@Scope(“prototype”)注解，每次都创建新的controller 2.使用ThreadLocal变量 3.避免在Controller中使用实例变量","tags":[{"name":"笔记","slug":"笔记","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"spring","slug":"spring","permalink":"http://houghmzqqq.gihub.io/tags/spring/"},{"name":"框架","slug":"框架","permalink":"http://houghmzqqq.gihub.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"Spring boot 笔记","date":"2017-09-09T01:32:32.000Z","path":"2017/09/09/Spring-boot-笔记/","text":"1 配置1.1 配置文件配置文件可以是.properties或.yml后缀的文件，两者的区别： 可以看出.yml比.properties文件的配置要简便 1.2 属性配置1.2.1 注解@Value(${&lt;配置文件中的属性名&gt;})：可以将配置文件中的一个属性取出，并赋给当前类的一个属性 @ConfigurationProperties(prefix=”&lt;前缀&gt;”)：将配置文件中的值赋给一个类 配置文件： 实体类： 这里将配置文件中的girl的值赋给GirlProperties 1.3 多个配置文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经常会遇到这种情况，开发时的配置文件和运行时的配置文件要求不相同，这时候就需要频繁修改配置文件。spring中可以编写多个配置文件，可以按照需求转换所需的配置文件 创建三个配置文件： application.yml: application-dev.yml: application-prod.yml: 使用哪一个配置文件取决于application.yml中spring.profiles.active的定义. 当spring.profiles.active=prod时使用application-prod.yml为配置文件当spring.profiles.active=dev时使用application-dev.yml 2 Controller注解@Controller：定义一个Controller组件，返回一个模板 @RestController：定义一个Controller组件，返回String，json等 @ResquestMapping：为该类或方法定义url @PathVariable：获取url中的数据 @RequestParam：获取请求参数 @GetMapping：组合注解，相当于RequestMapping(value=&quot;&quot;,method=&quot;GET&quot;) 2.1 @PathVariable用法： 可以从url中提取数据，并赋给方法中的属性。 2.2 @RequestParam用法： 此处的required表示是否必须，defaultValue默认值 获取url中的请求参数id 3 Spring-Data-Jpajpa是定义了一系列对象持久化的标准。目前实现这一规范的数据库产品有hibernate、TopLink、JDO等。使用jpa需要导入jar包。它可以简化hibernate的配置和使用。 3.1 jpa的使用1).在application.yml配置文件中配置数据库信息 2).创建实体类 3).创建一个接口，继承JpaRepository 4).使用jpa连接数据库 4 表单验证使用@Valid注解 5 使用aop需要导入spring-boot相应的aop包，新建一个切面类，如下： 其中 @Pointcut(&quot;execution(public * com.myboot.gril..controller.GirlCotroller.*(..))&quot;) public void log()&#123;&#125; 表示定义一个公用的方法。避免在@Before和@After中重复定义相同的切入点。 5.1 在aop里实现日志 spring已有封装好的日志模块，在切面类中实例化org.slf4j.Logger类就可以通过里面的info方法将信息放入日志中 6 统一异常处理6.1 统一输出的数据格式在controller返回数据时，返回的单个实例和多个实例的集合格式是有区别的，这不利于视图层对数据的处理。所以我们可以对输出的数据制定一个统一的格式。方法是新建一个Result类对输出的结果进行封装： 工具类，方便封装减少重复代码： 结果: 6.2 异常管理1)、首先自定义一个异常类 2)、创建一个异常信息收集类 3)、处理异常时使用自定义的异常类进行处理 6.3 提示信息由枚举类管理在大型项目中，提示信息是非常繁多的，如果不统一进行管理的话很容易出现混乱。所以在这里新建一个enum对提示信息进行管理。 enum: 使用时通过枚举类型取出所需要的信息即可： 7 单元测试7.1 controller测试 使用到MockMvc类，可以通过url地址对controller层进行单元测试。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"spring","slug":"spring","permalink":"http://houghmzqqq.gihub.io/tags/spring/"},{"name":"框架","slug":"框架","permalink":"http://houghmzqqq.gihub.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"LeetCode:79.Word Search","date":"2017-09-02T08:19:39.000Z","path":"2017/09/02/LeetCode-79-Word-Search/","text":"思路原题：Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. 大意：给定一个2D的字母表和一个单词，从该表中找出该单词。规则–单词可以由相邻相邻单元格的字母构成，相邻的单元格是水平或垂直相邻的单元格。同一个字母单元不能超过一次使用。 分析：对每一个点都进行深度遍历，遍历过程中发生：1.数组超出界限；2.指定位置的单词字母与该点字母不相等；3.给点已经遍历过。要进行剪枝。 代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public boolean exist(char[][] board, String word) &#123; char[] cWord &#x3D; word.toCharArray(); boolean[][] isUsed &#x3D; new boolean[board.length][board[0].length]; Queue&lt;Character&gt; queue &#x3D; new LinkedList(); for(int i&#x3D;0;i&lt;board.length;i++)&#123; for(int j&#x3D;0;j&lt;board[0].length;j++)&#123; &#x2F;&#x2F; if(cWord[0]&#x3D;&#x3D;board[i][j])&#123; if(judge(isUsed,board,cWord,0,i,j)) return true; &#x2F;&#x2F; &#125; &#125; &#125; return false; &#125; public boolean judge(boolean[][] isUsed,char[][] board,char[] cw,int w,int x,int y)&#123; int bLen &#x3D; board.length; int bHig &#x3D; board[0].length; &#x2F;&#x2F; 坐标可以向上下左右移动 int[] bh &#x3D; &#123;1,0,-1,0&#125;; int[] bw &#x3D; &#123;0,1,0,-1&#125;; if(w&#x3D;&#x3D;cw.length) return true; &#x2F;&#x2F;剪枝 if(x&lt;0 || y&lt;0 || x&gt;&#x3D;bLen || y&gt;&#x3D;bHig || cw[w]!&#x3D;board[x][y] || isUsed[x][y]&#x3D;&#x3D;true) return false; isUsed[x][y] &#x3D; true; for(int i&#x3D;0;i&lt;4;i++)&#123; if(judge(isUsed,board,cw,w+1,x+bh[i],y+bw[i])) return true; &#125; isUsed[x][y] &#x3D; false; return false; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-%E9%A2%91%E5%BA%A65/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"},{"name":"连通图","slug":"连通图","permalink":"http://houghmzqqq.gihub.io/tags/%E8%BF%9E%E9%80%9A%E5%9B%BE/"},{"name":"深度优先搜素DFS","slug":"深度优先搜素DFS","permalink":"http://houghmzqqq.gihub.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A0DFS/"}]},{"title":"LeetCode:77.Combinations","date":"2017-09-02T08:01:58.000Z","path":"2017/09/02/LeetCode-77-Combinations/","text":"思路原题：Given two integers n and k, return all possible combinations of k numbers out of 1 … n. For example,If n = 4 and k = 2, a solution is: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 大意：给定两个数字n和k，返回1…n中k个数字的所有排列组合结果。 分析：通过递归创建分支：1.当长度为k时，加入结果集；2.当剩下的元素与当前的元素相加小于k时，跳出该分支。（与LeetCode49题类似）(78题也与本题相似) 代码123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;Integer&gt; midList &#x3D; new ArrayList(); List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList(); group(midList,res,n,k,1); return res; &#125; public void group(List&lt;Integer&gt; midList,List&lt;List&lt;Integer&gt;&gt; res,int n,int k,int x)&#123; &#x2F;&#x2F;List&lt;Integer&gt; ns &#x3D; new ArrayList(nList); List&lt;Integer&gt; l1 &#x3D; new ArrayList(midList); &#x2F;&#x2F;长度等于k是，加入结果集 if(l1.size()&#x3D;&#x3D;k)&#123; res.add(l1); return ; &#125; if(l1.size()+n-x+1&lt;k)&#123; return ; &#125; for(int i&#x3D;x;i&lt;&#x3D;n;i++)&#123; &#x2F;&#x2F;创建分之后回溯 l1 &#x3D; new ArrayList(midList); &#x2F;&#x2F;创建分支 l1.add(i); group(l1,res,n,k,i+1); &#125; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-%E9%A2%91%E5%BA%A65/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"},{"name":"递归","slug":"递归","permalink":"http://houghmzqqq.gihub.io/tags/%E9%80%92%E5%BD%92/"},{"name":"排列组合","slug":"排列组合","permalink":"http://houghmzqqq.gihub.io/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"}]},{"title":"LeetCode:67.Add Binary","date":"2017-09-02T07:52:37.000Z","path":"2017/09/02/LeetCode-67-Add-Binary/","text":"思路原题：Given two binary strings, return their sum (also a binary string). 大意：给定一个二进制字符串，输出它们的和，结果也是一个二进制。 分析：这道题中，将两个字符串拆分成字符数组，逐位进行相加即可，要注意进位标志。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution &#123; public String addBinary(String a, String b) &#123; int c &#x3D; 0; char[] ac &#x3D; a.toCharArray(); char[] bc &#x3D; b.toCharArray(); int aLen &#x3D; ac.length-1; int bLen &#x3D; bc.length-1; &#x2F;&#x2F;存放结果，由于从低位开始运算，输出时需要将结果倒转 StringBuffer buffer &#x3D; new StringBuffer(); &#x2F;&#x2F;进行二进制加法运算 while(aLen&gt;&#x3D;0 &amp;&amp; bLen&gt;&#x3D;0)&#123; if((ac[aLen]&#x3D;&#x3D;&#39;1&#39; &amp;&amp; bc[bLen]&#x3D;&#x3D;&#39;0&#39;) || (ac[aLen]&#x3D;&#x3D;&#39;0&#39; &amp;&amp; bc[bLen]&#x3D;&#x3D;&#39;1&#39;))&#123; if(c&#x3D;&#x3D;1) &#123; buffer.append(&quot;0&quot;); c &#x3D; 1; &#125;else&#123; buffer.append(&quot;1&quot;); &#125; &#125; else if((ac[aLen]&#x3D;&#x3D;&#39;0&#39; &amp;&amp; bc[bLen]&#x3D;&#x3D;&#39;0&#39;))&#123; if(c&#x3D;&#x3D;1)&#123; buffer.append(&quot;1&quot;); c &#x3D; 0; &#125;else&#123; buffer.append(&quot;0&quot;); &#125; &#125; else if(ac[aLen]&#x3D;&#x3D;&#39;1&#39; &amp;&amp; bc[bLen]&#x3D;&#x3D;&#39;1&#39;)&#123; if(c&#x3D;&#x3D;1)&#123; buffer.append(&quot;1&quot;); &#125;else&#123; buffer.append(&quot;0&quot;); &#125; c &#x3D; 1; &#125; aLen--; bLen--; &#125; &#x2F;&#x2F;其中一个或两个数都相加完，处理剩余的进位标志 if(aLen&lt;0 || bLen&lt;0)&#123; int max &#x3D; Math.max(aLen,bLen); char[] temp; if(bLen&lt;0) temp &#x3D; ac; else temp &#x3D; bc; for(int i&#x3D;max;i&gt;&#x3D;0;i--)&#123; if(c&#x3D;&#x3D;1 &amp;&amp; temp[i]&#x3D;&#x3D;&#39;0&#39;)&#123; buffer.append(&quot;1&quot;); c &#x3D; 0; &#125; else if(c&#x3D;&#x3D;1 &amp;&amp; temp[i]&#x3D;&#x3D;&#39;1&#39;)&#123; buffer.append(&quot;0&quot;); c &#x3D; 1; &#125; else if(c&#x3D;&#x3D;0)&#123; buffer.append(temp[i]); &#125; &#125; &#125; if(c&#x3D;&#x3D;1)&#123; buffer.append(&quot;1&quot;); &#125; return buffer.reverse().toString(); &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-%E9%A2%91%E5%BA%A65/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Hard","slug":"Hard","permalink":"http://houghmzqqq.gihub.io/tags/Hard/"}]},{"title":"LeetCode:49.Group Anagrams","date":"2017-09-01T15:10:31.000Z","path":"2017/09/01/LeetCode-49-Group-Anagrams/","text":"思路原题：Given an array of strings, group anagrams together. 大意：给定一个String数组，将拥有相同字母的字符串归为一类。 分析：将每个单词按照a~z顺序排序，将排序后相同的字符串放入同一个集合中。 代码12345678910111213141516171819202122232425262728293031class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; List&lt;List&lt;String&gt;&gt; res &#x3D; new ArrayList(); &#x2F;&#x2F;存放排序后的字符串，和原字符串 Map&lt;String,List&lt;String&gt;&gt; map &#x3D; new HashMap(); for(String str : strs)&#123; &#x2F;&#x2F;对每一个字符串进行重组 char[] c &#x3D; str.toCharArray(); Arrays.sort(c); String tempStr &#x3D; String.valueOf(c); &#x2F;&#x2F;重组后，若未出现过，创建新的集合存放原字符串； &#x2F;&#x2F;若之前出现过，取出与该字符串相对应的集合，将原字符串放入。 if(map.get(tempStr)&#x3D;&#x3D;null)&#123; List&lt;String&gt; l1 &#x3D; new ArrayList(); l1.add(str); map.put(tempStr,l1); &#125;else&#123; map.get(tempStr).add(str); &#125; &#125; for(Map.Entry&lt;String,List&lt;String&gt;&gt; entry : map.entrySet())&#123; res.add(entry.getValue()); &#125; return res; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-%E9%A2%91%E5%BA%A65/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"},{"name":"递归","slug":"递归","permalink":"http://houghmzqqq.gihub.io/tags/%E9%80%92%E5%BD%92/"},{"name":"排列组合","slug":"排列组合","permalink":"http://houghmzqqq.gihub.io/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"}]},{"title":"LeetCode:46.Permutations","date":"2017-09-01T14:58:10.000Z","path":"2017/09/01/LeetCode-46-Permutations/","text":"思路原题：Given a collection of distinct numbers, return all possible permutations. 大意：给定一个数字集合，求所有排列组合的集合 分析：以集合[1,2,3,4]为例，分别以1,2,3,4,为开头建立分支，在1为开头的分支中，分别以2,3,4建立分支，以此类推。使用递归的方式创建分支。 代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res &#x3D; new ArrayList(); List&lt;Integer&gt; firstList &#x3D; new ArrayList(); List&lt;Integer&gt; midList &#x3D; new ArrayList(); for(int num : nums)&#123; firstList.add(num); &#125; getList(firstList,midList,res); return res; &#125; &#x2F;&#x2F;递归方法 public void getList(List&lt;Integer&gt; l1,List&lt;Integer&gt; l2,List&lt;List&lt;Integer&gt;&gt; res)&#123; List&lt;Integer&gt; midList &#x3D; new ArrayList(l2); List&lt;Integer&gt; list &#x3D; new ArrayList(); if(l1.size()!&#x3D;0 &amp;&amp; l1!&#x3D;null)&#123; for(int i&#x3D;0;i&lt;l1.size();i++)&#123; &#x2F;&#x2F;没创建一个分支，进行回溯，保证list和midList中个数不变 list &#x3D; new ArrayList(l1); midList &#x3D; new ArrayList(l2); midList.add(list.get(i)); list.remove(i); &#x2F;&#x2F;创建分支 getList(list,midList,res); &#125; &#125; &#x2F;&#x2F;返回条件 if(l1.size()&#x3D;&#x3D;0 || l1&#x3D;&#x3D;null) res.add(midList); &#125; &#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-%E9%A2%91%E5%BA%A65/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"}]},{"title":"LeetCode:27.Remove Element","date":"2017-09-01T13:25:51.000Z","path":"2017/09/01/LeetCode-27-Remove-Element/","text":"思路原题：Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. 大意：给定一个数组和一个常数，删除该数组中所有和该常数相等的值，输出剩余的值。结果返回一个常数，表示结果数组的长度。 分析：循环遍历数组，当数组中的值等于val时，将该元素和从尾部算起不等于val的元素互换；当头部元素和尾部元素相交，跳出该次循环。 代码1234567891011121314151617181920212223242526272829303132class Solution &#123; public int removeElement(int[] nums, int val) &#123; &#x2F;&#x2F;记录尾部开始计算，等于val的数组元素个数 int hasChange &#x3D; 0; int len &#x3D; nums.length; for(int i&#x3D;0;i&lt;len;i++)&#123; &#x2F;&#x2F;剩下的可能需要处理的元素 int chanLen &#x3D; len-hasChange-1; if(i&gt;chanLen) break; if(nums[i]&#x3D;&#x3D;val)&#123; for(int j&#x3D;chanLen;j&gt;&#x3D;0;j--)&#123; &#x2F;&#x2F;num[j]在num[i]前面，结束循环 if(i&gt;j) break; if(nums[j]!&#x3D;val)&#123; int temp &#x3D; nums[i]; nums[i] &#x3D; nums[j]; nums[j] &#x3D; temp; hasChange++; break; &#125; hasChange++; &#125; &#125; &#125; return len-hasChange; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-%E9%A2%91%E5%BA%A65/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Easy","slug":"Easy","permalink":"http://houghmzqqq.gihub.io/tags/Easy/"}]},{"title":"LeetCode:24.Swap Nodes in Pairs","date":"2017-09-01T12:51:35.000Z","path":"2017/09/01/LeetCode-24-Swap-Nodes-in-Pairs/","text":"思路原题：Given a linked list, swap every two adjacent nodes and return its head.For example, Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 大意：给定一个链表，将相邻的两个节点互换。只能够使用恒定的物理空间，不能够改变节点的值，只能够改变节点本身。 分析：这道题中需要定义1个辅助变量root。 代码123456789101112131415161718192021222324252627282930&#x2F;** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;class Solution &#123; public ListNode swapPairs(ListNode head) &#123; ListNode root &#x3D; new ListNode(-1); root.next &#x3D; head; ListNode pre_head &#x3D; root; while(head !&#x3D; null &amp;&amp; head.next!&#x3D; null)&#123; ListNode Node1 &#x3D; head; ListNode Node2 &#x3D; head.next.next; root.next &#x3D; head.next; &#x2F;&#x2F;改变单数节点 root &#x3D; root.next; &#x2F;&#x2F;改变双数节点 root.next &#x3D; Node1; &#x2F;&#x2F;跳转到下一对要置换的节点 Node1.next &#x3D; Node2; root &#x3D; root.next; head &#x3D; Node2; &#125; return pre_head.next; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-%E9%A2%91%E5%BA%A65/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"}]},{"title":"LeetCode:23.Merge k Sorted Lists","date":"2017-08-21T07:23:24.000Z","path":"2017/08/21/LeetCode-23-Merge-k-Sorted-Lists/","text":"思路原题：Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 大意：合并k个已排序的链表并返回一个合并后的链表。注意时间复杂度。 解法一分析：最简单的方法是遍历每一个链表的当前节点，并取出最小的一个数加入result（结果链表）中，取出数字的链表当前节点后移。该方法的时间复杂度较高。 代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; ListNode head &#x3D; new ListNode(0); ListNode result &#x3D; head; &#x2F;&#x2F;链表数组转化为ArrayList,方便对链表数量进行增删 List&lt;ListNode&gt; nodeList &#x3D; new ArrayList(Arrays.asList(lists)); &#x2F;&#x2F;过滤空链表 for(int i&#x3D;0;i&lt;nodeList.size();i++)&#123; if(nodeList.get(i)&#x3D;&#x3D;null)&#123; nodeList.remove(i); i--; &#125; &#125; if(nodeList.size()&#x3D;&#x3D;1) return nodeList.get(0); while(nodeList.size()&gt;1)&#123; Map&lt;Integer,Integer&gt; map &#x3D; new HashMap(); int min &#x3D; nodeList.get(0).val; map.put(min,0); for(int i&#x3D;1;i&lt;nodeList.size();i++)&#123; if(nodeList.get(i).val&lt;min)&#123; min&#x3D;nodeList.get(i).val; map.put(min,i); &#125; &#125; result.next &#x3D; new ListNode(min); &#x2F;&#x2F;result.next.val &#x3D; min; result &#x3D; result.next; int index &#x3D; map.get(min); if(nodeList.get(index).next&#x3D;&#x3D;null) nodeList.remove(index); else nodeList.set(index,nodeList.get(index).next); if(nodeList.size()&#x3D;&#x3D;1)&#123; result.next &#x3D; nodeList.get(0); &#125; &#125; return head.next; &#125;&#125; 方法二：基于“二分”思想的归并排序分析：进行循环合并链表，对于k个链表，总节点数为n，每一次循环使链表的数量减少为(k+1)/2。在每次循环中：lists[0]与lists[(k+1)/2]合并，lists[1]与lists[(k+1)/2+1]合并，lists[2]与lists[(k+1)/2+2]合并，类推…… 代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; int len &#x3D; lists.length; if(lists&#x3D;&#x3D;null || len&#x3D;&#x3D;0) return null; if(len&#x3D;&#x3D;1) return lists[0]; &#x2F;&#x2F;进行归并排序 while(len&gt;1)&#123; int mid &#x3D; (len+1)&#x2F;2; for(int i&#x3D;0;i&lt;len&#x2F;2;i++)&#123; lists[i] &#x3D; merge(lists[i],lists[i+mid]); &#125; len &#x3D; mid; &#125; return lists[0]; &#125; &#x2F;&#x2F;对lists[i],lists[(k+1)&#x2F;2+i]进行合并 public ListNode merge(ListNode node01,ListNode node02)&#123; ListNode head &#x3D; new ListNode(0); ListNode result &#x3D; head; while(node01!&#x3D;null &amp;&amp; node02!&#x3D;null)&#123; if(node01.val&lt;&#x3D;node02.val)&#123; result.next &#x3D; node01; node01 &#x3D; node01.next; &#125; else&#123; result.next &#x3D; node02; node02 &#x3D; node02.next; &#125; result &#x3D; result.next; &#125; if(node01!&#x3D;null) result.next &#x3D; node01; else result.next &#x3D; node02; return head.next; &#125;&#125; 方法三：基于优先级队列的堆排序分析：使用Java __api__中的优先级队列（Priority Queue），将所有链表的当前节点offer进堆中，PriorityQueue会根据实现了Comparable接口的实现类中的compareTo方法，将符合条件的元素放在堆顶，我们将堆顶的元素逐个取出放入结果链表中即可。 代码： 1234567891011121314151617181920212223242526272829303132&#x2F;&#x2F;实现Comparable接口public class ListNode implements Comparable&lt;ListNode&gt;&#123; int val; ListNode next; ListNode(int x) &#123; val &#x3D; x; &#125; &#x2F;&#x2F;PriorityQueue根据该方法决定放在堆顶的元素 public int compareTo(ListNode l1)&#123; return val-l1.val; &#125;&#125;class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; ListNode head &#x3D; new ListNode(0); ListNode result &#x3D; head; Queue&lt;ListNode&gt; queue &#x3D; new PriorityQueue(Arrays.asList(lists)); if(lists&#x3D;&#x3D;null || lists.length&#x3D;&#x3D;0) return null; if(lists.length&#x3D;&#x3D;1) return lists[0]; while(queue.size()&gt;0)&#123; ListNode l1 &#x3D; queue.poll(); result.next &#x3D; l1; if(l1.next!&#x3D;null) queue.offer(l1.next); &#125; return head.next; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-%E9%A2%91%E5%BA%A65/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Hard","slug":"Hard","permalink":"http://houghmzqqq.gihub.io/tags/Hard/"}]},{"title":"数据库中视图的作用","date":"2017-08-14T12:19:49.000Z","path":"2017/08/14/数据库中视图的作用/","text":"视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。 1、 视图能简化用户操作视图机制使用户可以将注意力集中在所关心地数据上。如果这些数据不是直接来自基本表，则可以通过定义视图，使数据库看起来结构简单、清晰，并且可以简化用户的的数据查询操作。例如，那些定义了若干张表连接的视图，就将表与表之间的连接操作对用户隐藏起来了。换句话说，用户所作的只是对一个虚表的简单查询，而这个虚表是怎样得来的，用户无需了解。 2、 视图使用户能以多种角度看待同一数据视图机制能使不同的用户以不同的方式看待同一数据，当许多不同种类的用户共享同一个数据库时，这种灵活性是非常必要的。 3、 视图对重构数据库提供了一定程度的逻辑独立性数据的物理独立性是指用户的应用程序不依赖于数据库的物理结构。数据的逻辑独立性是指当数据库重构造时，如增加新的关系或对原有的关系增加新的字段，用户的应用程序不会受影响。层次数据库和网状数据库一般能较好地支持数据的物理独立性，而对于逻辑独立性则不能完全的支持。 在关系数据库中，数据库的重构造往往是不可避免的。重构数据库最常见的是将一个基本表“垂直”地分成多个基本表。例如：将学生关系Student（Sno，Sname，Ssex，Sage，Sdept）， 分为SX（Sno，Sname，Sage）和SY（Sno，Ssex，Sdept）两个关系。这时原表Student为SX表和SY表自然连接的结果。如果建立一个视图Student： 12345CREATE VIEW Student（Sno，Sname，Ssex，Sage，Sdept）ASSELECT SX.Sno，SX.Sname，SY.Ssex，SX.Sage，SY.SdeptFROM SX，SYWHERE SX.Sno&#x3D;SY.Sno； 这样尽管数据库的逻辑结构改变了（变为SX和SY两个表了），但应用程序不必修改，因为新建立的视图定义为用户原来的关系，使用户的外模式保持不变，用户的应用程序通过视图仍然能够查找数据。 当然，视图只能在一定程度上提供数据的逻辑独立，比如由于视图的更新是有条件的，因此应用程序中修改数据的语句可能仍会因为基本表构造的改变而改变。 4、视图能够对机密数据提供安全保护有了视图机制，就可以在设计数据库应用系统时，对不同的用户定义不同的视图，使机密数据不出现在不应该看到这些数据的用户视图上。这样视图机制就自动提供了对机密数据的安全保护功能。例如，Student表涉及全校15个院系学生数据，可以在其上定义15个视图，每个视图只包含一个院系的学生数据，并只允许每个院系的主任查询和修改本原系学生视图。 5、适当的利用视图可以更清晰地表达查询例如经常需要执行这样的查询“对每个学生找出他获得最高成绩的课程号”。可以先定义一个视图，求出每个同学获得的最高成绩： 12345CREATE VIEW VMGRADEASSELECT Sno，MAX(Grade) MgradeFROM SCGROUP BY Sno； 然后用如下的查询语句完成查询： SELECT SC.Sno，Cno FROM SC，VMGRADE WHERE SC.Sno = VMGRADE.Sno AND SC.Grade = VMGRADE.Mgrade；","tags":[{"name":"数据库","slug":"数据库","permalink":"http://houghmzqqq.gihub.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]},{"title":"LeetCode:127.Word Ladder","date":"2017-08-14T05:58:46.000Z","path":"2017/08/14/LeetCode-127-Word-Ladder/","text":"思路原题：Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: 1.Only one letter can be changed at a time. 2.Each transformed word must exist in the word list. Note that beginWord is not a transformed word. 大意：给出两个单词（开始单词和结束单词）和一个字典，查找字典中从开始单词转变为结束单词的最短路径，规则如下： 1.一次只能改变一个单词 2.每一个转换后的单词必须为字典中的单词。开始单词不算是转换单词（即结束单词算是）。 分析：查找最短路径，首先想到的是数据结构中连通图的广度搜索算法（BFS）。 定义一个栈midList，存放图中的灰色元素，白色元素为列表root，长度存放在Map中 代码1234567891011121314151617181920212223242526272829303132333435363738public class Solution &#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; Queue&lt;String&gt; midList &#x3D; new LinkedList(); midList.offer(beginWord); Map&lt;String,Integer&gt; map &#x3D; new HashMap(); map.put(beginWord,1); if(!wordList.contains(endWord)) return 0; if(wordList.contains(beginWord)) wordList.remove(beginWord); while(!midList.isEmpty())&#123; String top &#x3D; midList.poll(); StringBuilder builder; int level &#x3D; map.get(top); for(int i&#x3D;0;i&lt;top.length();i++)&#123; for(char c&#x3D;&#39;a&#39;;c&lt;&#x3D;&#39;z&#39;;c++)&#123; builder &#x3D; new StringBuilder(top); builder.setCharAt(i,c); String tepStr &#x3D; builder.toString(); if(top&#x3D;&#x3D;tepStr) continue; if(tepStr.equals(endWord)) return level+1; if(wordList.contains(tepStr))&#123; midList.offer(tepStr); wordList.remove(tepStr); map.put(tepStr,level+1); &#125; &#125; &#125; &#125; return 0; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-%E9%A2%91%E5%BA%A65/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"}]},{"title":"LeetCode:125.Valid Palindrome","date":"2017-08-14T05:44:45.000Z","path":"2017/08/14/LeetCode-125-Valid-Palindrome/","text":"思路原题：Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.For example, “A man, a plan, a canal: Panama” is a palindrome. “race a car” is not a palindrome. 大意：判断给定的一个字符串是不是有效的回文（忽略空格和除字母和数字意外的符号） 分析：从头部和尾部同时开始进行比较判断，遇到无效字符就跳过。 代码123456789101112131415161718192021222324252627public class Solution &#123; public boolean isPalindrome(String s) &#123; char[] chars &#x3D; s.toCharArray(); int t &#x3D; chars.length - 1; for(int h&#x3D;0;h&lt;chars.length;h++)&#123; if(!Character.isDigit(chars[h]) &amp;&amp; !Character.isLetter(chars[h])) continue; else if(!Character.isDigit(chars[t]) &amp;&amp; !Character.isLetter(chars[t]))&#123; t--; h--; continue; &#125; if(h&gt;&#x3D;t) return true; &#x2F;&#x2F;转换大小写 if(Character.isLetter(chars[h]) || Character.isLetter(chars[t]))&#123; chars[h] &#x3D; Character.toLowerCase(chars[h]); chars[t] &#x3D; Character.toLowerCase(chars[t]); &#125; if(chars[h]!&#x3D;chars[t]) return false; t--; &#125; return true; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-%E9%A2%91%E5%BA%A65/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Easy","slug":"Easy","permalink":"http://houghmzqqq.gihub.io/tags/Easy/"}]},{"title":"LeetCode:98.Validate Binary Search Tree","date":"2017-08-14T05:28:14.000Z","path":"2017/08/14/LeetCode-98-Validate-Binary-Search-Tree/","text":"思路原题：Given a binary tree, determine if it is a valid binary search tree (BST).Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. 大意：判断一个二叉树是不是二叉搜索树（BST）。二叉搜索树的定义： 左边的节点小于父节点 右边的节点大于父节点 子树也是二叉搜索树 分析：因为一个节点的子节点需要与该节点的父节点相比较，所以这里定义两个Integer类型的属性min和max，分别用作和左子节点和右子节点作比较。然后用一个递归 算法遍历一遍二叉树。 代码123456789101112131415161718192021222324252627&#x2F;** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val &#x3D; x; &#125; * &#125; *&#x2F;public class Solution &#123; Map&lt;TreeNode,TreeNode&gt; map &#x3D; new HashMap(); public boolean isValidBST(TreeNode root) &#123; return isValid(root,null,null); &#125; public boolean isValid(TreeNode root,Integer min,Integer max)&#123; if(root&#x3D;&#x3D;null) return true; if(min!&#x3D;null &amp;&amp; root.val&lt;&#x3D;min) return false; if(max!&#x3D;null &amp;&amp; root.val&gt;&#x3D;max) return false; return isValid(root.left,min,root.val) &amp;&amp; isValid(root.right,root.val,max); &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-%E9%A2%91%E5%BA%A65/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"}]},{"title":"LeetCode:73.Set Matrix Zeroes","date":"2017-08-13T04:37:41.000Z","path":"2017/08/13/LeetCode-73-Set-Matrix-Zeroes/","text":"思路原题：Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. 大意：给定一个mXn的矩阵，如果一个元素，将该元素所在的行和列的所有元素设置为0。 分析：将第一行和第一列作为工具，先判断第一行和第一列中是否存在0，做上标记；判断其他元素，如果一个元素为0，将该元素所在的第一行和第一列元素标记为0；最后再根据第一行和第一列对所有元素进行转换。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Solution &#123; public void setZeroes(int[][] matrix) &#123; int rowLength &#x3D; matrix.length; int colLength &#x3D; matrix[0].length; boolean isFirstRowHasZeo &#x3D; false; boolean isFirstColHasZeo &#x3D; false; for(int i&#x3D;0;i&lt;rowLength;i++)&#123; if(matrix[i][0]&#x3D;&#x3D;0)&#123; isFirstColHasZeo &#x3D; true; break; &#125; &#125; for(int i&#x3D;0;i&lt;colLength;i++)&#123; if(matrix[0][i]&#x3D;&#x3D;0)&#123; isFirstRowHasZeo &#x3D; true; break; &#125; &#125; for(int i&#x3D;1;i&lt;matrix.length;i++)&#123; for(int j&#x3D;1;j&lt;matrix[i].length;j++)&#123; if(matrix[i][j]&#x3D;&#x3D;0)&#123; matrix[i][0] &#x3D; 0; matrix[0][j] &#x3D; 0; &#125; &#125; &#125; for(int i&#x3D;1;i&lt;rowLength;i++)&#123; for(int j&#x3D;1;j&lt;colLength;j++)&#123; if(matrix[i][0]&#x3D;&#x3D;0 || matrix[0][j]&#x3D;&#x3D;0)&#123; matrix[i][j] &#x3D; 0; &#125; &#125; &#125; if(isFirstRowHasZeo)&#123; for(int i&#x3D;0;i&lt;colLength;i++)&#123; matrix[0][i] &#x3D; 0; &#125; &#125; if(isFirstColHasZeo)&#123; for(int i&#x3D;0;i&lt;rowLength;i++)&#123; matrix[i][0] &#x3D; 0; &#125; &#125; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-%E9%A2%91%E5%BA%A65/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"}]},{"title":"LeetCode:57.Insert Interval","date":"2017-08-07T13:09:56.000Z","path":"2017/08/07/LeetCode-57-Insert-Interval/","text":"思路原题：Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. 大意：给一个不重合的时间间隔的集合，插入一个新的间隔，进行排列并合并重合的间隔。该集合按照start升序排列。 分析：可以先将插入的数据按照start排列进入集合中，然后再逐个合并重合的间隔。在这里，合并时分为向上合并和向下合并。向上合并只有可能和插入后的上一个元素合并。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&#x2F;** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start &#x3D; 0; end &#x3D; 0; &#125; * Interval(int s, int e) &#123; start &#x3D; s; end &#x3D; e; &#125; * &#125; *&#x2F;public class Solution &#123; public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; Interval inta, intb; int index &#x3D; 0; &#x2F;&#x2F;记录插入元素的位置 &#x2F;&#x2F;将插入的间隔按start插入集合中 intervals.add(newInterval); for(int i&#x3D;intervals.size()-1;i&gt;0;i--)&#123; if(intervals.get(i).start&lt;intervals.get(i-1).start)&#123; Interval temp &#x3D; intervals.get(i); intervals.set(i,intervals.get(i-1)); intervals.set(i-1,temp); &#125;else&#123; index &#x3D; i; break; &#125; &#125; &#x2F;&#x2F;判断是否和上一个元素合并 if(index !&#x3D; 0)&#123; inta &#x3D; intervals.get(index-1); intb &#x3D; intervals.get(index); if(inta.start&lt;&#x3D;intb.start &amp;&amp; inta.end&gt;&#x3D;intb.start)&#123; intervals.get(index-1).end &#x3D; Math.max(inta.end,intb.end); intervals.remove(index); index--; &#125; &#125; &#x2F;&#x2F;循环判断是否和后面的元素合并 while(true)&#123; if(index+1&gt;&#x3D;intervals.size())&#123; break; &#125; inta &#x3D; intervals.get(index); intb &#x3D; intervals.get(index+1); if(inta.end&gt;&#x3D;intb.start)&#123; intervals.get(index).end &#x3D; Math.max(inta.end,intb.end); intervals.remove(index+1); &#125;else&#123; break; &#125; &#125; return intervals; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-%E9%A2%91%E5%BA%A65/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Hard","slug":"Hard","permalink":"http://houghmzqqq.gihub.io/tags/Hard/"}]},{"title":"LeetCode:56.Merge Intervals","date":"2017-08-07T07:30:58.000Z","path":"2017/08/07/LeetCode-56-Merge-Intervals/","text":"！（该答案在LeetCode官网上运行时出现超时错误，需要优化） 思路原题：Given a collection of intervals, merge all overlapping intervals. For example, Given [1,3],[2,6],[8,10],[15,18], return [1,6],[8,10],[15,18]. 大意：给一个含有多个时间间隔的集合，合并所有重合的部分。 分析：给出多个时间间隔，它们两两之间存在以下两种种可能性： 1.两个间隔不相交，如[1,2]和[3,4] 4.两个间隔相交，如[1,3]和[2,4] 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */public class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; int count = 0; List&lt;Interval&gt; result = new ArrayList(); List&lt;Integer&gt; temps = new ArrayList(); //先按照start进行升序排序 for(int i=0;i&lt;intervals.size()-1;i++)&#123; for(int j=i+1;j&lt;intervals.size();j++)&#123; if(intervals.get(i).start&gt;intervals.get(j).start)&#123; Interval flag = intervals.get(i); intervals.set(i,intervals.get(j)); intervals.set(j,flag); &#125; &#125; &#125; for(int i=0;i&lt;intervals.size();i++)&#123; Interval inter01 = intervals.get(i); //判断当前元素之前是否已经被合并 boolean ifJump = false; for(Integer temp : temps)&#123; if(i==temp)&#123; ifJump = true; &#125; &#125; if(ifJump)&#123; continue; &#125; for(int j=i+1;j&lt;intervals.size();j++)&#123; Interval inter02 = intervals.get(j); //第一种情况，两个范围不相交 if(inter01.end&lt;inter02.start || inter01.start&gt;inter02.end)&#123; continue; &#125; //第二种情况，两个范围存在包含关系 else if((inter01.start&lt;inter02.start &amp;&amp; inter01.end&gt;inter02.end) || (inter01.start&gt;inter02.start &amp;&amp; inter01.end&lt;inter02.end))&#123; if(inter01.start&gt;inter02.start &amp;&amp; inter01.end&lt;inter02.end)&#123; inter01.start = inter02.start; inter01.end = inter02.end; &#125; temps.add(j); &#125; //第三种情况，有元素相等 else if(inter01.start==inter02.start || inter01.end==inter02.end)&#123; if(inter01.start&gt;inter02.start)&#123; inter01.start = inter02.start; inter01.end = inter02.end; &#125;else if(inter01.end&lt;inter02.end)&#123; inter01.start = inter02.start; inter01.end = inter02.end; &#125; temps.add(j); &#125; //第四种情况，两个范围相交 else if((inter01.start&lt;inter02.start &amp;&amp; inter01.end&lt;inter02.end) || (inter01.start&gt;inter02.start &amp;&amp; inter01.end&gt;inter02.end))&#123; if(inter01.start&lt;inter02.start &amp;&amp; inter01.end&lt;inter02.end)&#123; inter01.end = inter02.end; &#125;else&#123; inter01.start = inter02.start; &#125; temps.add(j); &#125; &#125; //过滤相等的结果 if(result.size()==0)&#123; result.add(inter01); &#125;else if(result.get(count).start==inter01.start &amp;&amp; result.get(count).end==inter01.end)&#123; &#125;else&#123; result.add(inter01); count++; &#125; &#125; return result; &#125;&#125; 优化分析：先根据start进行排序，然后进行合并，合并条件a.start &lt;= b.start &lt;= a.end 代码（优）123456789101112131415161718192021222324252627282930313233/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */public class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; //根据interval的start排序 Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare(Interval o1, Interval o2) &#123; return o1.start - o2.start; &#125; &#125;); for(int i=0;i&lt;intervals.size()-1;i++)&#123; Interval inta = intervals.get(i); Interval intb = intervals.get(i+1); if(inta.start&lt;=intb.start &amp;&amp; inta.end&gt;=intb.start)&#123; intervals.get(i).end = Math.max(inta.end,intb.end); intervals.remove(i+1); i--; &#125; &#125; return intervals; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-%E9%A2%91%E5%BA%A65/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"}]},{"title":"LeetCode:70.Climbing Stairs","date":"2017-07-28T12:00:07.000Z","path":"2017/07/28/LeetCode-70-Climbing-Stairs/","text":"思路原题：You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 大意：你去爬一座山，山脚到山顶有n级台阶。没一次你可以爬一或两级台阶。计算到达山顶有几种走法。 分析：假设有n级台阶，有s种走法，那么当n=1,s=1;n=2,s=2;n=3,s=3;n=4,s=5;n=5,s=8;很明显，这是一个裴波那切数列，可以使用递归的方式进行计算，公式为f(n)=f(n-2)+f(n-1). 代码12345678910public class Solution &#123; public int climbStairs(int n) &#123; if(n&#x3D;&#x3D;1 || n&#x3D;&#x3D;2)&#123; return n; &#125; else&#123; return climbStairs(n-2)+climbStairs(n-1); &#125; &#125;&#125; 另一种解法分析：递归是从目标值算到基础值，可以反过来，通过迭代的方式从基础值算到目标值。 代码123456789101112131415public class Solution &#123; public int climbStairs(int n) &#123; if(n&#x3D;&#x3D;1 || n&#x3D;&#x3D;2)&#123; return n; &#125; int n1 &#x3D; 1; int n2 &#x3D; 2; for(int i&#x3D;3;i&lt;&#x3D;n;i++)&#123; int temp &#x3D; n1+n2; n1 &#x3D; n2; n2 &#x3D; temp; &#125; return n2; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-%E9%A2%91%E5%BA%A65/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Easy","slug":"Easy","permalink":"http://houghmzqqq.gihub.io/tags/Easy/"}]},{"title":"spring学习笔记","date":"2017-07-26T12:53:00.000Z","path":"2017/07/26/spring学习笔记/","text":"1.IOC(控制反转)__转移控制权——由外部容器进行对象的创建，并进行对象控制权的管理__。应用程序本身不进行对象的创建，有外部容器完成创建对象和管理，当应用程序需要使用对象是，向容器进行申请。 DI(依赖注入)——是IOC的一中实现方法，通过容器将程序所要依赖的对象注入。一个例子： 房间中介——–IOC 找中介———-找IOC容器 租房子———-IOC返回对象 入住————程序使用对象 2.Spring注入方式2.1设值注入通过setter方法注入的方式 1234567public class MyTest&#123; private Bean bean; &#x2F;&#x2F;通过setter方法注入 public void setBean(Bean bean)&#123; this.bean &#x3D; bean; &#125;&#125; 2.2构造器注入通过在构造器中声明变量进行注入 1234567public class MyTest&#123; private Bean bean; &#x2F;&#x2F;通过构造方法注入 public MyTest(Bean bean)&#123; this.bean &#x3D; bean; &#125;&#125; 3.Bean作用域 singleton:单例，一个IOC容器中只存在一个 prototype:每次请求（每次使用）创建新的实例，destroy方法不生效 request:每次http请求创建一个实例且仅在当前request内有效 session:与上类似，每次http请求创建，当前session中有效 global session:基于portlet的web中有效 生命周期 配置文件中定义，IOC容器初始化，使用，IOC容器销毁 Aware spring提供一些以Aware结尾的接口，实现这些接口的Bean可以使用部分资源 3.1Bean的装配 通过xml文件进行显示配置 在Java中进行显示配置 隐式的Bean发现机制和自动装配 自动装配：在配置文件的beans标签中加入default autowire=“no/byName/byType/constructor”属性（作用是，当在一个bean中调用另外一个bean时，不需要在配置文件中标明） Resource和ResourceLoder ApplicationContext默认实现了Resource接口，可以通过ApplicationContext获取Resource Resource resource = ctx.getResource(); 加载资源文件的接口 3.2Bean的注解 @Component：通用的注解，可用于所有Bean @Repository：有针对性的Bean注解，Dao层 @Service：Service层 @Controller：Controller层 @Scope：类级别的注解，定义该Bean的作用域，可自定义。 3.3类的自动检测和Bean的注册 自动检测需要在配置文件中设置，使用&lt;context:component-scan base-package=”org.example”/&gt;标签(其中base-package表示需要检测的包名称)和context:annotation-config/，因为前者（常用）包含后者的功能，所以使用前者后一般不使用后者; 3.4其他注解 @Autowired &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以在setter方法、成员变量和构造方法上进行注解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以注解BeanFactory、ApplicationContext、ResourceLoder等接口 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Autowired注解是由BeanPostProcessor处理的，所以不能对BeanPostProcessor、BeanFactoryPOSTProcessor等接口进行注解，必须在xml文件中声明 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于有多个实现类的接口，使用@Autowired注解List或Map可以自动将接口的实现类都装配进入List或Map中，其中Map&lt;String,Bean&gt;中的String为Bean的名称 @Qualifier（”BeanName”） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于有多个实现类的接口，使用@Autowired注解时，可以使用@Qualifier注解指定需要装配的实现类 3.5在Java中进行显示装配12345678@Configurationpublic class AppConfig&#123; @Bean（&quot;BeanName&quot;） public MyService myService()&#123; return new MyServiceImpl(); &#125;&#125;相当于配置文件中的\\&lt;bean&#x2F;\\&gt;标签 @Bean标签有InitMethod和destoryMethod属性，定义初始化和销毁方法 @Scope，一般与@Bean一起使用，设置Bean的作用域（单例或多例等） 4.AOP AOP即面向切面编程，通过__预编译方式__或__运行期动态代理__实现程序功能的统一维护的一种技术 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主要的应用模块是：日志记录，性能统计，安全控制，事物处理，异常处理等 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上图所示，一个系统中有产品、订单、用户等多个模块，每一个模块都需要使用事务管理，如果在每个模块中都编写事务管理的代码，工作量将会很大；使用AOP的思想，将事务管理的功能独立出来，当某个模块需要使用时，通过预编译或动态代理的方式，赋予它该功能。 4.1AOP配置aspect切面123456789&lt;aop:config&gt; &lt;aop:aspect id&#x3D;&quot;myAspect&quot; ref&#x3D;&quot;myBean&quot;&gt; ...（&lt;aop:ponitcut&#x2F;&gt;） &lt;&#x2F;aop:aspect&gt;&lt;&#x2F;aop:config&gt;&lt;bean id&#x3D;&quot;myBean&quot; class&#x3D;&quot;...&quot;&gt; ...&lt;&#x2F;bean&gt; 4.2配置pointcut切入点 等。。。。。。 补充：5.事务管理5.1编程式事务管理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。 5.2声明式事务管理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;声明式事务管理也有两种常用的方式，一种是基于tx和aop名字空间的xml配置文件，另一种就是基于@Transactional注解。显然基于注解的方式更简单易用，更清爽。 application.xml中配置声明式事务管理： 1234567891011121314151617181920212223242526&lt;!-- 配置Hibernate Session --&gt; &lt;bean id&#x3D;&quot;sessionFactory&quot; class&#x3D;&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;&gt; &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;hibernateProperties&quot;&gt; &lt;props&gt; &lt;prop key&#x3D;&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;&#x2F;prop&gt; &lt;prop key&#x3D;&quot;hibernate.show_sql&quot;&gt;true&lt;&#x2F;prop&gt; &lt;prop key&#x3D;&quot;hibernate.format_sql&quot;&gt;false&lt;&#x2F;prop&gt; &lt;prop key&#x3D;&quot;hibernate.cache.use_second_level_cache&quot;&gt;false&lt;&#x2F;prop&gt; &lt;prop key&#x3D;&quot;hibernate.cache.use_query_cache&quot;&gt;false&lt;&#x2F;prop&gt; &lt;prop key&#x3D;&quot;current_session_context_class&quot;&gt;thread&lt;&#x2F;prop&gt; &lt;prop key&#x3D;&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;&#x2F;prop&gt; &lt;prop key&#x3D;&quot;hibernate.current_session_context_class&quot;&gt;org.springframework.orm.hibernate4.SpringSessionContext&lt;&#x2F;prop&gt; &lt;prop key&#x3D;&quot;c3p0.min_size&quot;&gt;5&lt;&#x2F;prop&gt; &lt;prop key&#x3D;&quot;c3p0.max_size&quot;&gt;30&lt;&#x2F;prop&gt; &lt;prop key&#x3D;&quot;c3p0.time_out&quot;&gt;1800&lt;&#x2F;prop&gt; &lt;prop key&#x3D;&quot;c3p0.max_statement&quot;&gt;50&lt;&#x2F;prop&gt; &lt;&#x2F;props&gt; &lt;&#x2F;property&gt; &lt;!-- 实体类的包 --&gt; &lt;property name&#x3D;&quot;packagesToScan&quot;&gt; &lt;list&gt; &lt;value&gt;com.*.po&lt;&#x2F;value&gt; &lt;&#x2F;list&gt; &lt;&#x2F;property&gt; &lt;&#x2F;bean&gt; 1234&lt;!-- 配置事务管理器 --&gt;&lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.orm.hibernate4.HibernateTransactionManager&quot;&gt; &lt;property name&#x3D;&quot;sessionFactory&quot; ref&#x3D;&quot;sessionFactory&quot; &#x2F;&gt; &lt;&#x2F;bean&gt; 12345678910111213141516&lt;!-- 事务advice --&gt; &lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name&#x3D;&quot;get*&quot; read-only&#x3D;&quot;true&quot; propagation&#x3D;&quot;REQUIRED&quot; &#x2F;&gt; &lt;tx:method name&#x3D;&quot;list*&quot; read-only&#x3D;&quot;true&quot; propagation&#x3D;&quot;REQUIRED&quot; &#x2F;&gt; &lt;tx:method name&#x3D;&quot;find*&quot; read-only&#x3D;&quot;true&quot; propagation&#x3D;&quot;REQUIRED&quot; &#x2F;&gt; &lt;tx:method name&#x3D;&quot;*&quot; read-only&#x3D;&quot;false&quot; propagation&#x3D;&quot;REQUIRED&quot; rollback-for&#x3D;&quot;Exception&quot;&#x2F;&gt; &lt;&#x2F;tx:attributes&gt; &lt;&#x2F;tx:advice&gt; &lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot; proxy-target-class&#x3D;&quot;true&quot; &#x2F;&gt; &lt;!-- 配置切面 --&gt; &lt;aop:config proxy-target-class&#x3D;&quot;true&quot;&gt; &lt;aop:advisor pointcut&#x3D;&quot;execution(public * com.xyz.gym_management_sys.service.*Service.*(..))&quot; advice-ref&#x3D;&quot;txAdvice&quot; &#x2F;&gt; &lt;&#x2F;aop:config&gt;","tags":[{"name":"笔记","slug":"笔记","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"spring","slug":"spring","permalink":"http://houghmzqqq.gihub.io/tags/spring/"},{"name":"框架","slug":"框架","permalink":"http://houghmzqqq.gihub.io/tags/%E6%A1%86%E6%9E%B6/"}]},{"title":"LeetCode:20.Valid Parentheses","date":"2017-07-23T06:34:25.000Z","path":"2017/07/23/LeetCode-20-Valid-Parentheses/","text":"思路原题：Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not. 大意：给一个只包含’(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ , ‘]’等字符的字符串，判断该字符串中的所有括号是否有效。 分析：根据题意，可以判断出有效的括号 like_this”()”,”()[]”,”({})”，无效括号like_this”((“,”]]”,”([)]”,”()[“。 步骤： 1、排除明显错误的答案（字符数量为单数时） 2、遍历所有字符，遇到开括号(如”(“,”[“,”{“)时，放入list中 3、遇到闭括号，与list中的最后一个字符匹配 代码12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public boolean isValid(String s) &#123; char[] paren &#x3D; s.toCharArray(); List&lt;Character&gt; openParen &#x3D; new ArrayList(); &#x2F;&#x2F;存放开括号 &#x2F;&#x2F;排除明显错误的答案 if(paren.length%2 !&#x3D; 0) &#123; return false; &#125; for(Character p : paren)&#123; int type; if( p&#x3D;&#x3D;&#39;(&#39; || p&#x3D;&#x3D;&#39;[&#39; || p&#x3D;&#x3D;&#39;&#123;&#39; )&#123; openParen.add(p); &#125; if( p&#x3D;&#x3D;&#39;)&#39; || p&#x3D;&#x3D;&#39;]&#39; || p&#x3D;&#x3D;&#39;&#125;&#39; )&#123; if(openParen.size()&#x3D;&#x3D;0)&#123; return false; &#125; int lastIndex &#x3D; openParen.size()-1; if(!(openParen.get(lastIndex)&#x3D;&#x3D;&#39;(&#39; &amp;&amp; p&#x3D;&#x3D;&#39;)&#39; || openParen.get(lastIndex)&#x3D;&#x3D;&#39;[&#39; &amp;&amp; p&#x3D;&#x3D;&#39;]&#39; || openParen.get(lastIndex)&#x3D;&#x3D;&#39;&#123;&#39; &amp;&amp; p&#x3D;&#x3D;&#39;&#125;&#39;))&#123; return false; &#125;else&#123; openParen.remove(lastIndex); &#125; &#125; &#125; if(openParen.size()!&#x3D;0)&#123; return false; &#125; return true; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-%E9%A2%91%E5%BA%A65/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Easy","slug":"Easy","permalink":"http://houghmzqqq.gihub.io/tags/Easy/"}]},{"title":"LeetCode:15.3Sum","date":"2017-07-22T13:53:10.000Z","path":"2017/07/22/LeetCode-15-3Sum/","text":"思路原题：Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note: The solution set must not contain duplicate triplets. 大意：给一个包含n个整数的数组，找出所有符合a+b+c=0的元素数组。__提示__：a,b,c符合条件a&lt;=b&lt;=c，结果不能重复。 初次分析：题目要求结果要排序并且不能重复，所以可以先对数组进行排序，在通过三重for循环得出结果，因为需要查重，所以需要四重for循环。 步骤（1）： 1、对数组进行排序 2、三重循环遍历所有可能的元素 3、得到结果后，对比是否重复 4、结果放入List中 代码（1）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;Integer&gt; sum &#x3D; null; List&lt;List&lt;Integer&gt;&gt; sums &#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int i&#x3D;nums.length-1;i&gt;0;i--) &#123; for(int j&#x3D;0;j&lt;i;j++) &#123; if(nums[j+1]&lt;nums[j]) &#123; int temp; temp &#x3D; nums[j]; nums[j] &#x3D; nums[j+1]; nums[j+1] &#x3D; temp; &#125; &#125; &#125; for(int x&#x3D;0;x&lt;nums.length-2;x++) &#123; for(int y&#x3D;x+1;y&lt;nums.length-1;y++) &#123; for(int z&#x3D;y+1;z&lt;nums.length;z++) &#123; if(nums[x]+nums[y]+nums[z] &#x3D;&#x3D; 0) &#123; sum &#x3D; new ArrayList&lt;Integer&gt;(); boolean repeat &#x3D; false; sum.add(nums[x]); sum.add(nums[y]); sum.add(nums[z]); for(List&lt;Integer&gt; comp : sums) &#123; if(sum.get(0)&#x3D;&#x3D;comp.get(0) &amp;&amp; sum.get(1)&#x3D;&#x3D;comp.get(1) &amp;&amp; sum.get(2)&#x3D;&#x3D;comp.get(2)) &#123; repeat &#x3D; true; &#125; &#125; if(!repeat) &#123; sums.add(sum); &#125; &#125; &#125; &#125; &#125; return sums; &#125;&#125; 这个答案submit后出错，提示：Time Limit Exceeds(超时)。经分析，是因为套入多重的for循环，时间复杂度大，当数组的基数较大时，运行时间会超出限制。 修改解决方案：减少for循环的层数。通过查找资料了解到，可以借助map避免第三层循环。 步骤（2）： 1、对数组进行排序 2、定义一个map，以nums（给定数组）的值为 key ，以list（该值在数组中的index）为__value__。 3、遍历数组，排除明显不符合条件的结果，并得出符合条件的结果。 4、结果放入List中 代码（2）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;Integer&gt; sum &#x3D; null; List&lt;List&lt;Integer&gt;&gt; sums &#x3D; new ArrayList&lt;List&lt;Integer&gt;&gt;(); &#x2F;&#x2F;排序 for(int i&#x3D;nums.length-1;i&gt;0;i--) &#123; for(int j&#x3D;0;j&lt;i;j++) &#123; if(nums[j+1]&lt;nums[j]) &#123; int temp; temp &#x3D; nums[j]; nums[j] &#x3D; nums[j+1]; nums[j+1] &#x3D; temp; &#125; &#125; &#125; &#x2F;&#x2F;nums数组中的数字分组放入map中，并记录它们的index(改操作可以减少一重循环) Map&lt;Integer,List&lt;Integer&gt;&gt; map &#x3D; new HashMap(); for(int i&#x3D;0;i&lt;nums.length;i++) &#123; int num &#x3D; nums[i]; if(map.get(num)&#x3D;&#x3D;null) &#123; List&lt;Integer&gt; lastOnes &#x3D; new ArrayList(); lastOnes.add(i); map.put(num,lastOnes); &#125; else &#123; map.get(num).add(i); &#125; &#125; for(int y&#x3D;0;y&lt;nums.length-2;y++) &#123; &#x2F;&#x2F;因为已排序，当第一个数大于0时，不能满足a+b+c&#x3D;0 if(nums[y]&gt;0) &#123; break; &#125; &#x2F;&#x2F;nums[y]&#x3D;&#x3D;nums[y-1]说明num[y]之前已经进行过判断,跳过 if(y&gt;0 &amp;&amp; nums[y] &#x3D;&#x3D; nums[y-1]) &#123; continue; &#125; for(int z&#x3D;y+1;z&lt;nums.length-1;z++) &#123; &#x2F;&#x2F;与上同理 if(z&gt;y+1 &amp;&amp; nums[z]&#x3D;&#x3D;nums[z-1]) &#123; continue; &#125; &#x2F;&#x2F;计算数字c int finalNum &#x3D; -nums[y] -nums[z]; &#x2F;&#x2F;c为abc中最后一个数字，所以c &gt;&#x3D; b if(finalNum &lt; nums[z]) &#123; break; &#125; &#x2F;&#x2F;查找nums中值为finalNum的List，不存在则跳过 List&lt;Integer&gt; lastOnes &#x3D; map.get(finalNum); if(lastOnes &#x3D;&#x3D; null) &#123; continue; &#125; for(Integer lastOne : lastOnes) &#123; if(lastOne&gt;z) &#123; sum &#x3D; new ArrayList(); sum.add(nums[y]); sum.add(nums[z]); sum.add(nums[lastOne]); sums.add(sum); break; &#125; &#125; &#125; &#125; return sums; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-%E9%A2%91%E5%BA%A65/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"}]},{"title":"LeetCode:8.String to Integer (atoi)","date":"2017-07-19T09:20:19.000Z","path":"2017/07/19/LeetCode-8-String-to-Integer-atoi/","text":"思路原题：Implement atoi to convert a string to an integer. 大意：实现字符串转换成int，参考atoi函数 分析：要求实现atoi函数相似的功能，通过查找资料了解到atoi函数的作用—— 1.如果字符前面有空格，跳过。 2.第一个有效字符可以为‘+’或‘-’号。 3.转换过程中如果遇到非数字符号或空格，停止转换，输出当前已转换的数字需要注意int的溢出问题 步骤： 1、过滤前面的空格 2、判断正负 3、转换有效数字 4、判断是否溢出。为了防止溢出现象，本人使用Long类型来暂时存储数字，由于long也有边界值会溢出，所以添加一个length变量来记录数字的长度 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class Solution &#123; public int myAtoi(String str) &#123; Long s &#x3D; 0l; int length &#x3D; 0; char[] strChar &#x3D; str.toCharArray(); boolean theFirst &#x3D; true; boolean isJumpSymbol &#x3D; false; boolean flag &#x3D; false; if (str &#x3D;&#x3D; null || str.equals(&quot;&quot;)) return 0; for (Character c : strChar) &#123; &#x2F;&#x2F; 1.不为空 if (!Character.isWhitespace(c)) &#123; &#x2F;&#x2F; 检测有效字符，有效字符串前面的空格已经跳过，做上标记 if (isJumpSymbol &#x3D;&#x3D; false) &#123; isJumpSymbol &#x3D; true; &#125; &#x2F;&#x2F; 2.第一个字符为正负符号 if ((c.equals(&#39;-&#39;) || c.equals(&#39;+&#39;)) &amp;&amp; theFirst &#x3D;&#x3D; true) &#123; theFirst &#x3D; false; &#x2F;&#x2F; 如果为负号，做上标记 if (c.equals(&#39;-&#39;)) &#123; flag &#x3D; true; &#125; &#125; else &#123; &#x2F;&#x2F; 3.是否为数字 if (Character.isDigit(c)) &#123; &#x2F;&#x2F; 记录有效数字的长度 if (length &gt; 10) break; length++; switch (c) &#123; case &#39;0&#39;: s &#x3D; s * 10 + 0; break; case &#39;1&#39;: s &#x3D; s * 10 + 1; break; case &#39;2&#39;: s &#x3D; s * 10 + 2; break; case &#39;3&#39;: s &#x3D; s * 10 + 3; break; case &#39;4&#39;: s &#x3D; s * 10 + 4; break; case &#39;5&#39;: s &#x3D; s * 10 + 5; break; case &#39;6&#39;: s &#x3D; s * 10 + 6; break; case &#39;7&#39;: s &#x3D; s * 10 + 7; break; case &#39;8&#39;: s &#x3D; s * 10 + 8; break; case &#39;9&#39;: s &#x3D; s * 10 + 9; break; &#125; &#125; else &#123; break; &#125; &#125; &#125; else if (Character.isWhitespace(c) &amp;&amp; isJumpSymbol &#x3D;&#x3D; true) &#123; break; &#125; &#125; &#x2F;&#x2F; 判断是否溢出 if (flag) &#123; if (-s &lt; Integer.MIN_VALUE) return Integer.MIN_VALUE; &#125; else &#123; if (s &gt; Integer.MAX_VALUE) return Integer.MAX_VALUE; &#125; return (int) (s * (flag ? -1 : 1)); &#125;&#125; 心得&nbsp;&nbsp;&nbsp;&nbsp;这一题让我理解的测试的重要性，血的教训啊！！！T。T","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-%E9%A2%91%E5%BA%A65/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"}]},{"title":"LeetCode:4.Median of Two Sorted Arrays","date":"2017-07-17T08:20:28.000Z","path":"2017/07/17/LeetCode-4-Median-of-Two-Sorted-Arrays/","text":"思路原题：There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 大意：给出两个已经排好序的int数组，将其合并，获取中数并返回。 分析：要求获取两个数组合并后的中数。首先要进行的是对两个数组的合并，然后对合并后的数组进行排序，由于给出的数组本身已经排序，所以可以很容易地在合并的过程中进行排序，最后取出中数加以计算即可。 步骤：1、将两个数组合并，合并过程中进行排序 2、计算中数 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int[] numAccount &#x3D; new int[nums1.length+nums2.length]; &#x2F;&#x2F;两个int数组合并为一个，并排序 int i&#x3D;0; int j&#x3D;0; for(int z&#x3D;0;z&lt;numAccount.length;z++) &#123; &#x2F;&#x2F;判断是否超出数组范围 if(i &gt;&#x3D; nums1.length) &#123; numAccount[z] &#x3D; nums2[j]; j++; &#125; else if(j &gt;&#x3D; nums2.length) &#123; numAccount[z] &#x3D; nums1[i]; i++; &#125; &#x2F;&#x2F;先比较大小再填入numAccount数组中 else if(nums1[i]&lt;&#x3D;nums2[j]) &#123; numAccount[z] &#x3D; nums1[i]; i++; &#125; else if(nums2[j]&lt;nums1[i]) &#123; numAccount[z] &#x3D; nums2[j]; j++; &#125; &#125; &#x2F;&#x2F;取出中数 if(numAccount.length%2 &#x3D;&#x3D; 1) &#123; return numAccount[numAccount.length&#x2F;2]; &#125; else &#123; int midNum1,midNum2; midNum1 &#x3D; numAccount[(numAccount.length&#x2F;2) - 1]; midNum2 &#x3D; numAccount[numAccount.length&#x2F;2]; return (double)(midNum1 + midNum2) &#x2F;2; &#125; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-%E9%A2%91%E5%BA%A65/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/%E7%AE%97%E6%B3%95/"},{"name":"Hard","slug":"Hard","permalink":"http://houghmzqqq.gihub.io/tags/Hard/"}]},{"title":"浅析String、StringBuffer、StringBuider的区别","date":"2017-07-08T12:48:38.000Z","path":"2017/07/08/浅析String、StringBuffer、StringBuider的区别/","text":"1 String浅析1.1 String对象的创建 &nbsp;&nbsp;&nbsp;&nbsp;我们先来了解一下String对象的创建过程。 &nbsp;&nbsp;&nbsp;&nbsp;要创建String对象，很普遍的一种方法是利用构造器 `String str = new String(\"Hello World\")`，问题是这里的参数\"Hello World\"是什么东西？也是一个String对象？ &nbsp;&nbsp;&nbsp;&nbsp;还有一种常用的创建方式，`String str = \"Hello World\"`,与创建基本数据类型相似。 &nbsp;&nbsp;&nbsp;&nbsp;我们知道，Java程序运行之前，编译器会先将源代码文件编译成Class文件，然后再由JVM继续执行，在class字节流中有一个常量池，用于放置源代码中的符号信息(并且不同的符号信息放置在不同标志的常量表中)，其中有四个不同类型的常量表。上述”Hello World”字符串在编译成Class文件时，被存放进常量池中用于存放字符串的常量表中，JVM加载Class文件时，会将该常量表中的字符串取出&nbsp;并在堆中创建新的String对象（intern字符串对象，又称拘留字符串对象）。&nbsp;&nbsp;&nbsp;&nbsp;简单来说，就是在运行阶段&nbsp;String str == &quot;Hello World&quot; &nbsp;中的字符串”Hello World”被转换成&nbsp;拘留字符串&nbsp;对象被压入&nbsp;堆&nbsp;中 参照事例1： 12345678&#x2F;&#x2F;代码1String s1 &#x3D; new String(&quot;Hello&quot;);String s2 &#x3D; new String(&quot;Hello&quot;);System.out.println(s1&#x3D;&#x3D;s2);&#x2F;&#x2F;代码2String s3 &#x3D; &quot;Hello&quot;;String s4 &#x3D; &quot;Hello&quot;;System.out.println(s3&#x3D;&#x3D;s4); 输出为： false true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行代码1时，jvm先为字面值“Hello”创建了一个拘留字符串对象，再将拘留字符串的值赋予给new的对象，所以这里的s1、s2存放的是new出来的对象的地址；执行2代码时，s3、s4存储的时拘留字符串的地址。 参照事例2： 12345678910&#x2F;&#x2F;代码1String s1 &#x3D; &quot;ab&quot;;String s2 &#x3D; &quot;cd&quot;;String s12 &#x3D; s1 + s2;String s &#x3D; &quot;abcd&quot;;System.out.println(s12&#x3D;&#x3D;s);&#x2F;&#x2F;代码2String s1 &#x3D; &quot;ab&quot; + &quot;cd&quot;;String s2 &#x3D; &quot;abcd&quot;;System.out.println(s1&#x3D;&#x3D;s2); 输出为： false true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行上述代码1时，JVM会在堆中先创建一个以s1所指向的拘留字符串对象完成初始化的StringBuilder对象，并使用append方法对s2进行拼接，然后用toString()方法在堆中创建一个String对象，所以s12、s指向两个不同的地址；执行代码2时，“ab”+”cd”会在编译器就合并成“abcd”，因此它指向对应的拘留字符串。 StringBuffer和StringBuilder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer和StringBuilder功能一样，都是用于字符串缓冲，但是StringBuffer是线程安全的，StringBuilder是线程不安全的。由于StringBuilder所有方面都没有被synchronized修饰，因此它的效率要比StringBuffer高。","tags":[{"name":"Java","slug":"Java","permalink":"http://houghmzqqq.gihub.io/tags/Java/"}]},{"title":"markdown文件（即.md后缀文件）的基本常用编写语法","date":"2017-07-01T12:51:11.000Z","path":"2017/07/01/markdown文件（即-md后缀文件）的基本常用编写语法/","text":"现在的前端基本上都用上了前端构建工具，难免要写一些readme等等的说明性文件，这样的文件一般都是.md的文件，所以在这里记录一下.md文件的一些基本编写语法1.标题的三种写法1）第一个字符为#、##、###、。。。、######，表示h1~h6 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 2）适用于标题一和标题二，在标题下面一行加上”======”或”——-“，分别表示标题一和标题二（”=”和”-“数量没有限制） 标题一 ====== 标题二 ——3）与第一种相似，左右两边均加上#号（与标题之间有一个空格） # 一级标题 # ## 二级标题 ## 。 。 。 2.列表1）无序列表下面是效果： 选项1 选项2 选项3 下面是语法： * 选项1 * 选项2 * 选项3 + 选项1 + 选项2 + 选项3 - 选项1 - 选项2 - 选项3 2）有序列表效果如下： 选项1 选项2 选项3 格式为： 1. 选项1 2. 选项2 3. 选项3 .前面的数字并不影响显示时的序号，例如： 3. 选项1 7. 选项2 1. 选项3的显示结果和前面的是一样的。 3.区块应用1）如果你想对某个部分的内容做一些说明或者引用某某人的话时可以使用到效果如下： 问题1 这是对问题一的说明 语法： * 问题1 &gt; 这是对问题一的说明 2）多级引用格式： &gt; 一级引用 &gt;&gt; 二级引用 &gt;&gt;&gt; 三级引用 4.分割线分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以： * * * （星号） _ _ _ （下划线） - - - （减号） 5.链接1）行内式点击这里跳转到百度 [点击这里](http://www.baidu.com)跳转到百度 参数式 更多内容请转github [github]: &lt;https://houghmzqqq.github.io/&gt; &quot;博主github主页&quot; 更多内容请转[github] 这里将链接定义为参数，需要用到的时候写”参数名”即可 6.图片和链接类似，分为行内式和参数式 行内式：![图片](url) 前面的！号是必须的，url为图片地址 参数式：[图片]:url 7.引用代码单行用`代码`（蜜汁符号，Esc下面那个建），多行```代码``` `String role = &quot;student&quot;;` \\``` String role1 = &quot;student&quot;; String role2 = &quot;teacher&quot;; \\``` 效果：String role = &quot;student&quot;; 12String role1 &#x3D; &quot;student&quot;;String role2 &#x3D; &quot;teacher&quot;; 8.表格可以实现如下效果： name age sex tony 18 man lucy 17 woman 如下两种写法均可，第一种中的“：”号表示对齐方式，左边有表示左对齐，两边有表示居中 | name | age | sex | |:----|:---:|---:| | tony | 18 | man | | lucy | 17 | woman | name | age | sex ---- |---- |---- tony | 18 | man lucy | 17 | woman 9.强调这是倾斜效果__ 这是加粗效果 __ 语法： *这是倾斜效果* _这是倾斜效果_ __这是加粗效果__ 10.转义在需要转义的字符前加上“\\”即可 11.删除线删除我吧 ~~删除我吧~~","tags":[{"name":"零碎","slug":"零碎","permalink":"http://houghmzqqq.gihub.io/tags/%E9%9B%B6%E7%A2%8E/"}]}]