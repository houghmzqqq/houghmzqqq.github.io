[{"title":"springboot 2.0中定义拦截器","date":"2018-04-04T01:51:23.000Z","path":"2018/04/04/springboot-2-0中定义拦截器/","text":"HandlerInterceptor 的功能跟过滤器类似，但是提供更精细的的控制能力：在request被响应之前、request被响应之后、视图渲染之前以及request全部结束之后。我们不能通过拦截器修改request内容，但是可以通过抛出异常（或者返回false）来暂停request的执行。 实现 UserRoleAuthorizationInterceptor 的拦截器有：ConversionServiceExposingInterceptorCorsInterceptorLocaleChangeInterceptorPathExposingHandlerInterceptorResourceUrlProviderExposingInterceptorThemeChangeInterceptorUriTemplateVariablesHandlerInterceptorUserRoleAuthorizationInterceptor 其中 LocaleChangeInterceptor 和 ThemeChangeInterceptor 比较常用。 配置拦截器也很简单，Spring 为什么提供了基础类WebMvcConfigurerAdapter ，我们只需要重写 addInterceptors 方法添加注册拦截器。 实现自定义拦截器只需要3步：1、创建我们自己的拦截器类并实现 HandlerInterceptor 接口。2、创建一个Java类继承WebMvcConfigurerAdapter，并重写 addInterceptors 方法。2、实例化我们自定义的拦截器，然后将对像手动添加到拦截器链中（在addInterceptors方法中添加）。 1、LoginInterceptor.java新建一个Interceptor类，实现HandlerInteceptor接口 1234567891011121314151617public class LoginInterceptor implements HandlerInterceptor&#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"--&gt;request请求执行前，Controller执行前。\"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception &#123; System.out.println(\"--&gt;request请求执行后，Controller执行前。\"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception &#123; System.out.println(\"--&gt;request请求执行后，Controller执行后。\"); &#125;&#125; 2、WebAppConfigurer​ 新建WebAppConfigurer类继承WebMvcConfigurationSupport，重写addInteceptor()方法，在其中配置拦截器。（在SpringBoot2.0中，WebMvcConfigurationAdapter已过时，用WebMvcConfigurationSupport替换） 12345678@Configurationpublic class WebAppConfigurer extends WebMvcConfigurationSupport &#123; @Override protected void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new LoginInterceptor()).addPathPatterns(\"/**\"); super.addInterceptors(registry); &#125;&#125; 拦截器配置完成，在浏览器访问该项目路径，拦截器会进行拦截 123--&gt;request请求执行前，Controller执行前。--&gt;request请求执行后，Controller执行前。--&gt;request请求执行后，Controller执行后。","tags":[{"name":"-笔记 -框架 -spring","slug":"笔记-框架-spring","permalink":"http://houghmzqqq.gihub.io/tags/笔记-框架-spring/"}]},{"title":"百度地图(BMap)JavaScript API","date":"2018-02-09T07:03:49.000Z","path":"2018/02/09/百度地图-BMap-JavaScript-API/","text":"","tags":[{"name":"-百度地图","slug":"百度地图","permalink":"http://houghmzqqq.gihub.io/tags/百度地图/"}]},{"title":"关于搭建网站的探索","date":"2018-01-23T09:45:52.000Z","path":"2018/01/23/关于搭建网站的探索/","text":"​ 今天研究了一下搭建一个网站的过程，虽然最后由于云服务器比较贵而止步，但还是想记录一下今天的收获，以供以后搭建网站时做参考。 1.注册一个域名​ 在阿里云上注册了一个域名www.yejunfeng.top。然后进入控制台 ​ 然后顺手完成“实名认证”（需要3~5天），不然过两天域名就访问不了了。 2.域名解析​ 点击上图域名栏中的“解析”，进入域名解析页面 ​ 这个需要你有空间, 也可以被称做主机. 空间服务商在你购买空间之后, 会给你一个固定ip, 然后你只需要把域名解析到该ip下就可以了. 解析需要一定的时间, 也就是10几分钟到几个小时不等. 所以, 解析之后耐心等待.解析这块要理解一些概念, 就是记录类型: 什么是A CNAME MX NS等. A:可以称为IP指向, 就是空间提供的固定IP可以通过A记录, 来达到通过主机记录来访问该空间下的网站. 例如: www.xxxx.com. 指向了ip: 12.12.2.2的ip. 那么访问www.xxxx.com也就是访问了12.12.2.2的网站. CNAME: 是指可以指向一个域名地址. 比方说, 我的记录类型为CNAME,主机为mail, 然后我的主机记录为www.baidu.com, 那么, 我的mail.xxxx.com就是打开的www.baidu.com. ​ 在这里添加一条解析就可以了 ​ 这里的记录值为服务器的ip地址。 3.云服务器绑定域名​ 云服务器需要绑定上面的域名（解析了服务器ip地址的域名）。 ​ 这是我在阿里云上租用的云虚拟机，我在上面进行了域名的绑定。绑定后需要备案，十分的麻烦，如果仅是个人使用，建议去淘宝租用香港的虚拟机 4.上传程序​ 通过服务器或虚拟机支持的上传方式，将你的项目上传，我本来打算上传wordpress的，这是一 个cms站点。具体的可以网上搜索。 5.想说​ 网上的空间商网站很少有提供java虚拟主机的，多数是PHP和.net。这是因为JSP主机的维护成本比较高，所以，配置JSP主机的，一般是自己的服务器。现在做站大多用PHP，是因为全套免费，从PHP语言到MySQL数据库、Apache服务器、Linux系统，开发成本低。维护成本也低。而JSP主要用于大型数据运算的。所以一般银行、税务、查询等大型系统，无一不是用JSP开发的。开发成本高。 ​ 所以想要在托管一个java web应用，要么使用自己的服务器，要么在网上租用云服务器，使用云虚拟主机的话，比较难找，也比较贵。","tags":[{"name":"零碎","slug":"零碎","permalink":"http://houghmzqqq.gihub.io/tags/零碎/"},{"name":"网站搭建","slug":"网站搭建","permalink":"http://houghmzqqq.gihub.io/tags/网站搭建/"}]},{"title":"自定义jsp标签","date":"2018-01-17T03:00:07.000Z","path":"2018/01/17/自定义jsp标签/","text":"1.如何自定义Jsp标签​ 通过一个示例来说明如何自定义一个jsp标签，示例内容是定义一个标签输出“Hello World！” 1.1新建一个java类，继承TagSupport类​ 可以选择重写doStartTag()、doEndTag、doAfterBody()等方法，分别表示识别到开始标签时执行的方法、识别结束标签时执行的方法、执行完标签体后执行的方法。 ​ 我们可以在doStartTag()中控制是否输出标签体，在doAfterBody()中实现标签体的循环输出，在doEndTag()中控制后面的内容是否输出等。 12345678910111213141516public class MyTag extends TagSupport &#123; @Override public int doStartTag() throws JspException &#123; //获取输出流 JspWriter out = this.pageContext.getOut(); //或者获取打印流// PrintWriter out = this.pageContext.getResponse().getWriter(); try &#123; //打印字符串 out.print(\"Hello World!\"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return super.doStartTag(); &#125;&#125; 1.2注册Tag标签​ 实现好标签的具体执行类后，需要新建一个tld文件对它进行注册。 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"ISO-8859-1\"?&gt;&lt;taglib xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-jsptaglibrary_2_1.xsd\" version=\"2.1\"&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;short-name&gt;mycompany&lt;/short-name&gt; &lt;!-- 这个标签的uri，jap通过这个uri访问这个标签库 --&gt; &lt;uri&gt;http://mycompany.com/mytag&lt;/uri&gt; &lt;!-- Invoke 'Generate' action to add tags or functions --&gt; &lt;!-- 标签的信息，定义标签的名称、对应的标签实现类、标签体内容格式 --&gt; &lt;tag&gt; &lt;name&gt;ViewIp&lt;/name&gt; &lt;tag-class&gt;com.yjf.tagTest.MyTag&lt;/tag-class&gt; &lt;!-- 标签体内容格式，可以为empty、JSP等 --&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;/tag&gt; &lt;/taglib&gt; 1.3引用标签​ 注册完成后，就可以在jsp中使用该标签了。 12345678&lt;!-- 引用标签库，uri对应tld文件中的uri --&gt;&lt;%@taglib prefix=\"mytag\" uri=\"http://mycompany.com/mytag\"%&gt;&lt;html&gt; &lt;body&gt; &lt;!-- 别名：标签名 的形式使用自定义标签 --&gt; &lt;mytag:ViewIp/&gt; &lt;/body&gt;&lt;/html&gt; 2.自定义标签的原理2.1访问页面到调用标签的过程​ 1）当服务器打开时，就会加载WEB-INF下的资源文件，包括web.xml 和 tld文件，把它们加载到内存 ​ 2）我们在浏览器输入http://localhost:8080/index.jsp来访问jsp页面 ​ 3）服务器读取index.jsp里的内容，当读到 &lt;%@taglib uri=&quot;http://mycompany.com/mytag&quot; prefix=&quot;mytag&quot; %&gt; 这一句的时候，就会在内存中找是否存在uri为http://mycompany.com/mytag的tld文件，找不到就会报错 ​ 4）继续读取jsp页面，读到&lt;mmt:mytag&gt;这个标签的时候，就会通过uri去找到tld文件，在tld文件中找到mytab是否被定义，是的话就得到它的tag-class的内容，然后去找到它对应的标签处理程序 ​ 5）实例化标签处理程序，利用生成的对象调用它里面的方法 2.2处理程序中方法的调用顺序服务器对标签处理程序里的方法也有一定的调用顺序 ​ A)void setPageContext(PageContext pc) –传入pageContext对象 ​ B)void setParent(Tag t) –如果有父标签，传入父标签对象，如果没有，则传入null ​ C)int doStartTag() –开始执行标签时调用。 ​ D)int doEndTag() –结束标签时调用 ​ E)void release() –释放资源 如果你没有重写上面的方法，系统将会调用它的父类里的方法~ 为什么是这个调用顺序，我们来看一下证据，下面是该jsp被翻译为的java文件中截取的内容 123456789101112131415161718192021222324252627282930313233343536373839private boolean _jspx_meth_mytag03_005fchangeBody_005f0(PageContext _jspx_page_context) throws Throwable &#123; //获取pageContext PageContext pageContext = _jspx_page_context; JspWriter out = _jspx_page_context.getOut(); // mytag03:changeBody com.yjf.tagTest.MyTag03 _jspx_th_mytag03_005fchangeBody_005f0 = (com.yjf.tagTest.MyTag03) _005fjspx_005ftagPool_005fmytag03_005fchangeBody.get(com.yjf.tagTest.MyTag03.class); //1.调用setPageContext方法 _jspx_th_mytag03_005fchangeBody_005f0.setPageContext(_jspx_page_context); //2.调用setParent方法 _jspx_th_mytag03_005fchangeBody_005f0.setParent(null); //3.调用doStartTag方法 int _jspx_eval_mytag03_005fchangeBody_005f0 = _jspx_th_mytag03_005fchangeBody_005f0.doStartTag(); if (_jspx_eval_mytag03_005fchangeBody_005f0 != javax.servlet.jsp.tagext.Tag.SKIP_BODY) &#123; if (_jspx_eval_mytag03_005fchangeBody_005f0 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) &#123; out = _jspx_page_context.pushBody(); _jspx_th_mytag03_005fchangeBody_005f0.setBodyContent((javax.servlet.jsp.tagext.BodyContent) out); _jspx_th_mytag03_005fchangeBody_005f0.doInitBody(); &#125; do &#123; out.write(\"\\r\\n\"); out.write(\" hello world!\\r\\n\"); //4.调用doAfterBody方法 int evalDoAfterBody = _jspx_th_mytag03_005fchangeBody_005f0.doAfterBody(); if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN) break; &#125; while (true); if (_jspx_eval_mytag03_005fchangeBody_005f0 != javax.servlet.jsp.tagext.Tag.EVAL_BODY_INCLUDE) &#123; out = _jspx_page_context.popBody(); &#125; &#125; //5.调用doEndTag方法 if (_jspx_th_mytag03_005fchangeBody_005f0.doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) &#123; _005fjspx_005ftagPool_005fmytag03_005fchangeBody.reuse(_jspx_th_mytag03_005fchangeBody_005f0); return true; &#125; _005fjspx_005ftagPool_005fmytag03_005fchangeBody.reuse(_jspx_th_mytag03_005fchangeBody_005f0); return false; &#125; 3.操作标签体中的内容​ 使用TagSupport能够实现控制标签体内容的输出，但是不能够修改标签体的内容。如果需要修改标签体的内容再输出，需要继承TagSupport的子类BodyTagSupport。 12345678910111213141516171819202122232425262728public class MyTag03 extends BodyTagSupport &#123; @Override public int doStartTag() throws JspException &#123; //表示输出标签体中的内容 return BodyTag.EVAL_BODY_BUFFERED; &#125; @Override public int doAfterBody() throws JspException &#123; //得到BodyContent对象，它包装了标签体里的内容 BodyContent bodyContent = this.getBodyContent(); //获取标签体中的内容 String content = bodyContent.getString(); //将字符串转换为大写 String change = content.toUpperCase(); try &#123; this.pageContext.getResponse().getWriter().write(change); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return Tag.EVAL_BODY_INCLUDE; &#125; @Override public int doEndTag() throws JspException &#123; return Tag.SKIP_PAGE; &#125;&#125; ​ 使用以上的方法定义的标签我们成为传统标签，这种方法相对比较麻烦，所以有人写出一组代码，用来解决这个问题，这组代码称为：简单标签 简单标签4.开发一个简单标签​ 实现简单标签需要继承SimpleTagSupport类 4.1创建处理类1234567public class SimpleTag extends SimpleTagSupport &#123; @Override public void doTag() throws JspException, IOException &#123; getJspBody().invoke(null); super.doTag(); &#125;&#125; 4.2注册123456&lt;tag&gt; &lt;name&gt;showBody&lt;/name&gt; &lt;tag-class&gt;com.yjf.tagTest.SimpleTag&lt;/tag-class&gt; &lt;!-- 这里需要用scriptless处理 --&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;/tag&gt; 4.3在将jsp中使用和传统标签一样的方法 5.简单标签的原理5.1访问过程1）和传统标签一样，得到tag-class字符串，找到标签处理程序类 2）实例化标签处理程序类 3）利用对象调用方法。。。。 5.2方法调用顺序和传统标签相比，简单标签调用的方法不相同： SimpleTag接口的方法执行过程： 1） void setJspContext(JspContext pc) ——设置pageContext对象，传入pageContext对象。JspContext是PageContext的父类。在标签处理器类中通过this.getJspContext()方法得到PageContext对象。 2）void setParent(JspTag parent) ——传入父标签对象，如果没有父标签，则不调用次方法。通过getParent方法得到父标签对象 3）void setJspBody(JspFragment jspBody) ——传入标签体内容。标签体内容封装到JspFragment方法中。通过getJspBody方法得到标签体内容。如果没签体，不调用此方法。 4）void doTag() ——开始标签和结束标签都执行次方法。 这个顺序也是有依据的，具体查看tomcat下的jsp编译文件 5.3控制标签体文本与结束标签后的内容是否输出我们可以通过JspFragment对象来控制– 标签体内容： ​ 要输出：在doTage()方法中执行jspFrament.invoke()方法 ​ 不输出：什么都不做！ 结束标签后的内容： ​ 要输出：什么都不做！ ​ 不输出：在doTag()方法中抛出一个SkipPageException异常。 那么如何循环输出标签体内容呢，在简单标签中实现十分简单，在doTag()方法中加一个for循环即可： 12345678910 public class SimpleTag extends SimpleTagSupport &#123; @Override public void doTag() throws JspException, IOException &#123; System.out.println(\"使用了简单标签中的doTag方法！\"); for(int i=0;i&lt;3;i++)&#123; getJspBody().invoke(null); &#125; super.doTag(); &#125;&#125; 5.4改变标签体中的内容在doTag()方法中这样写： 12345678910111213141516public class SimpleTag02 extends SimpleTagSupport &#123; @Override public void doTag() throws JspException, IOException &#123; //1.获取一个临时的输出流作为容器 StringWriter writer = new StringWriter(); //2.将标签体内容拷贝到writer流中 JspFragment jspFragment = this.getJspBody(); jspFragment.invoke(writer); //3.从临时的输出流中获取标签体内容 String tempStr = writer.toString(); //4.修改标签体内容 tempStr = tempStr.toUpperCase(); //5.通过JspContext将内容输出，这里注意使用jspFragment.invoke()还是输出修改前的标签体 this.getJspContext().getOut().write(tempStr); &#125;&#125; 5.5标签体内容输出格式除了能设置标签体内容是否输出，还能够设置它的输出格式，那么它有什么样的输出格式呢？ 可以有以下输出格式： JSP： 表示输出的标签体内容可以包含jsp脚本，且可以执行此脚本。此值只能用在传统标签中。 scriptless: 表示输出的标签体内容不能包含jsp脚本，如果包含则报错。 empty：表示没有标签体内容。即是空标签。如果不是空标签，则报错。 tagdependent： 表示输出的标签体内容可以包含jsp脚本。但不执行jsp脚本（直接原样输出） 5.6自定义标签属性下面定义一个if标签： 123456789101112131415public class MyIfTag extends SimpleTagSupport&#123; //定义一个属性，并生成setter方法 private boolean test; public void setTest(boolean test) &#123; this.test = test; &#125; @Override public void doTag() throws JspException, IOException &#123; //如果test为true，执行标签体 if (test)&#123; getJspBody().invoke(null); &#125; &#125;&#125; tld文件中定义test属性 1234567891011&lt;tag&gt; &lt;name&gt;if&lt;/name&gt; &lt;tag-class&gt;com.yjf.tagTest.MyIfTag&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;!-- 定义属性 --&gt; &lt;attribute&gt; &lt;name&gt;test&lt;/name&gt; &lt;required&gt;true&lt;/required&gt;&lt;!-- --&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt;&lt;!-- --&gt; &lt;/attribute&gt;&lt;/tag&gt; 6.最后的实践6.1任务使用SimpleTagSupport简单标签自定义一组标签、、 –其中when标签中有一个boolean类型的属性：test –choose是when和otherwise的父标签，when在otherwise之前使用 –在父标签中定义一个“全局”的boolean类型的flag：用于判断子标签在满足条件的情况下是否执行 –若when的tese为true，且when的父标签flag也为true，则执行when的标签体，并且设置父标签的flag为false –若when的test为true，且when的父标签flag为false，则不执行标签体 –若flag为true，otherwise执行标签体 6.2处理类MyChoose： 123456789101112131415 public class MyChoose extends SimpleTagSupport &#123; //全局的判断属性 private boolean flag = true; public boolean isFlag() &#123; return flag; &#125; public void setFlag(boolean flag) &#123; this.flag = flag; &#125; @Override public void doTag() throws JspException, IOException &#123; getJspBody().invoke(null); &#125;&#125; MyWhen： 123456789101112131415161718192021public class MyWhen extends SimpleTagSupport&#123; private boolean test; public void setTest(boolean test) &#123; this.test = test; &#125; @Override public void doTag() throws JspException, IOException &#123; //test为true if (test) &#123; //获取父标签的flag MyChoose choose = (MyChoose) getParent(); boolean flag = choose.isFlag(); //如果父标签的flag为trur，则执行when的标签体 if(flag)&#123; getJspBody().invoke(null); choose.setFlag(false); &#125; &#125; &#125;&#125; MyOtherwise： 1234567891011public class MyOtherwise extends SimpleTagSupport &#123; @Override public void doTag() throws JspException, IOException &#123; //获取父标签 MyChoose choose = (MyChoose) getParent(); //如果父标签中的flag为true，则执行otherwise的标签体 if(choose.isFlag())&#123; getJspBody().invoke(null); &#125; &#125;&#125; 6.3tld文件在tld文件中定义标签 1234567891011121314151617181920&lt;tag&gt; &lt;name&gt;choose&lt;/name&gt; &lt;tag-class&gt;com.yjf.tagTest.MyChoose&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt;&lt;/tag&gt;&lt;tag&gt; &lt;name&gt;when&lt;/name&gt; &lt;tag-class&gt;com.yjf.tagTest.MyWhen&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;test&lt;/name&gt; &lt;required&gt;true&lt;/required&gt; &lt;rtexprvalue&gt;true&lt;/rtexprvalue&gt; &lt;/attribute&gt;&lt;/tag&gt;&lt;tag&gt; &lt;name&gt;otherwise&lt;/name&gt; &lt;tag-class&gt;com.yjf.tagTest.MyOtherwise&lt;/tag-class&gt; &lt;body-content&gt;scriptless&lt;/body-content&gt;&lt;/tag&gt; 6.4jsp中使用接下来就是在jsp中使用这些个标签啦 12345678&lt;myc:choose&gt; &lt;myc:when test=\"$&#123;false&#125;\"&gt; when body &lt;/myc:when&gt; &lt;myc:otherwise&gt; otherwise body &lt;/myc:otherwise&gt;&lt;/myc:choose&gt; 如上，页面中显示 otherwise body。","tags":[{"name":"Java","slug":"Java","permalink":"http://houghmzqqq.gihub.io/tags/Java/"}]},{"title":"synchronized和Lock的区别","date":"2018-01-08T11:36:58.000Z","path":"2018/01/08/synchronized和Lock的区别/","text":"1.Thread的几个重要方法我们先了解一下Thread的几个重要方法：​ a、start()方法，调用该方法开始执行该线程；​ b、stop()方法，调用该方法强制结束该线程执行；​ c、join方法，调用该方法等待该线程结束。​ d、sleep()方法，调用该方法该线程进入等待。​ e、run()方法，调用该方法直接执行线程的run()方法，但是线程调用start()方法时也会运行run()方法，区别就是一个是由线程调度运行run()方法，一个是直接调用了线程中的run()方法！！ ​ 看到这里，可能有些人就会问啦，那wait()和notify()呢？要注意，其实wait()与notify()方法是Object的方法，不是Thread的方法！！同时，wait()与notify()会配合使用，分别表示线程挂起和线程恢复。 ​ 这里还有一个很常见的问题，顺带提一下：wait()与sleep()的区别，简单来说wait()会释放对象锁而sleep()不会释放对象锁。这些问题有很多的资料，不再赘述。 2.线程的状态 线程总共有5大状态。 新建状态：新建线程对象，并没有调用start()方法之前 就绪状态：调用start()方法之后线程就进入就绪状态，但是并不是说只要调用start()方法线程就马上变为当前线程，在变为当前线程之前都是为就绪状态。值得一提的是，线程在睡眠和挂起中恢复的时候也会进入就绪状态哦。 运行状态：线程被设置为当前线程，开始执行run()方法。就是线程进入运行状态 阻塞状态：线程被暂停，比如说调用sleep()方法后线程就进入阻塞状态 死亡状态：线程执行结束 3.锁的类型 可重入锁：在执行对象中所有同步方法不用再次获得锁 可中断锁：在等待获取锁过程中可中断 公平锁： 按等待获取锁的线程的等待时间进行获取，等待时间长的具有优先获取锁权利 读写锁：对资源读取和写入的时候拆分为2部分处理，读的时候可以多线程一起读，写的时候必须同步地写 4.synchronized和Lock的区别 类别 synchronized Lock 存在层次 JAVA的关键字，在jvm层面上的 是一个类 锁的释放 1.已获取锁的线程执行完代码，释放锁 2.线程执行发生异常时，jvm会让线程释放锁 在finally中必须释放锁，不然容易造成线程死锁 锁的获取 假如A线程获得锁，B线程等待。如果A线程阻塞，B线程会一直等待。 分情况而定，Lock有多个获取锁的方式，大致是可以尝试获得所，线程可以不用一直等待 锁状态 无法判断 可以判断 锁类型 可重入 不可中断 非公平 可重入 可中断 可公平(可非公平) 性能 少量同步 大量同步","tags":[{"name":"Java","slug":"Java","permalink":"http://houghmzqqq.gihub.io/tags/Java/"},{"name":"线程","slug":"线程","permalink":"http://houghmzqqq.gihub.io/tags/线程/"}]},{"title":"redis学习笔记","date":"2018-01-02T11:47:27.000Z","path":"2018/01/02/redis学习笔记/","text":"1.什么是redis​ redis是一种NoSql（非关系型数据库），它是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言的API。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。 2.redis的安装redis一般是安装在liunx上的，本人使用centOs进行安装 2.1配置环境​ redis是使用c语言开发的，使用它需要配置c语言的运行环境，需要在centOs中安装gcc-c++软件 1yum install gcc-c++ ​ 下载redis for linux，使用SecureCRT上传到虚拟机上运行的centOs，并进行解压 1tar -zxvf redis-4.0.6.tat.gz ​ 解压后进入redis-4.0.6文件夹 1cd redis-4.0.6 ​ 然后执行make命令，对它进行基本的编译 1make ​ 进行基本的安装 1make PREFIX=/usr/local/redis install ​ 然后进到/usr/local/redis/bin目录中 1cd /usr/local/redis/bin ​ 该目录中可以看到以下文件 ] redis-benchmark 性能测试的工具 redis-check-aof aof文件修复工具 redis-check-rdb rdb文件检查工具 redis-cli 命令行的客户端 redis-sentinel -&gt; redis-server redis-server redis服务器启动命令 ​ 回到redis-4.0.6目录下，将redis.conf文件复制到redis目录 1cp redis.conf /usr/local/redis ​ 修改redis.conf文件 将daemonize yes 改为 no (表示开启) 将bind 127.0.0.1 注释掉(否则，redis只能由本机访问) 将protected-mode yes 改为no(表示关闭保护模式，否则在关闭bind的情况下，不能通过外部程序访问redis) ​ 启动redis 1./usr/local/redis/bin/redis-server ./usr/local/redis/redis.conf ​ 查看是否启动 1ps -ef | grep -i redis ​ 关闭redis 1./usr/local/redis/bin/redis-cli shutdown ​ 执行客户端，之后就可以向redis数据库存取数据了 1./usr/local/redis/bin/redis-cli ​ 插入命令，插入一个key=name，value=zhangsan的数据 1set name zhangsan ​ 查询命令，查询key=name的数据 1get name ​ 查看所有key名称 1keys * 3.使用jedis操作linux上的redis​ jedis是redis官方推荐的一个针对java语言的客户端，使用它可以使用java程序操作redis。 3.1打开redis端口在root用户下，通过vim /etc/sysconfig/iptables 修改防火墙配置， 以上6379为默认端口，配置你自己的redis端口 3.2在maven工程中导入jar包12345678910&lt;dependency&gt; &lt;groupId&gt;commons-pool&lt;/groupId&gt; &lt;artifactId&gt;commons-pool&lt;/artifactId&gt; &lt;version&gt;1.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt;&lt;/dependency&gt; 3.3测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class JedisDemo1 &#123; /** *连接linux上的redis **/ @Test public void demo1()&#123; //1.设置ip地址和端口号 Jedis jedis = new Jedis(\"192.168.13.153\"); //2.保存数据 jedis.set(\"name\",\"yejunfeng\"); //3.获取数据 System.out.println(jedis.get(\"name\")); //4.释放资源 jedis.close(); &#125; /** *设置redis的连接池 **/ @Test public void demo2()&#123; //1.获得连接池配置对象 JedisPoolConfig config = new JedisPoolConfig(); //设置最大连接数 config.setMaxTotal(10); //设置最大空闲连接数 config.setMaxIdle(5); //获得连接池 JedisPool jedisPool = new JedisPool(config,\"192.168.13.153\",6379); //获得jedis对象 Jedis jedis = null; try &#123; jedis = jedisPool.getResource(); jedis.set(\"handsome\",\"yjf\"); System.out.println(jedis.get(\"handsome\")); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if(jedis!=null)&#123; jedis.close(); &#125; if(jedisPool!=null)&#123; jedisPool.close(); &#125; &#125; &#125;&#125; 4.redis中的数据结构redis有5种数据结构，分别是hash、String、list、sort set、set 4.1字符串的基本操作 set key value get key value incr key(该key的value为一个可以转换为数字的字符串，否则报错) decr key incrby key 4(表示该key的值加4) decrby key 4(表示该key的值减4) append key aa(如果key的值为b，执行该命令后key的值为aab) 4.2hash的基本操作key为hash的名称，field为属性名，value为属性值 hset key field value hget key field hdel key field hgetall key hmset key field value [field value] hincrby key field increment(使hash的某个属性增加‘increment’) hexists key field(判断某个hash的某个属性是否存在) hlen key(返回某个hash的属性个数) hkeys key(返回某个hash的所有属性名称) hvals key(返回某个hash的所有属性的值) 4.3list的基本操作 lpush key value [value] (从左边将元素放入队列) lpushx key value [value] (为已存在的列表添加至) rpush key value [value] (从右边将元素放入队列) lrange key start stop (start和stop表示查找的范围，0 -1 表示查找全部) lindex key index (通过索引查找列表中的元素) rpop key (弹出列表的最后一个元素) rpoplpush list1 list2 (将list1中的最后一个元素删除并移出，放入list2的头部) linsert key BEFORE|AFTER pivot value (在pivot之前或之后插入元素) 4.4set的基本操作","tags":[{"name":"redis","slug":"redis","permalink":"http://houghmzqqq.gihub.io/tags/redis/"},{"name":"数据库","slug":"数据库","permalink":"http://houghmzqqq.gihub.io/tags/数据库/"}]},{"title":"mybatis学习笔记","date":"2018-01-02T01:03:25.000Z","path":"2018/01/02/mybatis学习笔记/","text":"1.初次使用mybatis1.1通过maven导入jar包12345678910&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.1.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.30&lt;/version&gt;&lt;/dependency&gt; 1.2mybatis的配置文件mybatis需要一个全局的配置文件，在其中声明数据库、连接池等参数 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\" /&gt; &lt;!-- 配置数据库连接信息 --&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\" /&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\" /&gt; &lt;property name=\"username\" value=\"root\" /&gt; &lt;property name=\"password\" value=\"XDP\" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"User.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; 2.3创建一个实体类User以及相应的映射文件User.xml123456public class User &#123; private int id; private String userName; private String password; …getter and setter…&#125; 12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- 为这个mapper指定一个唯一的namespace，namespace的值习惯上设置成包名+sql映射文件名，这样就能够保证namespace的值是唯一的例如namespace=\"me.gacl.mapping.userMapper\"就是me.gacl.mapping(包名)+userMapper(userMapper.xml文件去除后缀) --&gt;&lt;mapper namespace=\"me.gacl.mapping.userMapper\"&gt; &lt;!-- 在select标签中编写查询的SQL语句， 设置select标签的id属性为getUser，id属性值必须是唯一的，不能够重复 使用parameterType属性指明查询时使用的参数类型，resultType属性指明查询返回的结果集类型 resultType=\"me.gacl.domain.User\"就表示将查询结果封装成一个User类的对象返回 User类就是users表所对应的实体类 --&gt; &lt;!-- 根据id查询得到一个user对象 --&gt; &lt;select id=\"getUser\" parameterType=\"int\" resultType=\"me.gacl.domain.User\"&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt;","tags":[{"name":"框架","slug":"框架","permalink":"http://houghmzqqq.gihub.io/tags/框架/"}]},{"title":"java多态","date":"2017-12-18T03:26:23.000Z","path":"2017/12/18/java多态/","text":"什么是多态面向对象的三大特性： ​ 1.封装：通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。 ​ 2.继承：一个类可以继承另一个类，子类可以访问父类的属性和方法。 ​ 3.多态：多态性是指允许不同子类型的对象对同一消息作出不同的响应。简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。 举个栗子： ​ 有一个Person类，它封装了walk()和talk()两个行为。有一个Teacher类继承了Person，Teacher也能够walk()和talk()，在此基础上他还能够teach()。 ​ 现在有~Person per = new Teacher();~，它表示Person的引用指向Teacher对象，per能够使用Person中的方法但不能使用Student中独有的teach(),能够访问Person中的非私有(private)属性，如果Student中重写了Person中的walk()方法，则per.walk()实际上是使用了重写后的walk()。 ​ 总的来说，java中的多态有三个条件：继承，重写，父类引用指向子类对象 第二个栗子： 123456789101112131415161718class A ...&#123; public String show(D obj)...&#123; return (\"A and D\"); &#125; public String show(A obj)...&#123; return (\"A and A\"); &#125; &#125; class B extends A...&#123; public String show(B obj)...&#123; return (\"B and B\"); &#125; public String show(A obj)...&#123; return (\"B and A\"); &#125; &#125; class C extends B...&#123;&#125; class D extends B...&#123;&#125; 123456789101112131415A a1 = new A(); A a2 = new B(); B b = new B(); C c = new C(); D d = new D(); System.out.println(a1.show(b)); 1System.out.println(a1.show(c)); 2System.out.println(a1.show(d)); 3System.out.println(a2.show(b)); 4System.out.println(a2.show(c)); 5System.out.println(a2.show(d)); 6System.out.println(b.show(b)); 7System.out.println(b.show(c)); 8System.out.println(b.show(d)); 9 结果： 1234567891 A and A2 A and A3 A and D4 B and A5 B and A6 A and D7 B and B8 B and B9 A and D","tags":[{"name":"Java","slug":"Java","permalink":"http://houghmzqqq.gihub.io/tags/Java/"}]},{"title":"JSONObject使用心得","date":"2017-12-15T12:48:54.000Z","path":"2017/12/15/JSONObject使用心得/","text":"对于JSONObject的使用心得​ 最近在一个项目中需要频繁使用JSON数据来做数据接口，使用到了JSONObject工具类，这是java中一个强大的json转Object、Object转json的工具。 1.maven中导入的jar：12345678910111213141516171819202122232425&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!-- Exclude Commons Logging in favor of SLF4j --&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-lang&lt;/groupId&gt; &lt;artifactId&gt;commons-lang&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-lang.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.json-lib&lt;/groupId&gt; &lt;artifactId&gt;json-lib-ext-spring&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt;&lt;/dependency&gt; 大概这些，可能还有些漏掉的… 2.使用2.1拼接jsonJSONObject可以逐个拼接字符串组成json，示例： 1234JSONObject jsonObject = newJSONObject();jsonObject.accumulate(\"action\",\"register\");jsonObject.accumulate(\"result\",\"ok\");jsonObject.toString(); 以上的代码输出{“action”:”register”,”result”:”ok”} 2.2拼接json数据使用JSONArray类封装json数据，示例： 123456789JSONObject json01 = newJSONObject();jsonObject.accumulate(\"action\",\"register\");jsonObject.accumulate(\"result\",\"ok\");JSONObject json02 = newJSONObject();jsonObject.accumulate(\"action\",\"login\");jsonObject.accumulate(\"result\",\"ok\");JSONArray jsonArray = new JSONArray();jsonArray.add(json01);jsonArray.add(1,json02); 上面代码输出[{“action”:”register”,”result”:”ok”},{“action”:”login”,”result”:”ok”}] 2.3json转Object，Object转jsonJSONObject可以直接将一个对象转化为json数据格式，示例： 12345public class Student()&#123; private String name; private String gander; ...setter and getter...&#125; 123456//通过JSONObject将对象转化为json数据格式Student stu = new Student();stu.setName(\"Jack\");stu.setGander(\"man\");JSONObject jsonObject = JSONObject.fromObject(stu);jsonObject.toString(); 上述代码输出{“name”:”Jack”,”gander”:”man”} 如果Student中包含其他对象，JSONArray转化Student对象时，需要用到一个map，示例： 123456public class Student()&#123; private String name; private String gander; private List&lt;Course&gt; courses; ...setter and getter...&#125; 12345678Map&lt;String,Object&gt; map = new HashMap&lt;~&gt;();map.put(\"courses\",Course.class);//data表示一个json格式的stu数组JSONObject jsonObject = JSONObject.fromObject(\"&lt;data&gt;\");//stu为Student数组的名称JSONArray jsonArray = jsonObject.getJSONArray(\"stu\");//解析student数组中的Course数组List&lt;Course&gt; courses = JSONArray.toList(jsonObject,Student.class,map); ######","tags":[{"name":"笔记","slug":"笔记","permalink":"http://houghmzqqq.gihub.io/tags/笔记/"}]},{"title":"代理模式","date":"2017-11-08T11:50:02.000Z","path":"2017/11/08/代理模式/","text":"1.远程代理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一冰淇淋公司制作了一个控制冰淇淋生产的系统，现在有一个新的需求，该公司CEO希望能够远程获取生产系统的信息。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CEO希望远程遥控生产系统，所以首先CEO这边的计算机上需要运行该系统，我们知道不同机器上运行的同一种程序会存在于不同的JVM中，它们之间是没有直接联系的。我们可以通过远程代理的方式让它们进行通信。 Java中的RMI","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://houghmzqqq.gihub.io/tags/设计模式/"}]},{"title":"线程笔记","date":"2017-11-02T05:41:17.000Z","path":"2017/11/02/线程笔记/","text":"1.Thread和RunnableThread是Runnable的实现类，定义一个线程类时，可以通过实现Runnable接口并实现run()方法实现；也可以通过继承Thread并重写run()方法实现。 区别在于，由于java不支持多继承，当你的线程类需要继承其他的类时，就需要用到Runnable 使用Thread实现线程类： 12345public class MyThread01 extends Thread &#123; public void run() &#123; //实现... &#125;&#125; 使用Runnable实现线程类： 1234public class MyThread02 implements Runnable &#123; public void run() &#123; //实现... &#125; 运行： 12345678public class Client&#123; public static void main(String args[])&#123; //直接调用start()方法启动 new MyThread01.start(); //需要使用Thread中的start()方法启动 new Thread(new MyThread02()).start(); &#125;&#125; 2.ExecutorExecutor在客户端和任务执行之间提供了一个间接层；与客户端直接执行任务不同，任务将由这个中介对象执行。Executor允许你管理异步任务的执行，而无需显式地管理线程的生命周期。 1）.CachedThreadPool为每个任务创建一个线程[与普通的线程启动没什么区别]2）.FixedThreadPool可以限制线程的作用： 12345678910public class Client &#123; public static void main(String[] args) &#123; //使用Executors的静态方法确定ExecutorService的类型 ExecutorService exec = Executors.newFixedThreadPool(5); for(int i=0;i&lt;10;i++)&#123; exec.execute(new MyThread()); &#125; exec.shutdown(); &#125;&#125; 如上代码，设置容量为5，当存在5个线程时，其他任务将延后处理，当有线程结束时再执行。. . . 3.Callable如果你的线程类实现了__Callable__而不是Runnable，则线程结束时会__返回一个类型为Future结果__。与Runnable类似，实现Callable需要实现它的call()方法，并且必须_使用ExecutorService中的submit()方法启动线程_。 示例：实现Callable接口并实现call()方法 1234567891011public class MyCallable implements Callable&lt;String&gt; &#123; private int id; public MyCallable(int id) &#123; this.id = id; &#125; @Override public String call() throws Exception &#123; return \"result of MyCallable\" + id; &#125;&#125; 启动线程，接收结果并输出 1234567891011121314151617181920public class Client &#123; public static void main(String[] args) &#123; ExecutorService exec = Executors.newCachedThreadPool(); List&lt;Future&lt;String&gt;&gt; list = new ArrayList&lt;&gt;(); for(int i=0;i&lt;10;i++)&#123; list.add(exec.submit(new MyCallable(i))); &#125; try &#123; for(Future&lt;String&gt; ft : list)&#123; System.out.println(ft.get()); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125;finally&#123; exec.shutdown(); &#125; &#125;&#125; 4.多线程的资源共享4.1多线程调用一个资源的例子1）.首先定义一个抽象类IntGenerator，作为被消费者的父类 123456789101112public abstract class IntGenerator &#123; private volatile boolean canceled = false; //被消费者的功能在这个方法中定义 public abstract int next(); //能够被取消 public void cancel()&#123; canceled = true; &#125; public boolean isCanceled()&#123; return canceled; &#125;&#125; 2）.消费者EvenChecker，它是一个线程类 123456789101112131415161718192021222324252627282930public class EvenChecker implements Runnable &#123; private IntGenerator generator; private final int id; public EvenChecker(IntGenerator generator, int id) &#123; this.generator = generator; this.id = id; &#125; @Override public void run() &#123; System.out.println(\"Thread: \" + id); while(!generator.isCanceled())&#123; int val = generator.next(); if(val % 2 != 0)&#123; System.out.println(val + \" not even!\"); generator.cancel(); &#125; &#125; &#125; //测试任意类型的IntGenerator public static void test(IntGenerator gp,int count)&#123; System.out.println(\"Press Contro-c to exit\"); ExecutorService excu = Executors.newCachedThreadPool(); for(int i=0;i&lt;count;i++)&#123; excu.execute(new EvenChecker(gp,i)); &#125; &#125; public static void test(IntGenerator gp)&#123; test(gp,10); &#125;&#125; 3）.被消费者 12345678910111213public class EvenGenerator extends IntGenerator &#123; private int currentEvenvalue = 0; //生产偶数 public int next() &#123; ++currentEvenvalue; //冲突点 ++currentEvenvalue; return currentEvenvalue; &#125; public static void main(String[] args) &#123; EvenChecker.test(new EvenGenerator()); &#125;&#125; 执行上面的程序时，__一个任务有可能在另一个任务执行第一个对currentEvenvalue的递增操作之后，但是没有执行第二个操作之前[即注释&quot;冲突点&quot;的地方]，调用next()方法__。这就使得next()返回的值可能是一个奇数，这时线程会调用cancel()方法取消被消费者。 4.2 解决共享资源竞争1）使用synchronized关键字修饰方法 在上面的问题中，可能发生冲突的代码是next()方法，我们使用synchronized关键字修饰该方法 1234567public synchronized int next() &#123; ++currentEvenvalue; //冲突点 Thread.yeild(); //提高发生冲突的可能性 ++currentEvenvalue; return currentEvenvalue; &#125; 2）使用ReentrantLock加锁 12345678910111213private Lock lock = new ReentrantLock();public int next() &#123; lock.lock(); try&#123; ++currentEvenvalue; //冲突点 Thread.yeild(); //提高发生冲突的可能性 ++currentEvenvalue; return currentEvenvalue; &#125;finally&#123; lock.unlock(); &#125; &#125; 使用lock.lock()和lock.unlock()将方法块包围起来，为这个方法块加一个互斥锁。需要注意的是，对lock()的调用，你必须放置在finally字句中带有unlock()的fry-finally语句之前。 关于wait()和sleep()方法1.wait来自Object类，sleep来自Thread类，它是一个静态方法 2.使用wait时释放了锁，使用sleep时没有释放锁 ​ 使用sleep让线程睡觉时，它不会让出资源，所以它是占着cpu睡觉的。 ​ wait是进入线程等待池等待，让出系统资源，敏感词线程可以占用cpu。然后等待敏感词线程调用notify、notifyAll唤醒等待池中的所有线程。 3.wait、notify和notifyAll只能在同步控制方法块（synchronized）中使用，sleep能够在任何地方使用，sleep需要捕获异常。","tags":[{"name":"Java","slug":"Java","permalink":"http://houghmzqqq.gihub.io/tags/Java/"},{"name":"线程","slug":"线程","permalink":"http://houghmzqqq.gihub.io/tags/线程/"}]},{"title":"数据结构之排序","date":"2017-11-01T02:13:33.000Z","path":"2017/11/01/数据结构之排序/","text":"1. 插入排序1.1 直接插入排序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对如下序列进行直接插入排序：{18,8,56,9,68,8} 1）.将第一个数据元素放入序列，即{18} 2）.插入下一个元素，得到{8,18} 3）.循环第二步，直至最后一个元素插入完毕 1.2 shell排序&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设有一个序列{18,8,15,9,5,3,8,16}，长度为n=8. 1）.对它进行划分，分成增量t=n/2，长度至多为2的多个分组，对每一个分组进行直接插入排序； 2）.然后继续划分，分成增量t=n/2，长度至多为4的多个分组，对分组排序； 3）.后面依次类推，直到增量为1. 1.3快速排序​ 快速排序的基本思想是，通过一轮的排序将序列分割成独立的两部分，其中一部分序列的关键字（这里主要用值来表示）均比另一部分关键字小。继续对长度较短的序列进行同样的分割，最后到达整体有序。在排序过程中，由于已经分开的两部分的元素不需要进行比较，故减少了比较次数，降低了排序时间。 下面用一个例子说明快速排序的过程， ​ i = j = 3， 这样序列就这样分割成了两部分，左边部分{15， 30， 17} 均小于 基准值（46）；右边部分 {56， 90，95，82}，均大于基准值。这样子我们就达到了分割序列的目标。在接着对子序列用同样的办法进行分割，直至子序列不超过一个元素，那么排序结束，整个序列处于有序状态。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://houghmzqqq.gihub.io/tags/数据结构/"}]},{"title":"数据结构之查找","date":"2017-10-16T13:00:27.000Z","path":"2017/10/16/数据结构之查找/","text":"1. 静态表的查找1.1 顺序查找&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从第一个记录开始逐个比较关键字。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;顺序查找的效率（用平均查找长度表示）ASL=(n+1)/2 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;与其他查找方法相比，顺序查找法查找成功的平均查找长度较长，但是对查找表没有什么要求，并且线性链表只能进行顺序查找。 1.2有序表的查找有序表是指查找表按关键字排序，一般采用折半查找来实现。过程如下图：对于7个元素的查找表{1,3,4,5,7,8,9}，查找关键字key=4 2. 动态查找表2.1 二叉搜索树2.1.1 二叉搜索树的定义1）如果左子树不为空，则左子树上的所有节点上的值小于根节点的值2）如果右子树不为空，则右子树上的所有节点上的值大于根节点的值3）左右子树也分别是二叉搜索树 2.1.2 二叉搜索树生成过程设关键字序列为{16,8,28,6,18,10}，则二叉树生成过程如下： 2.2 二叉平衡树（AVL树）2.2.1 定义AVL树是一种特殊的二叉搜索树，即具有以下特征的二叉搜索树：1）根的左、右子树的高度差的绝对值不大于12）根的左、右子树都是AVL树 平衡因子：根的左右子树的高度差最小不平衡节点：平衡因子的绝对值大于1的节点称为不平衡节点，高度最低的不平衡节点就是最低不平衡节点 2.2.2 失去平衡时的调整方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在平衡二叉树进行插入操作时遇到的不平衡情况有多种，但是这么多种情况都可以分解为一下四中基础情景：把它叫做：左左、左右、右右、右左。 四种情景命名意义：左左：节点插入在最小不平衡节点的&nbsp;&nbsp;左子树&nbsp;&nbsp;的&nbsp;&nbsp;左子树&nbsp;&nbsp;上。左右：节点插入在最小不平衡节点的&nbsp;&nbsp;左子树&nbsp;&nbsp;的&nbsp;&nbsp;右子树&nbsp;&nbsp;上面右右：节点插入在最小不平衡节点的&nbsp;&nbsp;右子树&nbsp;&nbsp;的&nbsp;&nbsp;右子树&nbsp;&nbsp;上面。 右左：节点插入在最小不平衡节点的&nbsp;&nbsp;右子树&nbsp;&nbsp;的&nbsp;&nbsp;左子树&nbsp;&nbsp;上面。 针对以上四种情况，各自有相对应的调整平衡的方法： 1） 左左–右旋 2） 左右–先左旋再右旋 这里解释一下为什么上图的情况需要旋转两次 上面是直接进行右旋的结果，这种情况下直接进行右旋，最后的结果还是不平衡 上图先以6为节点左旋，降低6节点右子树的高度，然后再进行右旋 3）右右–左旋 4) 右左–先右旋在左旋 与左右类似的，先对18进行右旋，调低18节点的左子树高度，在对10节点进行左旋 3.散列表3.1 概念&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashTable是一种结合数组和链表的构造方法。在线性表的存储结构中，数组和链表的特点： 数组——寻址容易，插入和删除困难链表——寻址困难，插入和删除容易 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashTable就是为了构造一种寻址容易，插入和删除也容易的存储结构。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HashTable中定义了一个数组，用来存放数据的地址，每个数组中存放一个链表的表头，用来存放数据 3.2构造散列函数的方法1）.平方取中法2）.随机数法3）.除留余数法：H(key) = key % length [length为数组长度] 3.3处理冲突的方法1）.开放定址法 如果发生冲突，则往后找空余位置， 2）.链地址发","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://houghmzqqq.gihub.io/tags/数据结构/"}]},{"title":"树和二叉树","date":"2017-10-14T12:07:02.000Z","path":"2017/10/14/树和二叉树/","text":"1. 树的定义有序树：节点的位置对树的结构有关，节点的位置改变会改变该树的意义。无序树：与有序树相反，节点的位置不关乎树的结构。二叉树：是有序树的一种。 2. 二叉树的存储结构2.1 顺序存储结构将完全二叉树的各个节点按照节点编号依次存放入数组中。 由于该树是完全二叉树，可以很容易的找到节点的的双亲节点和子节点。 对于含有n个节点的完全二叉树，任意节点i有以下关系： 1.若i=1,则节点i是根节点；若i&gt;1，则节点[i/2]为双亲节点。 2.若2i&gt;n，则节点i无左孩子，否则节点[2i]为左孩子。 3.若2i+1&gt;n，则节点无右孩子，否则节点[2i+1]为右孩子 2.2 链式存储结构在每一个节点中定义两个分别指向左孩子和右孩子节点的指针。 2.3 二叉树遍历使用递归算法 2. 普通有序树转换为二叉树 3. 哈弗曼树与哈夫曼编码3.1 哈夫曼树的几个相关概念1）路径：从树的一个节点到另一个节点的路径；对于哈夫曼树是指从根节点到某一节点的路径。2）树的路径长度：从根节点到某一节点的路径上的分支数目3）权：对某个节点定义某些属性或数值化的描述。4）带权路径长度：树中所有叶子结点的带权路径长度之和。设某个树中有n个叶子结点，他们的权值分别为w1，w1……wn，从根到各叶子结点的路径长度分别为l1,l2……ln，则该树的带权路径长度为WPL=（w1*l1 + w2*l2 + … + wn*ln）。5）哈弗曼树：设树有n个叶子结点，它们的权值分别为w1，w2……wn,其中带权路径长度WPL最小的二叉树叫做最优树，即哈弗曼树。 3.2 哈夫曼树的构建1）给定n个权值，构造由n可二叉树构成的森林。2）从森林中取出两个根节点的权值最小的两个颗树(如果这样的树不止两棵，则人选其中两棵)，分别做左右子树构造一颗新的二叉树，并置这棵二叉树的权值为其左右子树的权值之和。3）从森林中删去这两棵二叉树，并将新生成的二叉树加入森林中，循环执行 2）、3）。 3.3 哈夫曼树例题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对只含有字符{A,B,C,D}的字符串进行二进制编码。可以对每个字符进行等长编码，{A,B,C,D}分别对应{00,01,10,11},对于报文“ABCDBDBB”，它的编码为“0001101101110101”,编码长度为(1 + 4 + 1 + 2) * 2 = 16。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在这里，在已知传输的字符集合及其出现的频度的情况下，使用哈夫曼树对每个字符进行编码可以使总编码长度达到最短。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;已知{A,B,C,D}出现频度分别为{1,4,1,2},画出它的哈夫曼树： 由上图可得出字符编码： A:110B:0C:111D:10 得出字符串“ABCDBDBB”的编码为“11001111001000”，长度为(1*3+4*1+1*3+2*2) = 14。","tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://houghmzqqq.gihub.io/tags/数据结构/"}]},{"title":"BigDecimal控制精度及BigInteger解决整数溢出","date":"2017-10-13T14:15:57.000Z","path":"2017/10/13/BigDecimal控制精度及BigInteger解决整数溢出/","text":"1. BigDecimal1.1 进行精确计算1234public void test()&#123; System.out.println(0.06 + 0.01); System.out.println(1.0 - 0.42); &#125; 执行以上代码的结果是： 0.06999999999999999 0.5800000000000001 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原因在于我们的计算机是二进制的。浮点数没有办法是用二进制进行精确表示。我们的CPU表示浮点数由两个部分组成：指数和尾数，这样的表示方法一般都会失去一定的精确度，有些浮点数运算也会产生一定的误差。如：2.4的二进制表示并非就是精确的2.4。反而最为接近的二进制表示是 2.3999999999999999。浮点数的值实际上是由一个特定的数学公式计算得到的。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用BigDecimal进行精确运算 12345public static double add(double value1,double value2)&#123; BigDecimal b1 = new BigDecimal(String.valueOf(value1)); BigDecimal b2 = new BigDecimal(String.valueOf(value2)); return b1.add(b2).doubleValue(); &#125; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这里需要使用new BigDecimal(String str)构造方法实例化BigDecimal，然后通过内置的add()方法进行精确加法运算(相应的subtract()、multiply()、divide()方法进行其他运算)。[因为使用new BigDecimal(Double d) 时，得到的BigDecimal中的long值并不是精确的，使用new BigDecimal(String str)才能达到精确运算的目的] 1.2 控制精度有时会遇到保留小数点后两位，这样的要求精度的需求。可以使用BigDecimal控制。 12BigDecimal b1 = new BigDecimal(0.33333);BigDecimal b2 = b1.setScale(2,BigDecimal.ROUND_HALF_UP); 其中b1.setScale(2,BigDecimal.ROUND_HALF_UP)表示设置b1的精度为2并且采用四舍五入的策略 2. BigInteger&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;java中常规的进行整数运算的类有两个，Integer和Long，其中Long的表示范围比Integer要大，Long能够表示的最大值为2^63-1 = 9223372036854775807，当需要进行运算的数超过这个值时会发生溢出。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们可以使用BigInteger进行大整数的运算。 12BigInteger bi1 = new BigInteger(String.valueOf(10));BigInteger bi2 = bi1.multiply(new BigInteger(&quot;100000000000000000000000000000000000000000000&quot;));","tags":[{"name":"Java","slug":"Java","permalink":"http://houghmzqqq.gihub.io/tags/Java/"}]},{"title":"适配器模式","date":"2017-10-11T10:57:38.000Z","path":"2017/10/11/适配器模式/","text":"类图： 将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 Adaptee类表示被转换的类 Adapter是适配器 Traget是目标类，Adapter实现Traget，将Adaptee转换成Traget","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://houghmzqqq.gihub.io/tags/设计模式/"}]},{"title":"工厂模式","date":"2017-10-09T08:38:43.000Z","path":"2017/10/09/工厂模式/","text":"1. 简单工厂模式类图： 定义一个工厂类，将所有创建产品实例的动作交给工厂类完成。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Product是一个由工厂管理的产品类，ProductA和ProductB是它的子类。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Factory是一个简单工厂类，它拥有一个产品类属性，能够根据要求实例化用户所需的产品类。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;User是一个用户类，它表示一个向工厂申请产品实例的类，拥有一个工厂类属性。 2. 工厂方法模式类图： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在用户类中定义一个createProduct()抽象方法，在它的子类中实现该方法，在该方法中实例化产品。故称为工厂方法。工厂方法把对象的创建委托给子类，延迟创建对象的方法的实现。 3. 抽象工厂方法类图： 使用对象组合，对象的创建被实现在工厂接口所暴露出来的方法中。它可以创建相关的对象，而不需要依赖它们的具体类。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://houghmzqqq.gihub.io/tags/设计模式/"}]},{"title":"观察者模式","date":"2017-10-09T05:31:22.000Z","path":"2017/10/09/观察者模式/","text":"类图： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subject是一个观察者类，它可以添加、删除主题，观察变化并反馈给主题&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConcreteSubject是观察者的实现类&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Observer是一个主题类，它有一个update()方法，观察者通过调用这个方法通知主题进行更新&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConcreteObserver是主题的实现类 观察者实现类： 主题实现类： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subject中有个存放主题的集合，当调用registerObserver()[注册主题]方法时，将主题加入该集合中，观察者发现变化时，会调用notifyObserver()方法，notifyObserver()中通过调用主题中的update()方法提示主题进行更新。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://houghmzqqq.gihub.io/tags/设计模式/"}]},{"title":"装饰者模式","date":"2017-09-18T14:39:37.000Z","path":"2017/09/18/装饰者模式/","text":"类图： &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Component表示一个组件，也是一个超类 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConcreteComponent是一个具体组件，即相当于Component的实现类 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Decorator装饰者类,继承Component &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ConcreteDecorator具体的装饰者类，即相当于Decorator的实现类，每一个ConcreteDecorator中拥有一个Component的实例，记录所装饰的事物。在装饰者类中定义新行为，新的行为通过在旧的行为前面或后面做一些计算来达到装饰的目的","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://houghmzqqq.gihub.io/tags/设计模式/"}]},{"title":"SpringMVC笔记","date":"2017-09-16T08:26:20.000Z","path":"2017/09/16/SpringMVC笔记/","text":"1. Spring mvc 的配置1.1 首先，我们需要在web.xml中定义Spring mvc的servlet 12345678910111213141516171819202122232425&lt;!-- 配置Spring应用上下文 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt;&lt;/listener&gt;&lt;!-- DispatcherServlet,Spring MVC的核心 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 对应Spring应用的上下文 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 修改配置文件的路径 --&gt; &lt;param-value&gt;classpath:mvc-dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt; &lt;!-- 表示mvc-dispatcher拦截所有的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 1.2 配置Spring mvc 的xml文件，为 DispatcherServlet提供相应的配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!-- 本配置文件是名为mvc-dispatcher的DispatcherServlet使用的，为其提供相关的Spring MVC配置 --&gt; &lt;!-- 激活@Required等注解 --&gt; &lt;context:annotation-config/&gt; &lt;!-- DispatcherServlet上下文，只搜索@Controller注解的类 --&gt; &lt;context:component-scan base-package=\"com.yejunfeng.action\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Repository\"/&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Service\"/&gt; &lt;/context:component-scan&gt; &lt;!-- 扩充了注解驱动，可以将请求参数绑定到控制器参数 --&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:interceptors&gt; &lt;!--国际化操作拦截器 如果采用基于（请求/Session/Cookie）则必需配置--&gt; &lt;bean class=\"org.springframework.web.servlet.i18n.LocaleChangeInterceptor\" /&gt; &lt;!-- 如果不定义 mvc:mapping path 将拦截所有的URL请求 --&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**/*\"/&gt; &lt;mvc:exclude-mapping path=\"/**/fonts/*\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.css\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.js\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.png\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.gif\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.jpg\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.jpeg\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*login*\"/&gt; &lt;bean class=\"com.xyz.gym_management_sys.filter.SecurityInterceptor\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**/equ/*\"/&gt; &lt;mvc:exclude-mapping path=\"/**/fonts/*\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.css\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.js\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.png\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.gif\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.jpg\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.jpeg\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*login*\"/&gt; &lt;bean class=\"com.xyz.gym_management_sys.filter.EquManageInterceptor\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=\"/**/userManage/*\"/&gt; &lt;mvc:exclude-mapping path=\"/**/fonts/*\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.css\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.js\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.png\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.gif\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.jpg\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.jpeg\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*login*\"/&gt; &lt;bean class=\"com.xyz.gym_management_sys.filter.UserManageInterceptor\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;/mvc:interceptors&gt; &lt;!-- 静态资源处理，入css，js，image --&gt; &lt;!--&lt;mvc:resources location=\"/images/\" mapping=\"/images/**\" /&gt;--&gt; &lt;mvc:resources location=\"/lib/\" mapping=\"/lib/**\" /&gt; &lt;mvc:resources location=\"/stylesheets/\" mapping=\"/stylesheets/**\" /&gt; &lt;!-- 拼接视图的名称，prefix表示前缀，suffix表示后缀 --&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"viewClass\" value=\"org.springframework.web.servlet.view.JstlView\"&gt;&lt;/property&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsps/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 文件上传的bean配置 --&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;property name=\"maxUploadSize\" value=\"102400\" /&gt; &lt;property name=\"maxInMemorySize\" value=\"514\" /&gt; &lt;property name=\"defaultEncoding\" value=\"UTF-8\" /&gt; &lt;!--&lt;property name=\"uploadTempDir\" value=\"upload/temp\" /&gt;--&gt; &lt;/bean&gt;&lt;/beans&gt; 2.spring mvc注解2.1 @RequeseMapping(value=”path”) ​ 表示访问该action的路径名，可以注解类和类方法，类上的注解和方法上的注解拼接起来可以访问该方法。 1234567@RequestMapping(value=\"user\")public class User&#123; @RequestMapping(value=\"login\") public String login()&#123; return null; &#125;&#125; ​ 以上代码中~127.0.0.1:8080//user/login~地址可以访问user.login()方法，并返回一个视图名称。 2.2 @RequestParam ​ 用于接收浏览器发送到服务器的请求参数 1234@RequestMapping(value=\"login\")public String login(@RequestParam String userName, @RequestParam(value=\"password\") String password)&#123; return null;&#125; ​ 以上代码中，login()可以接收两个请求参数，其中第一个@RequestParam因为没有value值，所以请求参数的名字必须等于userName，否则会出错。 ​ 除了以上的接收参数的方法，Spring mvc可以将需要接收的请求参数直接封装在一个类中。 12345public class LoginInfo&#123; private String userName; private String password; ...setter and getter...&#125; 1234@RequestMapping(value=\"login\")public String login(LoginInfo logIn)&#123; return null;&#125; ​ 当然，LoginInfo中的userName和password需要和浏览器传过来的参数名称相同。 2.3 @ResponseBody ​ 将内容或对象作为HTTP响应正文返回（不返回视图，只返回内容，适合做即时校验） 12345@RequestMapping(value=\"login\")@ResponseBodypublic void login()&#123; return \"hello world!\";&#125; ​ 直接在方法上面加上该注解，当访问~127.0.0.1:8080//user/login~时，页面上显示hello world!. 3.对于Spring 中自定义servlet时获取IOC容器中的实例​ 在Spring中如果你自定义一个自动加载的servlet，那么当你在该servlet中获取IOC容器中的实例时，是取不到的，会得到一个null值，程序会报空指针异常。 解决方案： ​ 在servlet中加载Spring配置文件，通过getBean()方法获取实例，代码 123ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\");deviceService = context.getBean(DeviceService.class); 4.表单上传spring mvc 中的表单上传需要使用到MultipartFile这个类 1.表单上需要加上enctype=”multipart/form-data”，打开文件上传功能 2.通过@RequestPart注解获取文件对象 1234567@RequestMapping(value=\"/add\")public String method(@RequestPart(value=\"file01\")MultipartFile file)&#123; file.getInputStream(); file.getSize(); ... ...&#125; 5.拦截器Spring中定义一个拦截器，用于登录拦截。 第一步：定义一个拦截器。spring 中的拦截器需要继承HandlerInterceptorAdapter，它实现了java中给出的拦截器接口（具体待补充）。 123456789101112131415161718192021222324252627282930313233343536373839404142public class UserLoginInteceptorByString extends HandlerInterceptorAdapter &#123; @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; if(\"GET\".equalsIgnoreCase(request.getMethod()))&#123; // &#125; System.out.println(\"preHandle...\"); String requestUri = request.getRequestURI(); String contextPath = request.getContextPath(); String url = requestUri.substring(contextPath.length()); System.out.println(\"requestUri = \" + requestUri); System.out.println(\"contextPath = \" + contextPath); System.out.println(\"url = \" + url); String username = (String) request.getParameter(\"username\"); if(username==null || username.equals(\"\"))&#123; //未登录，跳转到登录界面// request.getRequestDispatcher(\"/WEB-INF/jsps/login.jsp\").forward(request,response); System.out.println(\"You have not login in, turn to login page...\"); return false; &#125; else&#123; System.out.println(\"You are login in, turn to the page you want...\"); return true; &#125;// return super.preHandle(request, response, handler); &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println(\"postHandle...\"); if (modelAndView != null) &#123; Map&lt;String,String&gt; map = new HashMap&lt;&gt;();// modelAndView.addAllObjects(map); &#125; &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println(\"afterCompletion...\"); &#125;&#125; 第二步：在Spring mvc的配置文件中进行拦截器的注册配置 12345678910111213141516171819&lt;mvc:interceptors&gt; &amp;lt;!&amp;ndash; 国际化操作拦截器 如果采用基于（请求/Session/Cookie）则必需配置 &amp;ndash;&amp;gt; &lt;bean class=\"org.springframework.web.servlet.i18n.LocaleChangeInterceptor\" /&gt; &amp;lt;!&amp;ndash;如果不定义 mvc:mapping path 将拦截所有的URL请求&amp;ndash;&amp;gt; &lt;mvc:interceptor&gt; &lt;!-- 拦截的url，这里表示拦截所有请求 --&gt; &lt;mvc:mapping path=\"/**/*\"/&gt; &lt;!-- 排除静态资源，不配置的话，拦截器会拦截静态资源 --&gt; &lt;mvc:exclude-mapping path=\"/**/fonts/*\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.css\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.js\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.png\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.gif\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.jpg\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*.jpeg\"/&gt; &lt;mvc:exclude-mapping path=\"/**/*login*\"/&gt; &lt;bean class=\"com.yejunfeng.interceptor.UserLoginInteceptorByString\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 当访问localhost://user/toLogin时，控制台输出： ​ preHandle…​ requestUri = /stu/toView​ contextPath =​ url = /stu/toView​ You have not login in, turn to login page… 当访问localhost://user/toLogin?username=yyy时，控制台输出： ​ preHandle… ​ requestUri = /stu/toView ​ contextPath = ​ url = /stu/toView ​ You are login in, turn to the page you want… ​ postHandle… 6.关于Spring mvc的线程安全问题对于SpringMVC和Struts2，我们知道SpringMVC是基于方法的拦截，而Struts2是基于类的拦截。 struts2每次处理一个请求，它会产生一个action的实例，所以它是不会产生线程安全问题的。 Spring的Controller默认是singleton的，这表示所有关于这个Action的请求都使用一个实例去进行处理，这样的话就容易产生线程问题。 我的解决方案： 1.在spring配置文件Controller中声明 scope=”prototype”或者使用@Scope(“prototype”)注解，每次都创建新的controller 2.使用ThreadLocal变量 3.避免在Controller中使用实例变量","tags":[{"name":"笔记","slug":"笔记","permalink":"http://houghmzqqq.gihub.io/tags/笔记/"},{"name":"框架","slug":"框架","permalink":"http://houghmzqqq.gihub.io/tags/框架/"},{"name":"spring","slug":"spring","permalink":"http://houghmzqqq.gihub.io/tags/spring/"}]},{"title":"Spring boot 笔记","date":"2017-09-09T01:32:32.000Z","path":"2017/09/09/Spring-boot-笔记/","text":"1 配置1.1 配置文件配置文件可以是.properties或.yml后缀的文件，两者的区别： 可以看出.yml比.properties文件的配置要简便 1.2 属性配置1.2.1 注解@Value(${&lt;配置文件中的属性名&gt;})：可以将配置文件中的一个属性取出，并赋给当前类的一个属性 @ConfigurationProperties(prefix=”&lt;前缀&gt;”)：将配置文件中的值赋给一个类 配置文件： 实体类： 这里将配置文件中的girl的值赋给GirlProperties 1.3 多个配置文件&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;经常会遇到这种情况，开发时的配置文件和运行时的配置文件要求不相同，这时候就需要频繁修改配置文件。spring中可以编写多个配置文件，可以按照需求转换所需的配置文件 创建三个配置文件： application.yml: application-dev.yml: application-prod.yml: 使用哪一个配置文件取决于application.yml中spring.profiles.active的定义. 当spring.profiles.active=prod时使用application-prod.yml为配置文件当spring.profiles.active=dev时使用application-dev.yml 2 Controller注解@Controller：定义一个Controller组件，返回一个模板 @RestController：定义一个Controller组件，返回String，json等 @ResquestMapping：为该类或方法定义url @PathVariable：获取url中的数据 @RequestParam：获取请求参数 @GetMapping：组合注解，相当于RequestMapping(value=&quot;&quot;,method=&quot;GET&quot;) 2.1 @PathVariable用法： 可以从url中提取数据，并赋给方法中的属性。 2.2 @RequestParam用法： 此处的required表示是否必须，defaultValue默认值 获取url中的请求参数id 3 Spring-Data-Jpajpa是定义了一系列对象持久化的标准。目前实现这一规范的数据库产品有hibernate、TopLink、JDO等。使用jpa需要导入jar包。它可以简化hibernate的配置和使用。 3.1 jpa的使用1).在application.yml配置文件中配置数据库信息 2).创建实体类 3).创建一个接口，继承JpaRepository 4).使用jpa连接数据库 4 表单验证使用@Valid注解 5 使用aop需要导入spring-boot相应的aop包，新建一个切面类，如下： 其中 @Pointcut(&quot;execution(public * com.myboot.gril..controller.GirlCotroller.*(..))&quot;) public void log(){} 表示定义一个公用的方法。避免在@Before和@After中重复定义相同的切入点。 5.1 在aop里实现日志 spring已有封装好的日志模块，在切面类中实例化org.slf4j.Logger类就可以通过里面的info方法将信息放入日志中 6 统一异常处理6.1 统一输出的数据格式在controller返回数据时，返回的单个实例和多个实例的集合格式是有区别的，这不利于视图层对数据的处理。所以我们可以对输出的数据制定一个统一的格式。方法是新建一个Result类对输出的结果进行封装： 工具类，方便封装减少重复代码： 结果: 6.2 异常管理1)、首先自定义一个异常类 2)、创建一个异常信息收集类 3)、处理异常时使用自定义的异常类进行处理 6.3 提示信息由枚举类管理在大型项目中，提示信息是非常繁多的，如果不统一进行管理的话很容易出现混乱。所以在这里新建一个enum对提示信息进行管理。 enum: 使用时通过枚举类型取出所需要的信息即可： 7 单元测试7.1 controller测试 使用到MockMvc类，可以通过url地址对controller层进行单元测试。","tags":[{"name":"笔记","slug":"笔记","permalink":"http://houghmzqqq.gihub.io/tags/笔记/"},{"name":"框架","slug":"框架","permalink":"http://houghmzqqq.gihub.io/tags/框架/"},{"name":"spring","slug":"spring","permalink":"http://houghmzqqq.gihub.io/tags/spring/"}]},{"title":"LeetCode:79.Word Search","date":"2017-09-02T08:19:39.000Z","path":"2017/09/02/LeetCode-79-Word-Search/","text":"思路原题：Given a 2D board and a word, find if the word exists in the grid. The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once. 大意：给定一个2D的字母表和一个单词，从该表中找出该单词。规则–单词可以由相邻相邻单元格的字母构成，相邻的单元格是水平或垂直相邻的单元格。同一个字母单元不能超过一次使用。 分析：对每一个点都进行深度遍历，遍历过程中发生：1.数组超出界限；2.指定位置的单词字母与该点字母不相等；3.给点已经遍历过。要进行剪枝。 代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public boolean exist(char[][] board, String word) &#123; char[] cWord = word.toCharArray(); boolean[][] isUsed = new boolean[board.length][board[0].length]; Queue&lt;Character&gt; queue = new LinkedList(); for(int i=0;i&lt;board.length;i++)&#123; for(int j=0;j&lt;board[0].length;j++)&#123; // if(cWord[0]==board[i][j])&#123; if(judge(isUsed,board,cWord,0,i,j)) return true; // &#125; &#125; &#125; return false; &#125; public boolean judge(boolean[][] isUsed,char[][] board,char[] cw,int w,int x,int y)&#123; int bLen = board.length; int bHig = board[0].length; // 坐标可以向上下左右移动 int[] bh = &#123;1,0,-1,0&#125;; int[] bw = &#123;0,1,0,-1&#125;; if(w==cw.length) return true; //剪枝 if(x&lt;0 || y&lt;0 || x&gt;=bLen || y&gt;=bHig || cw[w]!=board[x][y] || isUsed[x][y]==true) return false; isUsed[x][y] = true; for(int i=0;i&lt;4;i++)&#123; if(judge(isUsed,board,cw,w+1,x+bh[i],y+bw[i])) return true; &#125; isUsed[x][y] = false; return false; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-频度5/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/算法/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"},{"name":"连通图","slug":"连通图","permalink":"http://houghmzqqq.gihub.io/tags/连通图/"},{"name":"深度优先搜素DFS","slug":"深度优先搜素DFS","permalink":"http://houghmzqqq.gihub.io/tags/深度优先搜素DFS/"}]},{"title":"LeetCode:77.Combinations","date":"2017-09-02T08:01:58.000Z","path":"2017/09/02/LeetCode-77-Combinations/","text":"思路原题：Given two integers n and k, return all possible combinations of k numbers out of 1 … n. For example,If n = 4 and k = 2, a solution is: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4],] 大意：给定两个数字n和k，返回1…n中k个数字的所有排列组合结果。 分析：通过递归创建分支：1.当长度为k时，加入结果集；2.当剩下的元素与当前的元素相加小于k时，跳出该分支。（与LeetCode49题类似）(78题也与本题相似) 代码123456789101112131415161718192021222324252627282930313233class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;Integer&gt; midList = new ArrayList(); List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); group(midList,res,n,k,1); return res; &#125; public void group(List&lt;Integer&gt; midList,List&lt;List&lt;Integer&gt;&gt; res,int n,int k,int x)&#123; //List&lt;Integer&gt; ns = new ArrayList(nList); List&lt;Integer&gt; l1 = new ArrayList(midList); //长度等于k是，加入结果集 if(l1.size()==k)&#123; res.add(l1); return ; &#125; if(l1.size()+n-x+1&lt;k)&#123; return ; &#125; for(int i=x;i&lt;=n;i++)&#123; //创建分之后回溯 l1 = new ArrayList(midList); //创建分支 l1.add(i); group(l1,res,n,k,i+1); &#125; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-频度5/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/算法/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"},{"name":"递归","slug":"递归","permalink":"http://houghmzqqq.gihub.io/tags/递归/"},{"name":"排列组合","slug":"排列组合","permalink":"http://houghmzqqq.gihub.io/tags/排列组合/"}]},{"title":"LeetCode:67.Add Binary","date":"2017-09-02T07:52:37.000Z","path":"2017/09/02/LeetCode-67-Add-Binary/","text":"思路原题：Given two binary strings, return their sum (also a binary string). 大意：给定一个二进制字符串，输出它们的和，结果也是一个二进制。 分析：这道题中，将两个字符串拆分成字符数组，逐位进行相加即可，要注意进位标志。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class Solution &#123; public String addBinary(String a, String b) &#123; int c = 0; char[] ac = a.toCharArray(); char[] bc = b.toCharArray(); int aLen = ac.length-1; int bLen = bc.length-1; //存放结果，由于从低位开始运算，输出时需要将结果倒转 StringBuffer buffer = new StringBuffer(); //进行二进制加法运算 while(aLen&gt;=0 &amp;&amp; bLen&gt;=0)&#123; if((ac[aLen]==&apos;1&apos; &amp;&amp; bc[bLen]==&apos;0&apos;) || (ac[aLen]==&apos;0&apos; &amp;&amp; bc[bLen]==&apos;1&apos;))&#123; if(c==1) &#123; buffer.append(&quot;0&quot;); c = 1; &#125;else&#123; buffer.append(&quot;1&quot;); &#125; &#125; else if((ac[aLen]==&apos;0&apos; &amp;&amp; bc[bLen]==&apos;0&apos;))&#123; if(c==1)&#123; buffer.append(&quot;1&quot;); c = 0; &#125;else&#123; buffer.append(&quot;0&quot;); &#125; &#125; else if(ac[aLen]==&apos;1&apos; &amp;&amp; bc[bLen]==&apos;1&apos;)&#123; if(c==1)&#123; buffer.append(&quot;1&quot;); &#125;else&#123; buffer.append(&quot;0&quot;); &#125; c = 1; &#125; aLen--; bLen--; &#125; //其中一个或两个数都相加完，处理剩余的进位标志 if(aLen&lt;0 || bLen&lt;0)&#123; int max = Math.max(aLen,bLen); char[] temp; if(bLen&lt;0) temp = ac; else temp = bc; for(int i=max;i&gt;=0;i--)&#123; if(c==1 &amp;&amp; temp[i]==&apos;0&apos;)&#123; buffer.append(&quot;1&quot;); c = 0; &#125; else if(c==1 &amp;&amp; temp[i]==&apos;1&apos;)&#123; buffer.append(&quot;0&quot;); c = 1; &#125; else if(c==0)&#123; buffer.append(temp[i]); &#125; &#125; &#125; if(c==1)&#123; buffer.append(&quot;1&quot;); &#125; return buffer.reverse().toString(); &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-频度5/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/算法/"},{"name":"Hard","slug":"Hard","permalink":"http://houghmzqqq.gihub.io/tags/Hard/"}]},{"title":"LeetCode:49.Group Anagrams","date":"2017-09-01T15:10:31.000Z","path":"2017/09/01/LeetCode-49-Group-Anagrams/","text":"思路原题：Given an array of strings, group anagrams together. 大意：给定一个String数组，将拥有相同字母的字符串归为一类。 分析：将每个单词按照a~z顺序排序，将排序后相同的字符串放入同一个集合中。 代码12345678910111213141516171819202122232425262728293031class Solution &#123; public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123; List&lt;List&lt;String&gt;&gt; res = new ArrayList(); //存放排序后的字符串，和原字符串 Map&lt;String,List&lt;String&gt;&gt; map = new HashMap(); for(String str : strs)&#123; //对每一个字符串进行重组 char[] c = str.toCharArray(); Arrays.sort(c); String tempStr = String.valueOf(c); //重组后，若未出现过，创建新的集合存放原字符串； //若之前出现过，取出与该字符串相对应的集合，将原字符串放入。 if(map.get(tempStr)==null)&#123; List&lt;String&gt; l1 = new ArrayList(); l1.add(str); map.put(tempStr,l1); &#125;else&#123; map.get(tempStr).add(str); &#125; &#125; for(Map.Entry&lt;String,List&lt;String&gt;&gt; entry : map.entrySet())&#123; res.add(entry.getValue()); &#125; return res; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-频度5/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/算法/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"},{"name":"递归","slug":"递归","permalink":"http://houghmzqqq.gihub.io/tags/递归/"},{"name":"排列组合","slug":"排列组合","permalink":"http://houghmzqqq.gihub.io/tags/排列组合/"}]},{"title":"LeetCode:46.Permutations","date":"2017-09-01T14:58:10.000Z","path":"2017/09/01/LeetCode-46-Permutations/","text":"思路原题：Given a collection of distinct numbers, return all possible permutations. 大意：给定一个数字集合，求所有排列组合的集合 分析：以集合[1,2,3,4]为例，分别以1,2,3,4,为开头建立分支，在1为开头的分支中，分别以2,3,4建立分支，以此类推。使用递归的方式创建分支。 代码1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); List&lt;Integer&gt; firstList = new ArrayList(); List&lt;Integer&gt; midList = new ArrayList(); for(int num : nums)&#123; firstList.add(num); &#125; getList(firstList,midList,res); return res; &#125; //递归方法 public void getList(List&lt;Integer&gt; l1,List&lt;Integer&gt; l2,List&lt;List&lt;Integer&gt;&gt; res)&#123; List&lt;Integer&gt; midList = new ArrayList(l2); List&lt;Integer&gt; list = new ArrayList(); if(l1.size()!=0 &amp;&amp; l1!=null)&#123; for(int i=0;i&lt;l1.size();i++)&#123; //没创建一个分支，进行回溯，保证list和midList中个数不变 list = new ArrayList(l1); midList = new ArrayList(l2); midList.add(list.get(i)); list.remove(i); //创建分支 getList(list,midList,res); &#125; &#125; //返回条件 if(l1.size()==0 || l1==null) res.add(midList); &#125; &#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-频度5/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/算法/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"}]},{"title":"LeetCode:27.Remove Element","date":"2017-09-01T13:25:51.000Z","path":"2017/09/01/LeetCode-27-Remove-Element/","text":"思路原题：Given an array and a value, remove all instances of that value in place and return the new length. Do not allocate extra space for another array, you must do this in place with constant memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. 大意：给定一个数组和一个常数，删除该数组中所有和该常数相等的值，输出剩余的值。结果返回一个常数，表示结果数组的长度。 分析：循环遍历数组，当数组中的值等于val时，将该元素和从尾部算起不等于val的元素互换；当头部元素和尾部元素相交，跳出该次循环。 代码1234567891011121314151617181920212223242526272829303132class Solution &#123; public int removeElement(int[] nums, int val) &#123; //记录尾部开始计算，等于val的数组元素个数 int hasChange = 0; int len = nums.length; for(int i=0;i&lt;len;i++)&#123; //剩下的可能需要处理的元素 int chanLen = len-hasChange-1; if(i&gt;chanLen) break; if(nums[i]==val)&#123; for(int j=chanLen;j&gt;=0;j--)&#123; //num[j]在num[i]前面，结束循环 if(i&gt;j) break; if(nums[j]!=val)&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; hasChange++; break; &#125; hasChange++; &#125; &#125; &#125; return len-hasChange; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-频度5/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/算法/"},{"name":"Easy","slug":"Easy","permalink":"http://houghmzqqq.gihub.io/tags/Easy/"}]},{"title":"LeetCode:24.Swap Nodes in Pairs","date":"2017-09-01T12:51:35.000Z","path":"2017/09/01/LeetCode-24-Swap-Nodes-in-Pairs/","text":"思路原题：Given a linked list, swap every two adjacent nodes and return its head.For example, Given 1-&gt;2-&gt;3-&gt;4, you should return the list as 2-&gt;1-&gt;4-&gt;3. Your algorithm should use only constant space. You may not modify the values in the list, only nodes itself can be changed. 大意：给定一个链表，将相邻的两个节点互换。只能够使用恒定的物理空间，不能够改变节点的值，只能够改变节点本身。 分析：这道题中需要定义1个辅助变量root。 代码123456789101112131415161718192021222324252627282930/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode swapPairs(ListNode head) &#123; ListNode root = new ListNode(-1); root.next = head; ListNode pre_head = root; while(head != null &amp;&amp; head.next!= null)&#123; ListNode Node1 = head; ListNode Node2 = head.next.next; root.next = head.next; //改变单数节点 root = root.next; //改变双数节点 root.next = Node1; //跳转到下一对要置换的节点 Node1.next = Node2; root = root.next; head = Node2; &#125; return pre_head.next; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-频度5/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/算法/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"}]},{"title":"LeetCode:23.Merge k Sorted Lists","date":"2017-08-21T07:23:24.000Z","path":"2017/08/21/LeetCode-23-Merge-k-Sorted-Lists/","text":"思路原题：Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity. 大意：合并k个已排序的链表并返回一个合并后的链表。注意时间复杂度。 解法一分析：最简单的方法是遍历每一个链表的当前节点，并取出最小的一个数加入result（结果链表）中，取出数字的链表当前节点后移。该方法的时间复杂度较高。 代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; ListNode head = new ListNode(0); ListNode result = head; //链表数组转化为ArrayList,方便对链表数量进行增删 List&lt;ListNode&gt; nodeList = new ArrayList(Arrays.asList(lists)); //过滤空链表 for(int i=0;i&lt;nodeList.size();i++)&#123; if(nodeList.get(i)==null)&#123; nodeList.remove(i); i--; &#125; &#125; if(nodeList.size()==1) return nodeList.get(0); while(nodeList.size()&gt;1)&#123; Map&lt;Integer,Integer&gt; map = new HashMap(); int min = nodeList.get(0).val; map.put(min,0); for(int i=1;i&lt;nodeList.size();i++)&#123; if(nodeList.get(i).val&lt;min)&#123; min=nodeList.get(i).val; map.put(min,i); &#125; &#125; result.next = new ListNode(min); //result.next.val = min; result = result.next; int index = map.get(min); if(nodeList.get(index).next==null) nodeList.remove(index); else nodeList.set(index,nodeList.get(index).next); if(nodeList.size()==1)&#123; result.next = nodeList.get(0); &#125; &#125; return head.next; &#125;&#125; 方法二：基于“二分”思想的归并排序分析：进行循环合并链表，对于k个链表，总节点数为n，每一次循环使链表的数量减少为(k+1)/2。在每次循环中：lists[0]与lists[(k+1)/2]合并，lists[1]与lists[(k+1)/2+1]合并，lists[2]与lists[(k+1)/2+2]合并，类推…… 代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; int len = lists.length; if(lists==null || len==0) return null; if(len==1) return lists[0]; //进行归并排序 while(len&gt;1)&#123; int mid = (len+1)/2; for(int i=0;i&lt;len/2;i++)&#123; lists[i] = merge(lists[i],lists[i+mid]); &#125; len = mid; &#125; return lists[0]; &#125; //对lists[i],lists[(k+1)/2+i]进行合并 public ListNode merge(ListNode node01,ListNode node02)&#123; ListNode head = new ListNode(0); ListNode result = head; while(node01!=null &amp;&amp; node02!=null)&#123; if(node01.val&lt;=node02.val)&#123; result.next = node01; node01 = node01.next; &#125; else&#123; result.next = node02; node02 = node02.next; &#125; result = result.next; &#125; if(node01!=null) result.next = node01; else result.next = node02; return head.next; &#125;&#125; 方法三：基于优先级队列的堆排序分析：使用Java api中的优先级队列（Priority Queue），将所有链表的当前节点offer进堆中，PriorityQueue会根据实现了Comparable接口的实现类中的compareTo方法，将符合条件的元素放在堆顶，我们将堆顶的元素逐个取出放入结果链表中即可。 代码：1234567891011121314151617181920212223242526272829303132//实现Comparable接口public class ListNode implements Comparable&lt;ListNode&gt;&#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; //PriorityQueue根据该方法决定放在堆顶的元素 public int compareTo(ListNode l1)&#123; return val-l1.val; &#125;&#125;class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; ListNode head = new ListNode(0); ListNode result = head; Queue&lt;ListNode&gt; queue = new PriorityQueue(Arrays.asList(lists)); if(lists==null || lists.length==0) return null; if(lists.length==1) return lists[0]; while(queue.size()&gt;0)&#123; ListNode l1 = queue.poll(); result.next = l1; if(l1.next!=null) queue.offer(l1.next); &#125; return head.next; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-频度5/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/算法/"},{"name":"Hard","slug":"Hard","permalink":"http://houghmzqqq.gihub.io/tags/Hard/"}]},{"title":"数据库中视图的作用","date":"2017-08-14T12:19:49.000Z","path":"2017/08/14/数据库中视图的作用/","text":"视图是从一个或几个基本表（或视图）导出的表。它与基本表不同，是一个虚表。数据库只存放视图的定义，而不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。从这个意义上讲，视图就像一个窗口，透过它可以看到数据库中自己感兴趣的数据及其变化。 1、 视图能简化用户操作视图机制使用户可以将注意力集中在所关心地数据上。如果这些数据不是直接来自基本表，则可以通过定义视图，使数据库看起来结构简单、清晰，并且可以简化用户的的数据查询操作。例如，那些定义了若干张表连接的视图，就将表与表之间的连接操作对用户隐藏起来了。换句话说，用户所作的只是对一个虚表的简单查询，而这个虚表是怎样得来的，用户无需了解。 2、 视图使用户能以多种角度看待同一数据视图机制能使不同的用户以不同的方式看待同一数据，当许多不同种类的用户共享同一个数据库时，这种灵活性是非常必要的。 3、 视图对重构数据库提供了一定程度的逻辑独立性数据的物理独立性是指用户的应用程序不依赖于数据库的物理结构。数据的逻辑独立性是指当数据库重构造时，如增加新的关系或对原有的关系增加新的字段，用户的应用程序不会受影响。层次数据库和网状数据库一般能较好地支持数据的物理独立性，而对于逻辑独立性则不能完全的支持。 在关系数据库中，数据库的重构造往往是不可避免的。重构数据库最常见的是将一个基本表“垂直”地分成多个基本表。例如：将学生关系Student（Sno，Sname，Ssex，Sage，Sdept）， 分为SX（Sno，Sname，Sage）和SY（Sno，Ssex，Sdept）两个关系。这时原表Student为SX表和SY表自然连接的结果。如果建立一个视图Student：12345CREATE VIEW Student（Sno，Sname，Ssex，Sage，Sdept）ASSELECT SX.Sno，SX.Sname，SY.Ssex，SX.Sage，SY.SdeptFROM SX，SYWHERE SX.Sno=SY.Sno； 这样尽管数据库的逻辑结构改变了（变为SX和SY两个表了），但应用程序不必修改，因为新建立的视图定义为用户原来的关系，使用户的外模式保持不变，用户的应用程序通过视图仍然能够查找数据。 当然，视图只能在一定程度上提供数据的逻辑独立，比如由于视图的更新是有条件的，因此应用程序中修改数据的语句可能仍会因为基本表构造的改变而改变。 4、视图能够对机密数据提供安全保护有了视图机制，就可以在设计数据库应用系统时，对不同的用户定义不同的视图，使机密数据不出现在不应该看到这些数据的用户视图上。这样视图机制就自动提供了对机密数据的安全保护功能。例如，Student表涉及全校15个院系学生数据，可以在其上定义15个视图，每个视图只包含一个院系的学生数据，并只允许每个院系的主任查询和修改本原系学生视图。 5、适当的利用视图可以更清晰地表达查询例如经常需要执行这样的查询“对每个学生找出他获得最高成绩的课程号”。可以先定义一个视图，求出每个同学获得的最高成绩：12345CREATE VIEW VMGRADEASSELECT Sno，MAX(Grade) MgradeFROM SCGROUP BY Sno； 然后用如下的查询语句完成查询： SELECT SC.Sno，Cno FROM SC，VMGRADE WHERE SC.Sno = VMGRADE.Sno AND SC.Grade = VMGRADE.Mgrade；","tags":[{"name":"数据库","slug":"数据库","permalink":"http://houghmzqqq.gihub.io/tags/数据库/"}]},{"title":"LeetCode:127.Word Ladder","date":"2017-08-14T05:58:46.000Z","path":"2017/08/14/LeetCode-127-Word-Ladder/","text":"思路原题：Given two words (beginWord and endWord), and a dictionary’s word list, find the length of shortest transformation sequence from beginWord to endWord, such that: 1.Only one letter can be changed at a time. 2.Each transformed word must exist in the word list. Note that beginWord is not a transformed word. 大意：给出两个单词（开始单词和结束单词）和一个字典，查找字典中从开始单词转变为结束单词的最短路径，规则如下： 1.一次只能改变一个单词 2.每一个转换后的单词必须为字典中的单词。开始单词不算是转换单词（即结束单词算是）。 分析：查找最短路径，首先想到的是数据结构中连通图的广度搜索算法（BFS）。 定义一个栈midList，存放图中的灰色元素，白色元素为列表root，长度存放在Map中 代码1234567891011121314151617181920212223242526272829303132333435363738public class Solution &#123; public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123; Queue&lt;String&gt; midList = new LinkedList(); midList.offer(beginWord); Map&lt;String,Integer&gt; map = new HashMap(); map.put(beginWord,1); if(!wordList.contains(endWord)) return 0; if(wordList.contains(beginWord)) wordList.remove(beginWord); while(!midList.isEmpty())&#123; String top = midList.poll(); StringBuilder builder; int level = map.get(top); for(int i=0;i&lt;top.length();i++)&#123; for(char c=&apos;a&apos;;c&lt;=&apos;z&apos;;c++)&#123; builder = new StringBuilder(top); builder.setCharAt(i,c); String tepStr = builder.toString(); if(top==tepStr) continue; if(tepStr.equals(endWord)) return level+1; if(wordList.contains(tepStr))&#123; midList.offer(tepStr); wordList.remove(tepStr); map.put(tepStr,level+1); &#125; &#125; &#125; &#125; return 0; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-频度5/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/算法/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"}]},{"title":"LeetCode:125.Valid Palindrome","date":"2017-08-14T05:44:45.000Z","path":"2017/08/14/LeetCode-125-Valid-Palindrome/","text":"思路原题：Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.For example, “A man, a plan, a canal: Panama” is a palindrome. “race a car” is not a palindrome. 大意：判断给定的一个字符串是不是有效的回文（忽略空格和除字母和数字意外的符号） 分析：从头部和尾部同时开始进行比较判断，遇到无效字符就跳过。 代码123456789101112131415161718192021222324252627public class Solution &#123; public boolean isPalindrome(String s) &#123; char[] chars = s.toCharArray(); int t = chars.length - 1; for(int h=0;h&lt;chars.length;h++)&#123; if(!Character.isDigit(chars[h]) &amp;&amp; !Character.isLetter(chars[h])) continue; else if(!Character.isDigit(chars[t]) &amp;&amp; !Character.isLetter(chars[t]))&#123; t--; h--; continue; &#125; if(h&gt;=t) return true; //转换大小写 if(Character.isLetter(chars[h]) || Character.isLetter(chars[t]))&#123; chars[h] = Character.toLowerCase(chars[h]); chars[t] = Character.toLowerCase(chars[t]); &#125; if(chars[h]!=chars[t]) return false; t--; &#125; return true; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-频度5/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/算法/"},{"name":"Easy","slug":"Easy","permalink":"http://houghmzqqq.gihub.io/tags/Easy/"}]},{"title":"LeetCode:98.Validate Binary Search Tree","date":"2017-08-14T05:28:14.000Z","path":"2017/08/14/LeetCode-98-Validate-Binary-Search-Tree/","text":"思路原题：Given a binary tree, determine if it is a valid binary search tree (BST).Assume a BST is defined as follows: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. 大意：判断一个二叉树是不是二叉搜索树（BST）。二叉搜索树的定义： 左边的节点小于父节点 右边的节点大于父节点 子树也是二叉搜索树 分析：因为一个节点的子节点需要与该节点的父节点相比较，所以这里定义两个Integer类型的属性min和max，分别用作和左子节点和右子节点作比较。然后用一个递归 算法遍历一遍二叉树。 代码123456789101112131415161718192021222324252627/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; Map&lt;TreeNode,TreeNode&gt; map = new HashMap(); public boolean isValidBST(TreeNode root) &#123; return isValid(root,null,null); &#125; public boolean isValid(TreeNode root,Integer min,Integer max)&#123; if(root==null) return true; if(min!=null &amp;&amp; root.val&lt;=min) return false; if(max!=null &amp;&amp; root.val&gt;=max) return false; return isValid(root.left,min,root.val) &amp;&amp; isValid(root.right,root.val,max); &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-频度5/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/算法/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"}]},{"title":"LeetCode:73.Set Matrix Zeroes","date":"2017-08-13T04:37:41.000Z","path":"2017/08/13/LeetCode-73-Set-Matrix-Zeroes/","text":"思路原题：Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in place. 大意：给定一个mXn的矩阵，如果一个元素，将该元素所在的行和列的所有元素设置为0。 分析：将第一行和第一列作为工具，先判断第一行和第一列中是否存在0，做上标记；判断其他元素，如果一个元素为0，将该元素所在的第一行和第一列元素标记为0；最后再根据第一行和第一列对所有元素进行转换。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Solution &#123; public void setZeroes(int[][] matrix) &#123; int rowLength = matrix.length; int colLength = matrix[0].length; boolean isFirstRowHasZeo = false; boolean isFirstColHasZeo = false; for(int i=0;i&lt;rowLength;i++)&#123; if(matrix[i][0]==0)&#123; isFirstColHasZeo = true; break; &#125; &#125; for(int i=0;i&lt;colLength;i++)&#123; if(matrix[0][i]==0)&#123; isFirstRowHasZeo = true; break; &#125; &#125; for(int i=1;i&lt;matrix.length;i++)&#123; for(int j=1;j&lt;matrix[i].length;j++)&#123; if(matrix[i][j]==0)&#123; matrix[i][0] = 0; matrix[0][j] = 0; &#125; &#125; &#125; for(int i=1;i&lt;rowLength;i++)&#123; for(int j=1;j&lt;colLength;j++)&#123; if(matrix[i][0]==0 || matrix[0][j]==0)&#123; matrix[i][j] = 0; &#125; &#125; &#125; if(isFirstRowHasZeo)&#123; for(int i=0;i&lt;colLength;i++)&#123; matrix[0][i] = 0; &#125; &#125; if(isFirstColHasZeo)&#123; for(int i=0;i&lt;rowLength;i++)&#123; matrix[i][0] = 0; &#125; &#125; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-频度5/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/算法/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"}]},{"title":"LeetCode:57.Insert Interval","date":"2017-08-07T13:09:56.000Z","path":"2017/08/07/LeetCode-57-Insert-Interval/","text":"思路原题：Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary). You may assume that the intervals were initially sorted according to their start times. 大意：给一个不重合的时间间隔的集合，插入一个新的间隔，进行排列并合并重合的间隔。该集合按照start升序排列。 分析：可以先将插入的数据按照start排列进入集合中，然后再逐个合并重合的间隔。在这里，合并时分为向上合并和向下合并。向上合并只有可能和插入后的上一个元素合并。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */public class Solution &#123; public List&lt;Interval&gt; insert(List&lt;Interval&gt; intervals, Interval newInterval) &#123; Interval inta, intb; int index = 0; //记录插入元素的位置 //将插入的间隔按start插入集合中 intervals.add(newInterval); for(int i=intervals.size()-1;i&gt;0;i--)&#123; if(intervals.get(i).start&lt;intervals.get(i-1).start)&#123; Interval temp = intervals.get(i); intervals.set(i,intervals.get(i-1)); intervals.set(i-1,temp); &#125;else&#123; index = i; break; &#125; &#125; //判断是否和上一个元素合并 if(index != 0)&#123; inta = intervals.get(index-1); intb = intervals.get(index); if(inta.start&lt;=intb.start &amp;&amp; inta.end&gt;=intb.start)&#123; intervals.get(index-1).end = Math.max(inta.end,intb.end); intervals.remove(index); index--; &#125; &#125; //循环判断是否和后面的元素合并 while(true)&#123; if(index+1&gt;=intervals.size())&#123; break; &#125; inta = intervals.get(index); intb = intervals.get(index+1); if(inta.end&gt;=intb.start)&#123; intervals.get(index).end = Math.max(inta.end,intb.end); intervals.remove(index+1); &#125;else&#123; break; &#125; &#125; return intervals; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-频度5/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/算法/"},{"name":"Hard","slug":"Hard","permalink":"http://houghmzqqq.gihub.io/tags/Hard/"}]},{"title":"LeetCode:56.Merge Intervals","date":"2017-08-07T07:30:58.000Z","path":"2017/08/07/LeetCode-56-Merge-Intervals/","text":"！（该答案在LeetCode官网上运行时出现超时错误，需要优化） 思路原题：Given a collection of intervals, merge all overlapping intervals. For example, Given [1,3],[2,6],[8,10],[15,18], return [1,6],[8,10],[15,18]. 大意：给一个含有多个时间间隔的集合，合并所有重合的部分。 分析：给出多个时间间隔，它们两两之间存在以下两种种可能性： 1.两个间隔不相交，如[1,2]和[3,4] 4.两个间隔相交，如[1,3]和[2,4] 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */public class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; int count = 0; List&lt;Interval&gt; result = new ArrayList(); List&lt;Integer&gt; temps = new ArrayList(); //先按照start进行升序排序 for(int i=0;i&lt;intervals.size()-1;i++)&#123; for(int j=i+1;j&lt;intervals.size();j++)&#123; if(intervals.get(i).start&gt;intervals.get(j).start)&#123; Interval flag = intervals.get(i); intervals.set(i,intervals.get(j)); intervals.set(j,flag); &#125; &#125; &#125; for(int i=0;i&lt;intervals.size();i++)&#123; Interval inter01 = intervals.get(i); //判断当前元素之前是否已经被合并 boolean ifJump = false; for(Integer temp : temps)&#123; if(i==temp)&#123; ifJump = true; &#125; &#125; if(ifJump)&#123; continue; &#125; for(int j=i+1;j&lt;intervals.size();j++)&#123; Interval inter02 = intervals.get(j); //第一种情况，两个范围不相交 if(inter01.end&lt;inter02.start || inter01.start&gt;inter02.end)&#123; continue; &#125; //第二种情况，两个范围存在包含关系 else if((inter01.start&lt;inter02.start &amp;&amp; inter01.end&gt;inter02.end) || (inter01.start&gt;inter02.start &amp;&amp; inter01.end&lt;inter02.end))&#123; if(inter01.start&gt;inter02.start &amp;&amp; inter01.end&lt;inter02.end)&#123; inter01.start = inter02.start; inter01.end = inter02.end; &#125; temps.add(j); &#125; //第三种情况，有元素相等 else if(inter01.start==inter02.start || inter01.end==inter02.end)&#123; if(inter01.start&gt;inter02.start)&#123; inter01.start = inter02.start; inter01.end = inter02.end; &#125;else if(inter01.end&lt;inter02.end)&#123; inter01.start = inter02.start; inter01.end = inter02.end; &#125; temps.add(j); &#125; //第四种情况，两个范围相交 else if((inter01.start&lt;inter02.start &amp;&amp; inter01.end&lt;inter02.end) || (inter01.start&gt;inter02.start &amp;&amp; inter01.end&gt;inter02.end))&#123; if(inter01.start&lt;inter02.start &amp;&amp; inter01.end&lt;inter02.end)&#123; inter01.end = inter02.end; &#125;else&#123; inter01.start = inter02.start; &#125; temps.add(j); &#125; &#125; //过滤相等的结果 if(result.size()==0)&#123; result.add(inter01); &#125;else if(result.get(count).start==inter01.start &amp;&amp; result.get(count).end==inter01.end)&#123; &#125;else&#123; result.add(inter01); count++; &#125; &#125; return result; &#125;&#125; 优化分析：先根据start进行排序，然后进行合并，合并条件a.start &lt;= b.start &lt;= a.end 代码（优）123456789101112131415161718192021222324252627282930313233/** * Definition for an interval. * public class Interval &#123; * int start; * int end; * Interval() &#123; start = 0; end = 0; &#125; * Interval(int s, int e) &#123; start = s; end = e; &#125; * &#125; */public class Solution &#123; public List&lt;Interval&gt; merge(List&lt;Interval&gt; intervals) &#123; //根据interval的start排序 Collections.sort(intervals, new Comparator&lt;Interval&gt;() &#123; @Override public int compare(Interval o1, Interval o2) &#123; return o1.start - o2.start; &#125; &#125;); for(int i=0;i&lt;intervals.size()-1;i++)&#123; Interval inta = intervals.get(i); Interval intb = intervals.get(i+1); if(inta.start&lt;=intb.start &amp;&amp; inta.end&gt;=intb.start)&#123; intervals.get(i).end = Math.max(inta.end,intb.end); intervals.remove(i+1); i--; &#125; &#125; return intervals; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-频度5/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/算法/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"}]},{"title":"LeetCode:70.Climbing Stairs","date":"2017-07-28T12:00:07.000Z","path":"2017/07/28/LeetCode-70-Climbing-Stairs/","text":"思路原题：You are climbing a stair case. It takes n steps to reach to the top. Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top? 大意：你去爬一座山，山脚到山顶有n级台阶。没一次你可以爬一或两级台阶。计算到达山顶有几种走法。 分析：假设有n级台阶，有s种走法，那么当n=1,s=1;n=2,s=2;n=3,s=3;n=4,s=5;n=5,s=8;很明显，这是一个裴波那切数列，可以使用递归的方式进行计算，公式为f(n)=f(n-2)+f(n-1). 代码12345678910public class Solution &#123; public int climbStairs(int n) &#123; if(n==1 || n==2)&#123; return n; &#125; else&#123; return climbStairs(n-2)+climbStairs(n-1); &#125; &#125;&#125; 另一种解法分析：递归是从目标值算到基础值，可以反过来，通过迭代的方式从基础值算到目标值。 代码123456789101112131415public class Solution &#123; public int climbStairs(int n) &#123; if(n==1 || n==2)&#123; return n; &#125; int n1 = 1; int n2 = 2; for(int i=3;i&lt;=n;i++)&#123; int temp = n1+n2; n1 = n2; n2 = temp; &#125; return n2; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-频度5/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/算法/"},{"name":"Easy","slug":"Easy","permalink":"http://houghmzqqq.gihub.io/tags/Easy/"}]},{"title":"spring学习笔记","date":"2017-07-26T12:53:00.000Z","path":"2017/07/26/spring学习笔记/","text":"1.IOC(控制反转)转移控制权——由外部容器进行对象的创建，并进行对象控制权的管理。应用程序本身不进行对象的创建，有外部容器完成创建对象和管理，当应用程序需要使用对象是，向容器进行申请。 DI(依赖注入)——是IOC的一中实现方法，通过容器将程序所要依赖的对象注入。一个例子： 房间中介——–IOC 找中介———-找IOC容器 租房子———-IOC返回对象 入住————程序使用对象 2.Spring注入方式2.1设值注入通过setter方法注入的方式 1234567public class MyTest&#123; private Bean bean; //通过setter方法注入 public void setBean(Bean bean)&#123; this.bean = bean; &#125;&#125; 2.2构造器注入通过在构造器中声明变量进行注入 1234567public class MyTest&#123; private Bean bean; //通过构造方法注入 public MyTest(Bean bean)&#123; this.bean = bean; &#125;&#125; 3.Bean作用域 singleton:单例，一个IOC容器中只存在一个 prototype:每次请求（每次使用）创建新的实例，destroy方法不生效 request:每次http请求创建一个实例且仅在当前request内有效 session:与上类似，每次http请求创建，当前session中有效 global session:基于portlet的web中有效 生命周期 配置文件中定义，IOC容器初始化，使用，IOC容器销毁 Aware spring提供一些以Aware结尾的接口，实现这些接口的Bean可以使用部分资源 3.1Bean的装配 通过xml文件进行显示配置 在Java中进行显示配置 隐式的Bean发现机制和自动装配 自动装配：在配置文件的beans标签中加入default autowire=“no/byName/byType/constructor”属性（作用是，当在一个bean中调用另外一个bean时，不需要在配置文件中标明） Resource和ResourceLoder ApplicationContext默认实现了Resource接口，可以通过ApplicationContext获取Resource Resource resource = ctx.getResource(); 加载资源文件的接口 3.2Bean的注解 @Component：通用的注解，可用于所有Bean @Repository：有针对性的Bean注解，Dao层 @Service：Service层 @Controller：Controller层 @Scope：类级别的注解，定义该Bean的作用域，可自定义。 3.3类的自动检测和Bean的注册 自动检测需要在配置文件中设置，使用标签(其中base-package表示需要检测的包名称)和，因为前者（常用）包含后者的功能，所以使用前者后一般不使用后者; 3.4其他注解 @Autowired &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以在setter方法、成员变量和构造方法上进行注解 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以注解BeanFactory、ApplicationContext、ResourceLoder等接口 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;@Autowired注解是由BeanPostProcessor处理的，所以不能对BeanPostProcessor、BeanFactoryPOSTProcessor等接口进行注解，必须在xml文件中声明 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于有多个实现类的接口，使用@Autowired注解List或Map可以自动将接口的实现类都装配进入List或Map中，其中Map中的String为Bean的名称 @Qualifier（”BeanName”） &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于有多个实现类的接口，使用@Autowired注解时，可以使用@Qualifier注解指定需要装配的实现类 3.5在Java中进行显示装配12345678@Configurationpublic class AppConfig&#123; @Bean（&quot;BeanName&quot;） public MyService myService()&#123; return new MyServiceImpl(); &#125;&#125;相当于配置文件中的\\&lt;bean/\\&gt;标签 @Bean标签有InitMethod和destoryMethod属性，定义初始化和销毁方法 @Scope，一般与@Bean一起使用，设置Bean的作用域（单例或多例等） 4.AOP AOP即面向切面编程，通过预编译方式或运行期动态代理实现程序功能的统一维护的一种技术 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;主要的应用模块是：日志记录，性能统计，安全控制，事物处理，异常处理等 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如上图所示，一个系统中有产品、订单、用户等多个模块，每一个模块都需要使用事务管理，如果在每个模块中都编写事务管理的代码，工作量将会很大；使用AOP的思想，将事务管理的功能独立出来，当某个模块需要使用时，通过预编译或动态代理的方式，赋予它该功能。 4.1AOP配置aspect切面123456789&lt;aop:config&gt; &lt;aop:aspect id=&quot;myAspect&quot; ref=&quot;myBean&quot;&gt; ...（&lt;aop:ponitcut/&gt;） &lt;/aop:aspect&gt;&lt;/aop:config&gt;&lt;bean id=&quot;myBean&quot; class=&quot;...&quot;&gt; ...&lt;/bean&gt; 4.2配置pointcut切入点 等。。。。。。 补充：5.事务管理5.1编程式事务管理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。 5.2声明式事务管理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务。声明式事务最大的优点就是不需要通过编程的方式管理事务，这样就不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明(或通过基于@Transactional注解的方式)，便可以将事务规则应用到业务逻辑中。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;声明式事务管理也有两种常用的方式，一种是基于tx和aop名字空间的xml配置文件，另一种就是基于@Transactional注解。显然基于注解的方式更简单易用，更清爽。 application.xml中配置声明式事务管理： 1234567891011121314151617181920212223242526&lt;!-- 配置Hibernate Session --&gt; &lt;bean id=&quot;sessionFactory&quot; class=&quot;org.springframework.orm.hibernate4.LocalSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;property name=&quot;hibernateProperties&quot;&gt; &lt;props&gt; &lt;prop key=&quot;hibernate.dialect&quot;&gt;org.hibernate.dialect.MySQLDialect&lt;/prop&gt; &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt; &lt;prop key=&quot;hibernate.format_sql&quot;&gt;false&lt;/prop&gt; &lt;prop key=&quot;hibernate.cache.use_second_level_cache&quot;&gt;false&lt;/prop&gt; &lt;prop key=&quot;hibernate.cache.use_query_cache&quot;&gt;false&lt;/prop&gt; &lt;prop key=&quot;current_session_context_class&quot;&gt;thread&lt;/prop&gt; &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt; &lt;prop key=&quot;hibernate.current_session_context_class&quot;&gt;org.springframework.orm.hibernate4.SpringSessionContext&lt;/prop&gt; &lt;prop key=&quot;c3p0.min_size&quot;&gt;5&lt;/prop&gt; &lt;prop key=&quot;c3p0.max_size&quot;&gt;30&lt;/prop&gt; &lt;prop key=&quot;c3p0.time_out&quot;&gt;1800&lt;/prop&gt; &lt;prop key=&quot;c3p0.max_statement&quot;&gt;50&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- 实体类的包 --&gt; &lt;property name=&quot;packagesToScan&quot;&gt; &lt;list&gt; &lt;value&gt;com.*.po&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 1234&lt;!-- 配置事务管理器 --&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.orm.hibernate4.HibernateTransactionManager&quot;&gt; &lt;property name=&quot;sessionFactory&quot; ref=&quot;sessionFactory&quot; /&gt; &lt;/bean&gt; 12345678910111213141516&lt;!-- 事务advice --&gt; &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt; &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;list*&quot; read-only=&quot;true&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;find*&quot; read-only=&quot;true&quot; propagation=&quot;REQUIRED&quot; /&gt; &lt;tx:method name=&quot;*&quot; read-only=&quot;false&quot; propagation=&quot;REQUIRED&quot; rollback-for=&quot;Exception&quot;/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; proxy-target-class=&quot;true&quot; /&gt; &lt;!-- 配置切面 --&gt; &lt;aop:config proxy-target-class=&quot;true&quot;&gt; &lt;aop:advisor pointcut=&quot;execution(public * com.xyz.gym_management_sys.service.*Service.*(..))&quot; advice-ref=&quot;txAdvice&quot; /&gt; &lt;/aop:config&gt;","tags":[{"name":"笔记","slug":"笔记","permalink":"http://houghmzqqq.gihub.io/tags/笔记/"},{"name":"框架","slug":"框架","permalink":"http://houghmzqqq.gihub.io/tags/框架/"},{"name":"spring","slug":"spring","permalink":"http://houghmzqqq.gihub.io/tags/spring/"}]},{"title":"LeetCode:20.Valid Parentheses","date":"2017-07-23T06:34:25.000Z","path":"2017/07/23/LeetCode-20-Valid-Parentheses/","text":"思路原题：Given a string containing just the characters ‘(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ and ‘]’, determine if the input string is valid. The brackets must close in the correct order, “()” and “()[]{}” are all valid but “(]” and “([)]” are not. 大意：给一个只包含’(‘, ‘)’, ‘{‘, ‘}’, ‘[‘ , ‘]’等字符的字符串，判断该字符串中的所有括号是否有效。 分析：根据题意，可以判断出有效的括号 like_this”()”,”()[]”,”({})”，无效括号like_this”((“,”]]”,”([)]”,”()[“。 步骤： 1、排除明显错误的答案（字符数量为单数时） 2、遍历所有字符，遇到开括号(如”(“,”[“,”{“)时，放入list中 3、遇到闭括号，与list中的最后一个字符匹配 代码12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public boolean isValid(String s) &#123; char[] paren = s.toCharArray(); List&lt;Character&gt; openParen = new ArrayList(); //存放开括号 //排除明显错误的答案 if(paren.length%2 != 0) &#123; return false; &#125; for(Character p : paren)&#123; int type; if( p==&apos;(&apos; || p==&apos;[&apos; || p==&apos;&#123;&apos; )&#123; openParen.add(p); &#125; if( p==&apos;)&apos; || p==&apos;]&apos; || p==&apos;&#125;&apos; )&#123; if(openParen.size()==0)&#123; return false; &#125; int lastIndex = openParen.size()-1; if(!(openParen.get(lastIndex)==&apos;(&apos; &amp;&amp; p==&apos;)&apos; || openParen.get(lastIndex)==&apos;[&apos; &amp;&amp; p==&apos;]&apos; || openParen.get(lastIndex)==&apos;&#123;&apos; &amp;&amp; p==&apos;&#125;&apos;))&#123; return false; &#125;else&#123; openParen.remove(lastIndex); &#125; &#125; &#125; if(openParen.size()!=0)&#123; return false; &#125; return true; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-频度5/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/算法/"},{"name":"Easy","slug":"Easy","permalink":"http://houghmzqqq.gihub.io/tags/Easy/"}]},{"title":"LeetCode:15.3Sum","date":"2017-07-22T13:53:10.000Z","path":"2017/07/22/LeetCode-15-3Sum/","text":"思路原题：Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note: The solution set must not contain duplicate triplets. 大意：给一个包含n个整数的数组，找出所有符合a+b+c=0的元素数组。提示：a,b,c符合条件a&lt;=b&lt;=c，结果不能重复。 初次分析：题目要求结果要排序并且不能重复，所以可以先对数组进行排序，在通过三重for循环得出结果，因为需要查重，所以需要四重for循环。 步骤（1）： 1、对数组进行排序 2、三重循环遍历所有可能的元素 3、得到结果后，对比是否重复 4、结果放入List中 代码（1）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;Integer&gt; sum = null; List&lt;List&lt;Integer&gt;&gt; sums = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for(int i=nums.length-1;i&gt;0;i--) &#123; for(int j=0;j&lt;i;j++) &#123; if(nums[j+1]&lt;nums[j]) &#123; int temp; temp = nums[j]; nums[j] = nums[j+1]; nums[j+1] = temp; &#125; &#125; &#125; for(int x=0;x&lt;nums.length-2;x++) &#123; for(int y=x+1;y&lt;nums.length-1;y++) &#123; for(int z=y+1;z&lt;nums.length;z++) &#123; if(nums[x]+nums[y]+nums[z] == 0) &#123; sum = new ArrayList&lt;Integer&gt;(); boolean repeat = false; sum.add(nums[x]); sum.add(nums[y]); sum.add(nums[z]); for(List&lt;Integer&gt; comp : sums) &#123; if(sum.get(0)==comp.get(0) &amp;&amp; sum.get(1)==comp.get(1) &amp;&amp; sum.get(2)==comp.get(2)) &#123; repeat = true; &#125; &#125; if(!repeat) &#123; sums.add(sum); &#125; &#125; &#125; &#125; &#125; return sums; &#125;&#125; 这个答案submit后出错，提示：Time Limit Exceeds(超时)。经分析，是因为套入多重的for循环，时间复杂度大，当数组的基数较大时，运行时间会超出限制。 修改解决方案：减少for循环的层数。通过查找资料了解到，可以借助map避免第三层循环。 步骤（2）： 1、对数组进行排序 2、定义一个map，以nums（给定数组）的值为 key ，以list（该值在数组中的index）为value。 3、遍历数组，排除明显不符合条件的结果，并得出符合条件的结果。 4、结果放入List中 代码（2）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;Integer&gt; sum = null; List&lt;List&lt;Integer&gt;&gt; sums = new ArrayList&lt;List&lt;Integer&gt;&gt;(); //排序 for(int i=nums.length-1;i&gt;0;i--) &#123; for(int j=0;j&lt;i;j++) &#123; if(nums[j+1]&lt;nums[j]) &#123; int temp; temp = nums[j]; nums[j] = nums[j+1]; nums[j+1] = temp; &#125; &#125; &#125; //nums数组中的数字分组放入map中，并记录它们的index(改操作可以减少一重循环) Map&lt;Integer,List&lt;Integer&gt;&gt; map = new HashMap(); for(int i=0;i&lt;nums.length;i++) &#123; int num = nums[i]; if(map.get(num)==null) &#123; List&lt;Integer&gt; lastOnes = new ArrayList(); lastOnes.add(i); map.put(num,lastOnes); &#125; else &#123; map.get(num).add(i); &#125; &#125; for(int y=0;y&lt;nums.length-2;y++) &#123; //因为已排序，当第一个数大于0时，不能满足a+b+c=0 if(nums[y]&gt;0) &#123; break; &#125; //nums[y]==nums[y-1]说明num[y]之前已经进行过判断,跳过 if(y&gt;0 &amp;&amp; nums[y] == nums[y-1]) &#123; continue; &#125; for(int z=y+1;z&lt;nums.length-1;z++) &#123; //与上同理 if(z&gt;y+1 &amp;&amp; nums[z]==nums[z-1]) &#123; continue; &#125; //计算数字c int finalNum = -nums[y] -nums[z]; //c为abc中最后一个数字，所以c &gt;= b if(finalNum &lt; nums[z]) &#123; break; &#125; //查找nums中值为finalNum的List，不存在则跳过 List&lt;Integer&gt; lastOnes = map.get(finalNum); if(lastOnes == null) &#123; continue; &#125; for(Integer lastOne : lastOnes) &#123; if(lastOne&gt;z) &#123; sum = new ArrayList(); sum.add(nums[y]); sum.add(nums[z]); sum.add(nums[lastOne]); sums.add(sum); break; &#125; &#125; &#125; &#125; return sums; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-频度5/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/算法/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"}]},{"title":"LeetCode:8.String to Integer (atoi)","date":"2017-07-19T09:20:19.000Z","path":"2017/07/19/LeetCode-8-String-to-Integer-atoi/","text":"思路原题：Implement atoi to convert a string to an integer. 大意：实现字符串转换成int，参考atoi函数 分析：要求实现atoi函数相似的功能，通过查找资料了解到atoi函数的作用—— 1.如果字符前面有空格，跳过。 2.第一个有效字符可以为‘+’或‘-’号。 3.转换过程中如果遇到非数字符号或空格，停止转换，输出当前已转换的数字需要注意int的溢出问题 步骤： 1、过滤前面的空格 2、判断正负 3、转换有效数字 4、判断是否溢出。为了防止溢出现象，本人使用Long类型来暂时存储数字，由于long也有边界值会溢出，所以添加一个length变量来记录数字的长度 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class Solution &#123; public int myAtoi(String str) &#123; Long s = 0l; int length = 0; char[] strChar = str.toCharArray(); boolean theFirst = true; boolean isJumpSymbol = false; boolean flag = false; if (str == null || str.equals(&quot;&quot;)) return 0; for (Character c : strChar) &#123; // 1.不为空 if (!Character.isWhitespace(c)) &#123; // 检测有效字符，有效字符串前面的空格已经跳过，做上标记 if (isJumpSymbol == false) &#123; isJumpSymbol = true; &#125; // 2.第一个字符为正负符号 if ((c.equals(&apos;-&apos;) || c.equals(&apos;+&apos;)) &amp;&amp; theFirst == true) &#123; theFirst = false; // 如果为负号，做上标记 if (c.equals(&apos;-&apos;)) &#123; flag = true; &#125; &#125; else &#123; // 3.是否为数字 if (Character.isDigit(c)) &#123; // 记录有效数字的长度 if (length &gt; 10) break; length++; switch (c) &#123; case &apos;0&apos;: s = s * 10 + 0; break; case &apos;1&apos;: s = s * 10 + 1; break; case &apos;2&apos;: s = s * 10 + 2; break; case &apos;3&apos;: s = s * 10 + 3; break; case &apos;4&apos;: s = s * 10 + 4; break; case &apos;5&apos;: s = s * 10 + 5; break; case &apos;6&apos;: s = s * 10 + 6; break; case &apos;7&apos;: s = s * 10 + 7; break; case &apos;8&apos;: s = s * 10 + 8; break; case &apos;9&apos;: s = s * 10 + 9; break; &#125; &#125; else &#123; break; &#125; &#125; &#125; else if (Character.isWhitespace(c) &amp;&amp; isJumpSymbol == true) &#123; break; &#125; &#125; // 判断是否溢出 if (flag) &#123; if (-s &lt; Integer.MIN_VALUE) return Integer.MIN_VALUE; &#125; else &#123; if (s &gt; Integer.MAX_VALUE) return Integer.MAX_VALUE; &#125; return (int) (s * (flag ? -1 : 1)); &#125;&#125; 心得&nbsp;&nbsp;&nbsp;&nbsp;这一题让我理解的测试的重要性，血的教训啊！！！T。T","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-频度5/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/算法/"},{"name":"Medium","slug":"Medium","permalink":"http://houghmzqqq.gihub.io/tags/Medium/"}]},{"title":"LeetCode:4.Median of Two Sorted Arrays","date":"2017-07-17T08:20:28.000Z","path":"2017/07/17/LeetCode-4-Median-of-Two-Sorted-Arrays/","text":"思路原题：There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). 大意：给出两个已经排好序的int数组，将其合并，获取中数并返回。 分析：要求获取两个数组合并后的中数。首先要进行的是对两个数组的合并，然后对合并后的数组进行排序，由于给出的数组本身已经排序，所以可以很容易地在合并的过程中进行排序，最后取出中数加以计算即可。 步骤：1、将两个数组合并，合并过程中进行排序 2、计算中数 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Solution &#123; public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123; int[] numAccount = new int[nums1.length+nums2.length]; //两个int数组合并为一个，并排序 int i=0; int j=0; for(int z=0;z&lt;numAccount.length;z++) &#123; //判断是否超出数组范围 if(i &gt;= nums1.length) &#123; numAccount[z] = nums2[j]; j++; &#125; else if(j &gt;= nums2.length) &#123; numAccount[z] = nums1[i]; i++; &#125; //先比较大小再填入numAccount数组中 else if(nums1[i]&lt;=nums2[j]) &#123; numAccount[z] = nums1[i]; i++; &#125; else if(nums2[j]&lt;nums1[i]) &#123; numAccount[z] = nums2[j]; j++; &#125; &#125; //取出中数 if(numAccount.length%2 == 1) &#123; return numAccount[numAccount.length/2]; &#125; else &#123; int midNum1,midNum2; midNum1 = numAccount[(numAccount.length/2) - 1]; midNum2 = numAccount[numAccount.length/2]; return (double)(midNum1 + midNum2) /2; &#125; &#125;&#125;","tags":[{"name":"LeetCode-频度5","slug":"LeetCode-频度5","permalink":"http://houghmzqqq.gihub.io/tags/LeetCode-频度5/"},{"name":"算法","slug":"算法","permalink":"http://houghmzqqq.gihub.io/tags/算法/"},{"name":"Hard","slug":"Hard","permalink":"http://houghmzqqq.gihub.io/tags/Hard/"}]},{"title":"浅析String、StringBuffer、StringBuider的区别","date":"2017-07-08T12:48:38.000Z","path":"2017/07/08/浅析String、StringBuffer、StringBuider的区别/","text":"1 String浅析1.1 String对象的创建&nbsp;&nbsp;&nbsp;&nbsp;我们先来了解一下String对象的创建过程。&nbsp;&nbsp;&nbsp;&nbsp;要创建String对象，很普遍的一种方法是利用构造器 String str = new String(&quot;Hello World&quot;)，问题是这里的参数”Hello World”是什么东西？也是一个String对象？&nbsp;&nbsp;&nbsp;&nbsp;还有一种常用的创建方式，String str = &quot;Hello World&quot;,与创建基本数据类型相似。&nbsp;&nbsp;&nbsp;&nbsp;我们知道，Java程序运行之前，编译器会先将源代码文件编译成Class文件，然后再由JVM继续执行，在class字节流中有一个常量池，用于放置源代码中的符号信息(并且不同的符号信息放置在不同标志的常量表中)，其中有四个不同类型的常量表。上述”Hello World”字符串在编译成Class文件时，被存放进常量池中用于存放字符串的常量表中，JVM加载Class文件时，会将该常量表中的字符串取出&nbsp;并在堆中创建新的String对象（intern字符串对象，又称拘留字符串对象）。&nbsp;&nbsp;&nbsp;&nbsp;简单来说，就是在运行阶段&nbsp;String str == &quot;Hello World&quot; &nbsp;中的字符串”Hello World”被转换成&nbsp;拘留字符串&nbsp;对象被压入&nbsp;堆&nbsp;中 参照事例1： 12345678//代码1String s1 = new String(&quot;Hello&quot;);String s2 = new String(&quot;Hello&quot;);System.out.println(s1==s2);//代码2String s3 = &quot;Hello&quot;;String s4 = &quot;Hello&quot;;System.out.println(s3==s4); 输出为： false true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行代码1时，jvm先为字面值“Hello”创建了一个拘留字符串对象，再将拘留字符串的值赋予给new的对象，所以这里的s1、s2存放的是new出来的对象的地址；执行2代码时，s3、s4存储的时拘留字符串的地址。 参照事例2： 12345678910//代码1String s1 = &quot;ab&quot;;String s2 = &quot;cd&quot;;String s12 = s1 + s2;String s = &quot;abcd&quot;;System.out.println(s12==s);//代码2String s1 = &quot;ab&quot; + &quot;cd&quot;;String s2 = &quot;abcd&quot;;System.out.println(s1==s2); 输出为： false true &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;执行上述代码1时，JVM会在堆中先创建一个以s1所指向的拘留字符串对象完成初始化的StringBuilder对象，并使用append方法对s2进行拼接，然后用toString()方法在堆中创建一个String对象，所以s12、s指向两个不同的地址；执行代码2时，“ab”+”cd”会在编译器就合并成“abcd”，因此它指向对应的拘留字符串。 StringBuffer和StringBuilder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer和StringBuilder功能一样，都是用于字符串缓冲，但是StringBuffer是线程安全的，StringBuilder是线程不安全的。由于StringBuilder所有方面都没有被synchronized修饰，因此它的效率要比StringBuffer高。","tags":[{"name":"Java","slug":"Java","permalink":"http://houghmzqqq.gihub.io/tags/Java/"}]},{"title":"markdown文件（即.md后缀文件）的基本常用编写语法","date":"2017-07-01T12:51:11.000Z","path":"2017/07/01/markdown文件（即-md后缀文件）的基本常用编写语法/","text":"现在的前端基本上都用上了前端构建工具，难免要写一些readme等等的说明性文件，这样的文件一般都是.md的文件，所以在这里记录一下.md文件的一些基本编写语法1.标题的三种写法1）第一个字符为#、##、###、。。。、######，表示h1~h6 # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题 2）适用于标题一和标题二，在标题下面一行加上”======”或”——-“，分别表示标题一和标题二（”=”和”-“数量没有限制） 标题一 ====== 标题二 ------ 3）与第一种相似，左右两边均加上#号（与标题之间有一个空格） # 一级标题 # ## 二级标题 ## 。 。 。 2.列表1）无序列表下面是效果： 选项1 选项2 选项3 下面是语法： * 选项1 * 选项2 * 选项3 + 选项1 + 选项2 + 选项3 - 选项1 - 选项2 - 选项3 2）有序列表效果如下： 选项1 选项2 选项3 格式为： 1. 选项1 2. 选项2 3. 选项3 .前面的数字并不影响显示时的序号，例如： 3. 选项1 7. 选项2 1. 选项3 的显示结果和前面的是一样的。 3.区块应用1）如果你想对某个部分的内容做一些说明或者引用某某人的话时可以使用到效果如下： 问题1 这是对问题一的说明 语法： * 问题1 &gt; 这是对问题一的说明 2）多级引用格式： &gt; 一级引用 &gt;&gt; 二级引用 &gt;&gt;&gt; 三级引用 4.分割线分割线可以由* - _（星号，减号，底线）这3个符号的至少3个符号表示，注意至少要3个，且不需要连续，有空格也可以： * * * （星号） _ _ _ （下划线） - - - （减号） 5.链接1）行内式点击这里跳转到百度 [点击这里](http://www.baidu.com)跳转到百度 2) 参数式 更多内容请转github [github]: &lt;https://houghmzqqq.github.io/&gt; &quot;博主github主页&quot; 更多内容请转[github] 这里将链接定义为参数，需要用到的时候写”参数名”即可 6.图片和链接类似，分为行内式和参数式 行内式：![图片](url) 前面的！号是必须的，url为图片地址 参数式：[图片]:url 7.引用代码单行用`代码`（蜜汁符号，Esc下面那个建），多行```代码``` `String role = &quot;student&quot;;` \\123 String role1 = &quot;student&quot;; String role2 = &quot;teacher&quot;;\\ 效果：String role = &quot;student&quot;; 12String role1 = &quot;student&quot;;String role2 = &quot;teacher&quot;; 8.表格可以实现如下效果： name age sex tony 18 man lucy 17 woman 如下两种写法均可，第一种中的“：”号表示对齐方式，左边有表示左对齐，两边有表示居中 | name | age | sex | |:----|:---:|---:| | tony | 18 | man | | lucy | 17 | woman | name | age | sex ---- |---- |---- tony | 18 | man lucy | 17 | woman 9.强调这是倾斜效果 这是加粗效果 语法： *这是倾斜效果* _这是倾斜效果_ __这是加粗效果__ 10.转义在需要转义的字符前加上“\\”即可 11.删除线删除我吧 ~~删除我吧~~","tags":[{"name":"零碎","slug":"零碎","permalink":"http://houghmzqqq.gihub.io/tags/零碎/"}]}]